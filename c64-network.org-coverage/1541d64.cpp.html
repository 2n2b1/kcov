<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Coverage - ./frodo</title>
  <link rel="stylesheet" type="text/css" href="bcov.css"/>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="title">Coverage Report</td></tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr>
    <td width="100%">
      <table cellpadding="1" border="0" width="100%">
        <tr>
          <td class="headerItem" width="20%">Command:</td>
          <td class="headerValue" width="80%" colspan=6>./frodo</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Date:</td>
          <td class="headerValue" width="15%">2010-08-23 20:44:07</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Instrumented&nbsp;lines:</td>
          <td class="headerValue" width="10%">768</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Code&nbsp;covered:</td>
          <td class="headerValue" width="15%">11.7 %</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Executed&nbsp;lines:</td>
          <td class="headerValue" width="10%">90</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
</table>
<pre class="source">
<span class="lineNum">      1 </span>              : /* </span>
<span class="lineNum">      2 </span>              :  *  1541d64.cpp - 1541 emulation in disk image files (.d64/.x64/zipcode) </span>
<span class="lineNum">      3 </span>              :  * </span>
<span class="lineNum">      4 </span>              :  *  Frodo (C) 1994-1997,2002-2005 Christian Bauer </span>
<span class="lineNum">      5 </span>              :  *  zipcode decoding routines (C) 1993-1997 Marko M&#c3;&#a4;kel&#c3;&#a4;, Paul David Doherty </span>
<span class="lineNum">      6 </span>              :  * </span>
<span class="lineNum">      7 </span>              :  *  This program is free software; you can redistribute it and/or modify </span>
<span class="lineNum">      8 </span>              :  *  it under the terms of the GNU General Public License as published by </span>
<span class="lineNum">      9 </span>              :  *  the Free Software Foundation; either version 2 of the License, or </span>
<span class="lineNum">     10 </span>              :  *  (at your option) any later version. </span>
<span class="lineNum">     11 </span>              :  * </span>
<span class="lineNum">     12 </span>              :  *  This program is distributed in the hope that it will be useful, </span>
<span class="lineNum">     13 </span>              :  *  but WITHOUT ANY WARRANTY; without even the implied warranty of </span>
<span class="lineNum">     14 </span>              :  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the </span>
<span class="lineNum">     15 </span>              :  *  GNU General Public License for more details. </span>
<span class="lineNum">     16 </span>              :  * </span>
<span class="lineNum">     17 </span>              :  *  You should have received a copy of the GNU General Public License </span>
<span class="lineNum">     18 </span>              :  *  along with this program; if not, write to the Free Software </span>
<span class="lineNum">     19 </span>              :  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA </span>
<span class="lineNum">     20 </span>              :  */ </span>
<span class="lineNum">     21 </span>              :  </span>
<span class="lineNum">     22 </span>              : /* </span>
<span class="lineNum">     23 </span>              :  *  Incompatibilities: </span>
<span class="lineNum">     24 </span>              :  *   - No support for relative files </span>
<span class="lineNum">     25 </span>              :  *   - Unimplemented commands: P </span>
<span class="lineNum">     26 </span>              :  *   - Impossible to implement: B-E, M-E </span>
<span class="lineNum">     27 </span>              :  */ </span>
<span class="lineNum">     28 </span>              :  </span>
<span class="lineNum">     29 </span>              : #include &quot;sysdeps.h&quot; </span>
<span class="lineNum">     30 </span>              :  </span>
<span class="lineNum">     31 </span>              : #include &quot;1541d64.h&quot; </span>
<span class="lineNum">     32 </span>              : #include &quot;IEC.h&quot; </span>
<span class="lineNum">     33 </span>              : #include &quot;Prefs.h&quot; </span>
<span class="lineNum">     34 </span>              : #include &quot;C64.h&quot; </span>
<span class="lineNum">     35 </span>              : #include &quot;main.h&quot; </span>
<span class="lineNum">     36 </span>              : #include &quot;utils.hh&quot; </span>
<span class="lineNum">     37 </span>              :  </span>
<span class="lineNum">     38 </span>              : #define DEBUG 0 </span>
<span class="lineNum">     39 </span>              : #include &quot;debug.h&quot; </span>
<span class="lineNum">     40 </span>              :  </span>
<span class="lineNum">     41 </span>              :  </span>
<span class="lineNum">     42 </span>              : // Channel modes (IRC users listen up :-) </span>
<span class="lineNum">     43 </span>              : enum { </span>
<span class="lineNum">     44 </span>              : 	CHMOD_FREE,			// Channel free </span>
<span class="lineNum">     45 </span>              : 	CHMOD_COMMAND,		// Command/error channel </span>
<span class="lineNum">     46 </span>              : 	CHMOD_DIRECTORY,	// Reading directory, using large allocated buffer </span>
<span class="lineNum">     47 </span>              : 	CHMOD_FILE,			// Sequential file open, using buffer in 1541 RAM </span>
<span class="lineNum">     48 </span>              : 	CHMOD_REL,			// Relative file open, using buffer in 1541 RAM </span>
<span class="lineNum">     49 </span>              : 	CHMOD_DIRECT		// Direct buffer access ('#'), using buffer in 1541 RAM </span>
<span class="lineNum">     50 </span>              : }; </span>
<span class="lineNum">     51 </span>              :  </span>
<span class="lineNum">     52 </span>              : // Directory track </span>
<span class="lineNum">     53 </span>              : const int DIR_TRACK = 18; </span>
<span class="lineNum">     54 </span>              :  </span>
<span class="lineNum">     55 </span>              : // BAM structure </span>
<span class="lineNum">     56 </span>              : enum { </span>
<span class="lineNum">     57 </span>              : 	BAM_DIR_TRACK = 0,		// Track... </span>
<span class="lineNum">     58 </span>              : 	BAM_DIR_SECTOR = 1,		// ...and sector of first directory block (unused) </span>
<span class="lineNum">     59 </span>              : 	BAM_FMT_TYPE = 2,		// Format type </span>
<span class="lineNum">     60 </span>              : 	BAM_BITMAP = 4,			// Sector allocation map </span>
<span class="lineNum">     61 </span>              : 	BAM_DISK_NAME = 144,	// Disk name </span>
<span class="lineNum">     62 </span>              : 	BAM_DISK_ID = 162,		// Disk ID </span>
<span class="lineNum">     63 </span>              : 	BAM_FMT_CHAR = 165		// Format characters </span>
<span class="lineNum">     64 </span>              : }; </span>
<span class="lineNum">     65 </span>              :  </span>
<span class="lineNum">     66 </span>              : // Directory structure </span>
<span class="lineNum">     67 </span>              : enum { </span>
<span class="lineNum">     68 </span>              : 	DIR_NEXT_TRACK = 0,		// Track... </span>
<span class="lineNum">     69 </span>              : 	DIR_NEXT_SECTOR = 1,	// ... and sector of next directory block </span>
<span class="lineNum">     70 </span>              : 	DIR_ENTRIES = 2,		// Start of directory entries (8) </span>
<span class="lineNum">     71 </span>              :  </span>
<span class="lineNum">     72 </span>              : 	DE_TYPE = 0,			// File type/flags </span>
<span class="lineNum">     73 </span>              : 	DE_TRACK = 1,			// Track... </span>
<span class="lineNum">     74 </span>              : 	DE_SECTOR = 2,			// ...and sector of first data block </span>
<span class="lineNum">     75 </span>              : 	DE_NAME = 3,			// File name </span>
<span class="lineNum">     76 </span>              : 	DE_SIDE_TRACK = 19,		// Track... </span>
<span class="lineNum">     77 </span>              : 	DE_SIDE_SECTOR = 20,	// ...and sector of first side sector </span>
<span class="lineNum">     78 </span>              : 	DE_REC_LEN = 21,		// Record length </span>
<span class="lineNum">     79 </span>              : 	DE_OVR_TRACK = 26,		// Track... </span>
<span class="lineNum">     80 </span>              : 	DE_OVR_SECTOR = 27,		// ...and sector on overwrite (@) </span>
<span class="lineNum">     81 </span>              : 	DE_NUM_BLOCKS_L = 28,	// Number of blocks, LSB </span>
<span class="lineNum">     82 </span>              : 	DE_NUM_BLOCKS_H = 29,	// Number of blocks, MSB </span>
<span class="lineNum">     83 </span>              :  </span>
<span class="lineNum">     84 </span>              : 	SIZEOF_DE = 32			// Size of directory entry </span>
<span class="lineNum">     85 </span>              : }; </span>
<span class="lineNum">     86 </span>              :  </span>
<span class="lineNum">     87 </span>              : // Interleave of directory and data blocks </span>
<span class="lineNum">     88 </span>              : const int DIR_INTERLEAVE = 3; </span>
<span class="lineNum">     89 </span>              : const int DATA_INTERLEAVE = 10; </span>
<span class="lineNum">     90 </span>              :  </span>
<span class="lineNum">     91 </span>              : // Number of sectors per track, for all tracks </span>
<span class="lineNum">     92 </span>              : const int num_sectors[41] = { </span>
<span class="lineNum">     93 </span>              : 	0, </span>
<span class="lineNum">     94 </span>              : 	21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21, </span>
<span class="lineNum">     95 </span>              : 	19,19,19,19,19,19,19, </span>
<span class="lineNum">     96 </span>              : 	18,18,18,18,18,18, </span>
<span class="lineNum">     97 </span>              : 	17,17,17,17,17, </span>
<span class="lineNum">     98 </span>              : 	17,17,17,17,17		// Tracks 36..40 </span>
<span class="lineNum">     99 </span>              : }; </span>
<span class="lineNum">    100 </span>              :  </span>
<span class="lineNum">    101 </span>              : // Accumulated number of sectors </span>
<span class="lineNum">    102 </span>              : const int accum_num_sectors[41] = { </span>
<span class="lineNum">    103 </span>              : 	0, </span>
<span class="lineNum">    104 </span>              : 	0,21,42,63,84,105,126,147,168,189,210,231,252,273,294,315,336, </span>
<span class="lineNum">    105 </span>              : 	357,376,395,414,433,452,471, </span>
<span class="lineNum">    106 </span>              : 	490,508,526,544,562,580, </span>
<span class="lineNum">    107 </span>              : 	598,615,632,649,666, </span>
<span class="lineNum">    108 </span>              : 	683,700,717,734,751	// Tracks 36..40 </span>
<span class="lineNum">    109 </span>              : }; </span>
<span class="lineNum">    110 </span>              :  </span>
<span class="lineNum">    111 </span>              : // Prototypes </span>
<span class="lineNum">    112 </span>              : static bool match(const uint8 *p, int p_len, const uint8 *n); </span>
<span class="lineNum">    113 </span>              : static FILE *open_image_file(const char *path, bool write_mode); </span>
<span class="lineNum">    114 </span>              : static bool parse_image_file(FILE *f, image_file_desc &amp;desc); </span>
<span class="lineNum">    115 </span>              :  </span>
<span class="lineNum">    116 </span>              :  </span>
<span class="lineNum">    117 </span>              : /* </span>
<span class="lineNum">    118 </span>              :  *  Constructor: Prepare emulation, open image file </span>
<span class="lineNum">    119 </span>              :  */ </span>
<span class="lineNum">    120 </span>              :  </span>
<span class="lineNum">    121 </span><span class="linePartCov">    2 / 4     : ImageDrive::ImageDrive(IEC *iec, const char *filepath) : Drive(iec), the_file(NULL), bam(ram + 0x700), bam_dirty(false) </span>
<span class="lineNum">    122 </span>              : { </span>
<span class="lineNum">    123 </span><span class="linePartCov">    1 / 2     : 	for (int i=0; i&lt;18; i++) { </span>
<span class="lineNum">    124 </span><span class="linePartCov">    1 / 2     : 		ch[i].mode = CHMOD_FREE; </span>
<span class="lineNum">    125 </span><span class="linePartCov">    1 / 2     : 		ch[i].buf = NULL; </span>
<span class="lineNum">    126 </span>              : 	} </span>
<span class="lineNum">    127 </span><span class="linePartCov">    1 / 2     : 	ch[15].mode = CHMOD_COMMAND; </span>
<span class="lineNum">    128 </span>              :  </span>
<span class="lineNum">    129 </span>              : 	memset(&amp;this-&gt;desc, 0, sizeof(this-&gt;desc)); </span>
<span class="lineNum">    130 </span>              :  </span>
<span class="lineNum">    131 </span><span class="linePartCov">    1 / 2     : 	Reset(); </span>
<span class="lineNum">    132 </span>              :  </span>
<span class="lineNum">    133 </span>              : 	// Open image file </span>
<span class="lineNum">    134 </span><span class="linePartCov">    1 / 2     : 	if (change_image(filepath)) </span>
<span class="lineNum">    135 </span><span class="linePartCov">    1 / 2     : 		Ready = true; </span>
<span class="lineNum">    136 </span><span class="linePartCov">    1 / 2     : } </span>
<span class="lineNum">    137 </span>              :  </span>
<span class="lineNum">    138 </span>              :  </span>
<span class="lineNum">    139 </span>              : /* </span>
<span class="lineNum">    140 </span>              :  *  Destructor </span>
<span class="lineNum">    141 </span>              :  */ </span>
<span class="lineNum">    142 </span>              :  </span>
<span class="lineNum">    143 </span><span class="linePartCov">    2 / 6     : ImageDrive::~ImageDrive() </span>
<span class="lineNum">    144 </span>              : { </span>
<span class="lineNum">    145 </span><span class="linePartCov">    1 / 3     : 	close_image(); </span>
<span class="lineNum">    146 </span><span class="linePartCov">    1 / 3     : } </span>
<span class="lineNum">    147 </span>              :  </span>
<span class="lineNum">    148 </span>              :  </span>
<span class="lineNum">    149 </span>              : /* </span>
<span class="lineNum">    150 </span>              :  *  Close the image file </span>
<span class="lineNum">    151 </span>              :  */ </span>
<span class="lineNum">    152 </span>              :  </span>
<span class="lineNum">    153 </span>              : void ImageDrive::close_image(void) </span>
<span class="lineNum">    154 </span><span class="lineCov">    2 / 2     : { </span>
<span class="lineNum">    155 </span><span class="lineCov">    1 / 1     : 	if (the_file) { </span>
<span class="lineNum">    156 </span><span class="lineCov">    1 / 1     : 		close_all_channels(); </span>
<span class="lineNum">    157 </span><span class="lineCov">    1 / 1     : 		if (bam_dirty) { </span>
<span class="lineNum">    158 </span><span class="lineNoCov">    0 / 1     : 			write_sector(DIR_TRACK, 0, bam); </span>
<span class="lineNum">    159 </span><span class="lineNoCov">    0 / 1     : 			bam_dirty = false; </span>
<span class="lineNum">    160 </span>              : 		} </span>
<span class="lineNum">    161 </span><span class="lineCov">    1 / 1     : 		fclose(the_file); </span>
<span class="lineNum">    162 </span><span class="lineCov">    1 / 1     : 		the_file = NULL; </span>
<span class="lineNum">    163 </span>              : 	} </span>
<span class="lineNum">    164 </span><span class="lineCov">    1 / 1     : } </span>
<span class="lineNum">    165 </span>              :  </span>
<span class="lineNum">    166 </span>              :  </span>
<span class="lineNum">    167 </span>              : /* </span>
<span class="lineNum">    168 </span>              :  *  Open the image file </span>
<span class="lineNum">    169 </span>              :  */ </span>
<span class="lineNum">    170 </span>              :  </span>
<span class="lineNum">    171 </span>              : bool ImageDrive::change_image(const char *path) </span>
<span class="lineNum">    172 </span><span class="lineCov">    2 / 2     : { </span>
<span class="lineNum">    173 </span>              : 	// Close old image file </span>
<span class="lineNum">    174 </span><span class="lineCov">    1 / 1     : 	close_image(); </span>
<span class="lineNum">    175 </span>              :  </span>
<span class="lineNum">    176 </span>              : 	// Open new image file (try write access first, then read-only) </span>
<span class="lineNum">    177 </span><span class="lineCov">    1 / 1     : 	write_protected = false; </span>
<span class="lineNum">    178 </span><span class="lineCov">    1 / 1     : 	the_file = open_image_file(path, true); </span>
<span class="lineNum">    179 </span><span class="lineCov">    2 / 2     : 	if (the_file == NULL) { </span>
<span class="lineNum">    180 </span><span class="lineNoCov">    0 / 1     : 		write_protected = true; </span>
<span class="lineNum">    181 </span><span class="lineNoCov">    0 / 1     : 		the_file = open_image_file(path, false); </span>
<span class="lineNum">    182 </span>              : 	} </span>
<span class="lineNum">    183 </span><span class="lineNoCov">    0 / 2     : 	if (the_file) { </span>
<span class="lineNum">    184 </span>              :  </span>
<span class="lineNum">    185 </span>              : 		// Determine file type and fill in image_file_desc structure </span>
<span class="lineNum">    186 </span><span class="lineCov">    1 / 1     : 		if (!parse_image_file(the_file, desc)) { </span>
<span class="lineNum">    187 </span><span class="lineNoCov">    0 / 1     : 			fclose(the_file); </span>
<span class="lineNum">    188 </span><span class="lineNoCov">    0 / 1     : 			the_file = false; </span>
<span class="lineNum">    189 </span>              : 			return false; </span>
<span class="lineNum">    190 </span>              : 		} </span>
<span class="lineNum">    191 </span>              :  </span>
<span class="lineNum">    192 </span>              : 		// Read BAM </span>
<span class="lineNum">    193 </span><span class="lineCov">    1 / 1     : 		read_sector(DIR_TRACK, 0, bam); </span>
<span class="lineNum">    194 </span><span class="lineCov">    1 / 1     : 		bam_dirty = false; </span>
<span class="lineNum">    195 </span>              : 		return true; </span>
<span class="lineNum">    196 </span>              : 	} else </span>
<span class="lineNum">    197 </span>              : 		return false; </span>
<span class="lineNum">    198 </span><span class="linePartCov">    1 / 2     : } </span>
<span class="lineNum">    199 </span>              :  </span>
<span class="lineNum">    200 </span>              :  </span>
<span class="lineNum">    201 </span>              : /* </span>
<span class="lineNum">    202 </span>              :  *  Open channel </span>
<span class="lineNum">    203 </span>              :  */ </span>
<span class="lineNum">    204 </span>              :  </span>
<span class="lineNum">    205 </span>              : uint8 ImageDrive::Open(int channel, const uint8 *name, int name_len) </span>
<span class="lineNum">    206 </span><span class="lineNoCov">    0 / 2     : { </span>
<span class="lineNum">    207 </span>              : 	D(bug(&quot;ImageDrive::Open channel %d, file %s\n&quot;, channel, name)); </span>
<span class="lineNum">    208 </span>              :  </span>
<span class="lineNum">    209 </span><span class="lineNoCov">    0 / 1     : 	set_error(ERR_OK); </span>
<span class="lineNum">    210 </span>              :  </span>
<span class="lineNum">    211 </span>              : 	// Channel 15: execute file name as command </span>
<span class="lineNum">    212 </span><span class="lineNoCov">    0 / 1     : 	if (channel == 15) { </span>
<span class="lineNum">    213 </span><span class="lineNoCov">    0 / 1     : 		execute_cmd(name, name_len); </span>
<span class="lineNum">    214 </span><span class="lineNoCov">    0 / 1     : 		return ST_OK; </span>
<span class="lineNum">    215 </span>              : 	} </span>
<span class="lineNum">    216 </span>              :  </span>
<span class="lineNum">    217 </span><span class="lineNoCov">    0 / 1     : 	if (ch[channel].mode != CHMOD_FREE) { </span>
<span class="lineNum">    218 </span><span class="lineNoCov">    0 / 1     : 		set_error(ERR_NOCHANNEL); </span>
<span class="lineNum">    219 </span>              : 		return ST_OK; </span>
<span class="lineNum">    220 </span>              : 	} </span>
<span class="lineNum">    221 </span>              :  </span>
<span class="lineNum">    222 </span><span class="lineNoCov">    0 / 1     : 	if (name[0] == '$') </span>
<span class="lineNum">    223 </span>              : 	{ </span>
<span class="lineNum">    224 </span><span class="lineNoCov">    0 / 1     : 		if (channel) </span>
<span class="lineNum">    225 </span><span class="lineNoCov">    0 / 5     : 			return open_file_ts(channel, DIR_TRACK, 0); </span>
<span class="lineNum">    226 </span>              : 		else </span>
<span class="lineNum">    227 </span><span class="lineNoCov">    0 / 4     : 			return open_directory(name + 1, name_len - 1); </span>
<span class="lineNum">    228 </span>              : 	} </span>
<span class="lineNum">    229 </span>              :  </span>
<span class="lineNum">    230 </span><span class="lineNoCov">    0 / 1     : 	if (name[0] == '#') </span>
<span class="lineNum">    231 </span><span class="lineNoCov">    0 / 4     : 		return open_direct(channel, name); </span>
<span class="lineNum">    232 </span>              :  </span>
<span class="lineNum">    233 </span><span class="lineNoCov">    0 / 5     : 	return open_file(channel, name, name_len); </span>
<span class="lineNum">    234 </span><span class="lineNoCov">    0 / 15    : } </span>
<span class="lineNum">    235 </span>              :  </span>
<span class="lineNum">    236 </span>              :  </span>
<span class="lineNum">    237 </span>              : /* </span>
<span class="lineNum">    238 </span>              :  *  Open file </span>
<span class="lineNum">    239 </span>              :  */ </span>
<span class="lineNum">    240 </span>              :  </span>
<span class="lineNum">    241 </span>              : uint8 ImageDrive::open_file(int channel, const uint8 *name, int name_len) </span>
<span class="lineNum">    242 </span><span class="lineNoCov">    0 / 4     : { </span>
<span class="lineNum">    243 </span>              : 	uint8 plain_name[NAMEBUF_LENGTH]; </span>
<span class="lineNum">    244 </span>              : 	int plain_name_len; </span>
<span class="lineNum">    245 </span><span class="lineNoCov">    0 / 1     : 	int mode = FMODE_READ; </span>
<span class="lineNum">    246 </span><span class="lineNoCov">    0 / 1     : 	int type = FTYPE_DEL; </span>
<span class="lineNum">    247 </span><span class="lineNoCov">    0 / 1     : 	int rec_len = 0; </span>
<span class="lineNum">    248 </span><span class="lineNoCov">    0 / 3     : 	parse_file_name(name, name_len, plain_name, plain_name_len, mode, type, rec_len); </span>
<span class="lineNum">    249 </span><span class="lineNoCov">    0 / 1     : 	if (plain_name_len &gt; 16) </span>
<span class="lineNum">    250 </span><span class="lineNoCov">    0 / 1     : 		plain_name_len = 16; </span>
<span class="lineNum">    251 </span>              :  </span>
<span class="lineNum">    252 </span>              : 	D(bug(&quot; plain name %s, type %d, mode %d\n&quot;, plain_name, type, mode)); </span>
<span class="lineNum">    253 </span>              :  </span>
<span class="lineNum">    254 </span>              : 	// Channel 0 is READ, channel 1 is WRITE </span>
<span class="lineNum">    255 </span><span class="lineNoCov">    0 / 1     : 	if (channel == 0 || channel == 1) { </span>
<span class="lineNum">    256 </span><span class="lineNoCov">    0 / 1     : 		mode = channel ? FMODE_WRITE : FMODE_READ; </span>
<span class="lineNum">    257 </span><span class="lineNoCov">    0 / 2     : 		if (type == FTYPE_DEL) </span>
<span class="lineNum">    258 </span><span class="lineNoCov">    0 / 1     : 			type = FTYPE_PRG; </span>
<span class="lineNum">    259 </span>              : 	} </span>
<span class="lineNum">    260 </span>              :  </span>
<span class="lineNum">    261 </span><span class="lineNoCov">    0 / 2     : 	ch[channel].writing = (mode == FMODE_WRITE || mode == FMODE_APPEND); </span>
<span class="lineNum">    262 </span>              :  </span>
<span class="lineNum">    263 </span>              : 	// Wildcards are only allowed on reading </span>
<span class="lineNum">    264 </span><span class="lineNoCov">    0 / 4     : 	if (ch[channel].writing &amp;&amp; (strchr((const char *)plain_name, '*') || strchr((const char *)plain_name, '?'))) { </span>
<span class="lineNum">    265 </span><span class="lineNoCov">    0 / 1     : 		set_error(ERR_SYNTAX33); </span>
<span class="lineNum">    266 </span>              : 		return ST_OK; </span>
<span class="lineNum">    267 </span>              : 	} </span>
<span class="lineNum">    268 </span>              :  </span>
<span class="lineNum">    269 </span>              : 	// Check for write-protection if writing </span>
<span class="lineNum">    270 </span><span class="lineNoCov">    0 / 1     : 	if (ch[channel].writing &amp;&amp; write_protected) { </span>
<span class="lineNum">    271 </span><span class="lineNoCov">    0 / 1     : 		set_error(ERR_WRITEPROTECT); </span>
<span class="lineNum">    272 </span><span class="lineNoCov">    0 / 1     : 		return ST_OK; </span>
<span class="lineNum">    273 </span>              : 	} </span>
<span class="lineNum">    274 </span>              :  </span>
<span class="lineNum">    275 </span>              : 	// Relative files are not supported </span>
<span class="lineNum">    276 </span><span class="lineNoCov">    0 / 1     : 	if (type == FTYPE_REL) { </span>
<span class="lineNum">    277 </span><span class="lineNoCov">    0 / 1     : 		set_error(ERR_UNIMPLEMENTED); </span>
<span class="lineNum">    278 </span><span class="lineNoCov">    0 / 1     : 		return ST_OK; </span>
<span class="lineNum">    279 </span>              : 	} </span>
<span class="lineNum">    280 </span>              :  </span>
<span class="lineNum">    281 </span>              : 	// Find file in directory </span>
<span class="lineNum">    282 </span>              : 	int dir_track, dir_sector, entry; </span>
<span class="lineNum">    283 </span><span class="lineNoCov">    0 / 1     : 	if (find_first_file(plain_name, plain_name_len, dir_track, dir_sector, entry)) { </span>
<span class="lineNum">    284 </span>              :  </span>
<span class="lineNum">    285 </span>              : 		// File exists </span>
<span class="lineNum">    286 </span>              : 		D(bug(&quot; file exists, dir track %d, sector %d, entry %d\n&quot;, dir_track, dir_sector, entry)); </span>
<span class="lineNum">    287 </span><span class="lineNoCov">    0 / 1     : 		ch[channel].dir_track = dir_track; </span>
<span class="lineNum">    288 </span><span class="lineNoCov">    0 / 1     : 		ch[channel].dir_sector = dir_sector; </span>
<span class="lineNum">    289 </span><span class="lineNoCov">    0 / 1     : 		ch[channel].entry = entry; </span>
<span class="lineNum">    290 </span><span class="lineNoCov">    0 / 1     : 		uint8 *de = dir + DIR_ENTRIES + entry * SIZEOF_DE; </span>
<span class="lineNum">    291 </span>              :  </span>
<span class="lineNum">    292 </span>              : 		// Get file type from existing file if not specified in file name </span>
<span class="lineNum">    293 </span><span class="lineNoCov">    0 / 2     : 		if (type == FTYPE_DEL) </span>
<span class="lineNum">    294 </span><span class="lineNoCov">    0 / 1     : 			type = de[DE_TYPE] &amp; 7; </span>
<span class="lineNum">    295 </span>              :  </span>
<span class="lineNum">    296 </span><span class="lineNoCov">    0 / 1     : 		if ((de[DE_TYPE] &amp; 7) != type) { </span>
<span class="lineNum">    297 </span>              :  </span>
<span class="lineNum">    298 </span>              : 			// File type doesn't match </span>
<span class="lineNum">    299 </span><span class="lineNoCov">    0 / 1     : 			set_error(ERR_FILETYPE); </span>
<span class="lineNum">    300 </span>              :  </span>
<span class="lineNum">    301 </span><span class="lineNoCov">    0 / 1     : 		} else if (mode == FMODE_WRITE) { </span>
<span class="lineNum">    302 </span>              :  </span>
<span class="lineNum">    303 </span><span class="lineNoCov">    0 / 1     : 			if (name[0] == '@') { </span>
<span class="lineNum">    304 </span>              :  </span>
<span class="lineNum">    305 </span>              : 				// Open old file for overwriting (save-replace) </span>
<span class="lineNum">    306 </span><span class="lineNoCov">    0 / 1     : 				return create_file(channel, plain_name, plain_name_len, type, true); </span>
<span class="lineNum">    307 </span>              :  </span>
<span class="lineNum">    308 </span>              : 			} else { </span>
<span class="lineNum">    309 </span>              :  </span>
<span class="lineNum">    310 </span>              : 				// File to be written already exists, error </span>
<span class="lineNum">    311 </span><span class="lineNoCov">    0 / 1     : 				set_error(ERR_FILEEXISTS); </span>
<span class="lineNum">    312 </span>              : 			} </span>
<span class="lineNum">    313 </span>              :  </span>
<span class="lineNum">    314 </span><span class="lineNoCov">    0 / 1     : 		} else if (mode == FMODE_APPEND) { </span>
<span class="lineNum">    315 </span>              :  </span>
<span class="lineNum">    316 </span>              : 			// Open old file for appending </span>
<span class="lineNum">    317 </span><span class="lineNoCov">    0 / 2     : 			open_file_ts(channel, de[DE_TRACK], de[DE_SECTOR]); </span>
<span class="lineNum">    318 </span>              :  </span>
<span class="lineNum">    319 </span>              : 			// Seek to end of file </span>
<span class="lineNum">    320 </span>              : 			int track = 0, sector = 0, num_blocks = 0; </span>
<span class="lineNum">    321 </span><span class="lineNoCov">    0 / 4     : 			while (ch[channel].buf[0]) { </span>
<span class="lineNum">    322 </span><span class="lineNoCov">    0 / 1     : 				if (!read_sector(track = ch[channel].buf[0], sector = ch[channel].buf[1], ch[channel].buf)) </span>
<span class="lineNum">    323 </span>              : 					return ST_OK; </span>
<span class="lineNum">    324 </span><span class="lineNoCov">    0 / 1     : 				num_blocks++; </span>
<span class="lineNum">    325 </span>              : 			} </span>
<span class="lineNum">    326 </span>              :  </span>
<span class="lineNum">    327 </span>              : 			// Change channel mode to writing, adjust buffer pointer </span>
<span class="lineNum">    328 </span><span class="lineNoCov">    0 / 3     : 			ch[channel].writing = true; </span>
<span class="lineNum">    329 </span><span class="lineNoCov">    0 / 3     : 			ch[channel].buf_len = ch[channel].buf[1] + 1; </span>
<span class="lineNum">    330 </span><span class="lineNoCov">    0 / 1     : 			ch[channel].buf_ptr = ch[channel].buf + ch[channel].buf_len; </span>
<span class="lineNum">    331 </span><span class="lineNoCov">    0 / 1     : 			ch[channel].track = track; </span>
<span class="lineNum">    332 </span><span class="lineNoCov">    0 / 1     : 			ch[channel].sector = sector; </span>
<span class="lineNum">    333 </span><span class="lineNoCov">    0 / 3     : 			ch[channel].num_blocks = num_blocks; </span>
<span class="lineNum">    334 </span>              :  </span>
<span class="lineNum">    335 </span><span class="lineNoCov">    0 / 1     : 		} else if (mode == FMODE_M) { </span>
<span class="lineNum">    336 </span>              :  </span>
<span class="lineNum">    337 </span>              : 			// Open old file for reading, even if it is not closed </span>
<span class="lineNum">    338 </span>              : 			return open_file_ts(channel, de[DE_TRACK], de[DE_SECTOR]); </span>
<span class="lineNum">    339 </span>              :  </span>
<span class="lineNum">    340 </span>              : 		} else { </span>
<span class="lineNum">    341 </span>              :  </span>
<span class="lineNum">    342 </span>              : 			// Open old file for reading, error if file is open </span>
<span class="lineNum">    343 </span><span class="lineNoCov">    0 / 1     : 			if (de[DE_TYPE] &amp; 0x80) </span>
<span class="lineNum">    344 </span><span class="lineNoCov">    0 / 1     : 				return open_file_ts(channel, de[DE_TRACK], de[DE_SECTOR]); </span>
<span class="lineNum">    345 </span>              : 			else </span>
<span class="lineNum">    346 </span><span class="lineNoCov">    0 / 1     : 				set_error(ERR_WRITEFILEOPEN); </span>
<span class="lineNum">    347 </span>              : 		} </span>
<span class="lineNum">    348 </span>              :  </span>
<span class="lineNum">    349 </span>              : 	} else { </span>
<span class="lineNum">    350 </span>              :  </span>
<span class="lineNum">    351 </span>              : 		// File doesn't exist </span>
<span class="lineNum">    352 </span>              : 		D(bug(&quot; file not found\n&quot;)); </span>
<span class="lineNum">    353 </span>              :  </span>
<span class="lineNum">    354 </span>              : 		// Set file type to SEQ if not specified in file name </span>
<span class="lineNum">    355 </span><span class="lineNoCov">    0 / 1     : 		if (type == FTYPE_DEL) </span>
<span class="lineNum">    356 </span><span class="lineNoCov">    0 / 1     : 			type = FTYPE_SEQ; </span>
<span class="lineNum">    357 </span>              :  </span>
<span class="lineNum">    358 </span><span class="lineNoCov">    0 / 1     : 		if (mode == FMODE_WRITE) { </span>
<span class="lineNum">    359 </span>              :  </span>
<span class="lineNum">    360 </span>              : 			// Create new file for writing </span>
<span class="lineNum">    361 </span><span class="lineNoCov">    0 / 1     : 			return create_file(channel, plain_name, plain_name_len, type); </span>
<span class="lineNum">    362 </span>              :  </span>
<span class="lineNum">    363 </span>              : 		} else </span>
<span class="lineNum">    364 </span><span class="lineNoCov">    0 / 1     : 			set_error(ERR_FILENOTFOUND); </span>
<span class="lineNum">    365 </span>              : 	} </span>
<span class="lineNum">    366 </span>              : 	return ST_OK; </span>
<span class="lineNum">    367 </span><span class="lineNoCov">    0 / 2     : } </span>
<span class="lineNum">    368 </span>              :  </span>
<span class="lineNum">    369 </span>              :  </span>
<span class="lineNum">    370 </span>              : /* </span>
<span class="lineNum">    371 </span>              :  *  Open channel for reading from file given track/sector of first block </span>
<span class="lineNum">    372 </span>              :  */ </span>
<span class="lineNum">    373 </span>              :  </span>
<span class="lineNum">    374 </span>              : uint8 ImageDrive::open_file_ts(int channel, int track, int sector) </span>
<span class="lineNum">    375 </span><span class="lineNoCov">    0 / 4     : { </span>
<span class="lineNum">    376 </span>              : 	D(bug(&quot;open_file_ts track %d, sector %d\n&quot;, track, sector)); </span>
<span class="lineNum">    377 </span>              :  </span>
<span class="lineNum">    378 </span>              : 	// Allocate buffer and set channel mode </span>
<span class="lineNum">    379 </span>              : 	int buf = alloc_buffer(-1); </span>
<span class="lineNum">    380 </span>              : 	if (buf == -1) { </span>
<span class="lineNum">    381 </span><span class="lineNoCov">    0 / 1     : 		set_error(ERR_NOCHANNEL); </span>
<span class="lineNum">    382 </span>              : 		return ST_OK; </span>
<span class="lineNum">    383 </span>              : 	} </span>
<span class="lineNum">    384 </span><span class="lineNoCov">    0 / 2     : 	ch[channel].buf_num = buf; </span>
<span class="lineNum">    385 </span><span class="lineNoCov">    0 / 1     : 	ch[channel].buf = ram + 0x300 + buf * 0x100; </span>
<span class="lineNum">    386 </span><span class="lineNoCov">    0 / 1     : 	ch[channel].mode = CHMOD_FILE; </span>
<span class="lineNum">    387 </span>              :  </span>
<span class="lineNum">    388 </span>              : 	// On the next call to Read, the first block will be read </span>
<span class="lineNum">    389 </span><span class="lineNoCov">    0 / 2     : 	ch[channel].buf[0] = track; </span>
<span class="lineNum">    390 </span><span class="lineNoCov">    0 / 1     : 	ch[channel].buf[1] = sector; </span>
<span class="lineNum">    391 </span><span class="lineNoCov">    0 / 1     : 	ch[channel].buf_len = 0; </span>
<span class="lineNum">    392 </span>              :  </span>
<span class="lineNum">    393 </span>              : 	return ST_OK; </span>
<span class="lineNum">    394 </span><span class="lineNoCov">    0 / 3     : } </span>
<span class="lineNum">    395 </span>              :  </span>
<span class="lineNum">    396 </span>              :  </span>
<span class="lineNum">    397 </span>              : /* </span>
<span class="lineNum">    398 </span>              :  *  Create file and open channel for writing to file </span>
<span class="lineNum">    399 </span>              :  */ </span>
<span class="lineNum">    400 </span>              :  </span>
<span class="lineNum">    401 </span>              : uint8 ImageDrive::create_file(int channel, const uint8 *name, int name_len, int type, bool overwrite) </span>
<span class="lineNum">    402 </span><span class="lineNoCov">    0 / 4     : { </span>
<span class="lineNum">    403 </span>              : 	D(bug(&quot;create_file %s, type %d\n&quot;, name, type)); </span>
<span class="lineNum">    404 </span>              :  </span>
<span class="lineNum">    405 </span>              : 	// Allocate buffer </span>
<span class="lineNum">    406 </span>              : 	int buf = alloc_buffer(-1); </span>
<span class="lineNum">    407 </span>              : 	if (buf == -1) { </span>
<span class="lineNum">    408 </span><span class="lineNoCov">    0 / 1     : 		set_error(ERR_NOCHANNEL); </span>
<span class="lineNum">    409 </span>              : 		return ST_OK; </span>
<span class="lineNum">    410 </span>              : 	} </span>
<span class="lineNum">    411 </span><span class="lineNoCov">    0 / 3     : 	ch[channel].buf_num = buf; </span>
<span class="lineNum">    412 </span><span class="lineNoCov">    0 / 2     : 	ch[channel].buf = ram + 0x300 + buf * 0x100; </span>
<span class="lineNum">    413 </span>              :  </span>
<span class="lineNum">    414 </span>              : 	// Allocate new directory entry if not overwriting </span>
<span class="lineNum">    415 </span><span class="lineNoCov">    0 / 2     : 	if (!overwrite) { </span>
<span class="lineNum">    416 </span><span class="lineNoCov">    0 / 1     : 		if (!alloc_dir_entry(ch[channel].dir_track, ch[channel].dir_sector, ch[channel].entry)) { </span>
<span class="lineNum">    417 </span>              : 			free_buffer(buf); </span>
<span class="lineNum">    418 </span>              : 			return ST_OK; </span>
<span class="lineNum">    419 </span>              : 		} </span>
<span class="lineNum">    420 </span>              : 	} </span>
<span class="lineNum">    421 </span><span class="lineNoCov">    0 / 5     : 	uint8 *de = dir + DIR_ENTRIES + ch[channel].entry * SIZEOF_DE; </span>
<span class="lineNum">    422 </span>              :  </span>
<span class="lineNum">    423 </span>              : 	// Allocate first data block </span>
<span class="lineNum">    424 </span><span class="lineNoCov">    0 / 1     : 	ch[channel].track = DIR_TRACK - 1; </span>
<span class="lineNum">    425 </span><span class="lineNoCov">    0 / 1     : 	ch[channel].sector = -DATA_INTERLEAVE; </span>
<span class="lineNum">    426 </span><span class="lineNoCov">    0 / 2     : 	if (!alloc_next_block(ch[channel].track, ch[channel].sector, DATA_INTERLEAVE)) { </span>
<span class="lineNum">    427 </span>              : 		free_buffer(buf); </span>
<span class="lineNum">    428 </span>              : 		return ST_OK; </span>
<span class="lineNum">    429 </span>              : 	} </span>
<span class="lineNum">    430 </span><span class="lineNoCov">    0 / 1     : 	ch[channel].num_blocks = 1; </span>
<span class="lineNum">    431 </span>              : 	D(bug(&quot; first data block on track %d, sector %d\n&quot;, ch[channel].track, ch[channel].sector)); </span>
<span class="lineNum">    432 </span>              :  </span>
<span class="lineNum">    433 </span>              : 	// Write directory entry </span>
<span class="lineNum">    434 </span>              : 	memset(de, 0, SIZEOF_DE); </span>
<span class="lineNum">    435 </span><span class="lineNoCov">    0 / 1     : 	de[DE_TYPE] = type;		// bit 7 not set -&gt; open file </span>
<span class="lineNum">    436 </span><span class="lineNoCov">    0 / 1     : 	if (overwrite) { </span>
<span class="lineNum">    437 </span><span class="lineNoCov">    0 / 1     : 		de[DE_OVR_TRACK] = ch[channel].track; </span>
<span class="lineNum">    438 </span><span class="lineNoCov">    0 / 1     : 		de[DE_OVR_SECTOR] = ch[channel].sector; </span>
<span class="lineNum">    439 </span>              : 	} else { </span>
<span class="lineNum">    440 </span><span class="lineNoCov">    0 / 1     : 		de[DE_TRACK] = ch[channel].track; </span>
<span class="lineNum">    441 </span><span class="lineNoCov">    0 / 1     : 		de[DE_SECTOR] = ch[channel].sector; </span>
<span class="lineNum">    442 </span>              : 	} </span>
<span class="lineNum">    443 </span><span class="lineNoCov">    0 / 1     : 	memset(de + DE_NAME, 0xa0, 16); </span>
<span class="lineNum">    444 </span>              : 	memcpy(de + DE_NAME, name, name_len); </span>
<span class="lineNum">    445 </span><span class="lineNoCov">    0 / 4     : 	write_sector(ch[channel].dir_track, ch[channel].dir_sector, dir); </span>
<span class="lineNum">    446 </span>              :  </span>
<span class="lineNum">    447 </span>              : 	// Set channel descriptor </span>
<span class="lineNum">    448 </span><span class="lineNoCov">    0 / 1     : 	ch[channel].mode = CHMOD_FILE; </span>
<span class="lineNum">    449 </span><span class="lineNoCov">    0 / 1     : 	ch[channel].writing = true; </span>
<span class="lineNum">    450 </span><span class="lineNoCov">    0 / 2     : 	ch[channel].buf_ptr = ch[channel].buf + 2; </span>
<span class="lineNum">    451 </span><span class="lineNoCov">    0 / 1     : 	ch[channel].buf_len = 2; </span>
<span class="lineNum">    452 </span>              : 	return ST_OK; </span>
<span class="lineNum">    453 </span><span class="lineNoCov">    0 / 3     : } </span>
<span class="lineNum">    454 </span>              :  </span>
<span class="lineNum">    455 </span>              :  </span>
<span class="lineNum">    456 </span>              : /* </span>
<span class="lineNum">    457 </span>              :  *  Prepare directory as BASIC program (channel 0) </span>
<span class="lineNum">    458 </span>              :  */ </span>
<span class="lineNum">    459 </span>              :  </span>
<span class="lineNum">    460 </span>              : const char type_char_1[] = &quot;DSPUREER&quot;; </span>
<span class="lineNum">    461 </span>              : const char type_char_2[] = &quot;EERSELQG&quot;; </span>
<span class="lineNum">    462 </span>              : const char type_char_3[] = &quot;LQGRL???&quot;; </span>
<span class="lineNum">    463 </span>              :  </span>
<span class="lineNum">    464 </span><span class="lineNoCov">    0 / 6     : uint8 ImageDrive::open_directory(const uint8 *pattern, int pattern_len) </span>
<span class="lineNum">    465 </span><span class="lineNoCov">    0 / 1     : { </span>
<span class="lineNum">    466 </span>              : 	// Special treatment for &quot;$0&quot; </span>
<span class="lineNum">    467 </span><span class="lineNoCov">    0 / 1     : 	if (pattern[0] == '0' &amp;&amp; pattern_len == 1) { </span>
<span class="lineNum">    468 </span><span class="lineNoCov">    0 / 1     : 		pattern++; </span>
<span class="lineNum">    469 </span>              : 		pattern_len--; </span>
<span class="lineNum">    470 </span>              : 	} </span>
<span class="lineNum">    471 </span>              :  </span>
<span class="lineNum">    472 </span>              : 	// Skip everything before the ':' in the pattern </span>
<span class="lineNum">    473 </span>              : 	uint8 *t = (uint8 *)memchr(pattern, ':', pattern_len); </span>
<span class="lineNum">    474 </span><span class="lineNoCov">    0 / 1     : 	if (t) { </span>
<span class="lineNum">    475 </span><span class="lineNoCov">    0 / 1     : 		t++; </span>
<span class="lineNum">    476 </span><span class="lineNoCov">    0 / 2     : 		pattern_len -= t - pattern; </span>
<span class="lineNum">    477 </span>              : 		pattern = t; </span>
<span class="lineNum">    478 </span>              : 	} </span>
<span class="lineNum">    479 </span>              :  </span>
<span class="lineNum">    480 </span><span class="lineNoCov">    0 / 1     : 	ch[0].mode = CHMOD_DIRECTORY; </span>
<span class="lineNum">    481 </span><span class="lineNoCov">    0 / 2     : 	uint8 *p = ch[0].buf_ptr = ch[0].buf = new uint8[8192]; </span>
<span class="lineNum">    482 </span>              :  </span>
<span class="lineNum">    483 </span>              : 	// Create directory title with disk name, ID and format type </span>
<span class="lineNum">    484 </span><span class="lineNoCov">    0 / 1     : 	*p++ = 0x01;	// Load address $0401 (from PET days :-) </span>
<span class="lineNum">    485 </span><span class="lineNoCov">    0 / 1     : 	*p++ = 0x04; </span>
<span class="lineNum">    486 </span><span class="lineNoCov">    0 / 1     : 	*p++ = 0x01;	// Dummy line link </span>
<span class="lineNum">    487 </span><span class="lineNoCov">    0 / 1     : 	*p++ = 0x01; </span>
<span class="lineNum">    488 </span><span class="lineNoCov">    0 / 1     : 	*p++ = 0;		// Drive number (0) as line number </span>
<span class="lineNum">    489 </span><span class="lineNoCov">    0 / 1     : 	*p++ = 0; </span>
<span class="lineNum">    490 </span><span class="lineNoCov">    0 / 1     : 	*p++ = 0x12;	// RVS ON </span>
<span class="lineNum">    491 </span><span class="lineNoCov">    0 / 1     : 	*p++ = '\&quot;'; </span>
<span class="lineNum">    492 </span>              :  </span>
<span class="lineNum">    493 </span><span class="lineNoCov">    0 / 2     : 	uint8 *q = bam + BAM_DISK_NAME; </span>
<span class="lineNum">    494 </span><span class="lineNoCov">    0 / 4     : 	for (int i=0; i&lt;23; i++) { </span>
<span class="lineNum">    495 </span>              : 		int c; </span>
<span class="lineNum">    496 </span><span class="lineNoCov">    0 / 1     : 		if ((c = *q++) == 0xa0) </span>
<span class="lineNum">    497 </span><span class="lineNoCov">    0 / 1     : 			*p++ = ' ';		// Replace 0xa0 by space </span>
<span class="lineNum">    498 </span>              : 		else </span>
<span class="lineNum">    499 </span><span class="lineNoCov">    0 / 1     : 			*p++ = c; </span>
<span class="lineNum">    500 </span>              : 	} </span>
<span class="lineNum">    501 </span><span class="lineNoCov">    0 / 1     : 	*(p-7) = '\&quot;'; </span>
<span class="lineNum">    502 </span><span class="lineNoCov">    0 / 2     : 	*p++ = 0; </span>
<span class="lineNum">    503 </span>              :  </span>
<span class="lineNum">    504 </span>              : 	// Scan all directory blocks </span>
<span class="lineNum">    505 </span><span class="lineNoCov">    0 / 2     : 	dir[DIR_NEXT_TRACK] = DIR_TRACK; </span>
<span class="lineNum">    506 </span><span class="lineNoCov">    0 / 1     : 	dir[DIR_NEXT_SECTOR] = 1; </span>
<span class="lineNum">    507 </span>              :  </span>
<span class="lineNum">    508 </span>              : 	int num_dir_blocks = 0; </span>
<span class="lineNum">    509 </span><span class="lineNoCov">    0 / 2     : 	while (dir[DIR_NEXT_TRACK] &amp;&amp; num_dir_blocks &lt; num_sectors[DIR_TRACK]) { </span>
<span class="lineNum">    510 </span><span class="lineNoCov">    0 / 4     : 		if (!read_sector(dir[DIR_NEXT_TRACK], dir[DIR_NEXT_SECTOR], dir)) </span>
<span class="lineNum">    511 </span>              : 			return ST_OK; </span>
<span class="lineNum">    512 </span><span class="lineNoCov">    0 / 1     : 		num_dir_blocks++; </span>
<span class="lineNum">    513 </span>              :  </span>
<span class="lineNum">    514 </span>              : 		// Scan all 8 entries of a block </span>
<span class="lineNum">    515 </span><span class="lineNoCov">    0 / 7     : 		uint8 *de = dir + DIR_ENTRIES; </span>
<span class="lineNum">    516 </span><span class="lineNoCov">    0 / 2     : 		for (int j=0; j&lt;8; j++, de+=SIZEOF_DE) { </span>
<span class="lineNum">    517 </span><span class="lineNoCov">    0 / 2     : 			if (de[DE_TYPE] &amp;&amp; (pattern_len == 0 || match(pattern, pattern_len, de + DE_NAME))) { </span>
<span class="lineNum">    518 </span>              :  </span>
<span class="lineNum">    519 </span>              : 				// Dummy line link </span>
<span class="lineNum">    520 </span><span class="lineNoCov">    0 / 1     : 				*p++ = 0x01; </span>
<span class="lineNum">    521 </span><span class="lineNoCov">    0 / 1     : 				*p++ = 0x01; </span>
<span class="lineNum">    522 </span>              :  </span>
<span class="lineNum">    523 </span>              : 				// Line number = number of blocks </span>
<span class="lineNum">    524 </span><span class="lineNoCov">    0 / 1     : 				*p++ = de[DE_NUM_BLOCKS_L]; </span>
<span class="lineNum">    525 </span><span class="lineNoCov">    0 / 2     : 				*p++ = de[DE_NUM_BLOCKS_H]; </span>
<span class="lineNum">    526 </span>              :  </span>
<span class="lineNum">    527 </span>              : 				// Appropriate number of spaces to align file names </span>
<span class="lineNum">    528 </span><span class="lineNoCov">    0 / 1     : 				*p++ = ' '; </span>
<span class="lineNum">    529 </span><span class="lineNoCov">    0 / 2     : 				int n = (de[DE_NUM_BLOCKS_H] &lt;&lt; 8) + de[DE_NUM_BLOCKS_L]; </span>
<span class="lineNum">    530 </span><span class="lineNoCov">    0 / 2     : 				if (n&lt;10) *p++ = ' '; </span>
<span class="lineNum">    531 </span><span class="lineNoCov">    0 / 2     : 				if (n&lt;100) *p++ = ' '; </span>
<span class="lineNum">    532 </span>              :  </span>
<span class="lineNum">    533 </span>              : 				// File name enclosed in quotes </span>
<span class="lineNum">    534 </span><span class="lineNoCov">    0 / 1     : 				*p++ = '\&quot;'; </span>
<span class="lineNum">    535 </span>              : 				q = de + DE_NAME; </span>
<span class="lineNum">    536 </span>              : 				uint8 c; </span>
<span class="lineNum">    537 </span>              : 				bool m = false; </span>
<span class="lineNum">    538 </span><span class="lineNoCov">    0 / 2     : 				for (int i=0; i&lt;16; i++) { </span>
<span class="lineNum">    539 </span><span class="lineNoCov">    0 / 1     : 					if ((c = *q++) == 0xa0) { </span>
<span class="lineNum">    540 </span><span class="lineNoCov">    0 / 1     : 						if (m) </span>
<span class="lineNum">    541 </span><span class="lineNoCov">    0 / 1     : 							*p++ = ' ';			// Replace all 0xa0 by spaces </span>
<span class="lineNum">    542 </span>              : 						else </span>
<span class="lineNum">    543 </span><span class="lineNoCov">    0 / 1     : 							m = (*p++ = '\&quot;');	// But the first by a '&quot;' </span>
<span class="lineNum">    544 </span>              : 					} else </span>
<span class="lineNum">    545 </span><span class="lineNoCov">    0 / 2     : 						*p++ = c; </span>
<span class="lineNum">    546 </span>              : 				} </span>
<span class="lineNum">    547 </span><span class="lineNoCov">    0 / 1     : 				if (m) </span>
<span class="lineNum">    548 </span><span class="lineNoCov">    0 / 1     : 					*p++ = ' '; </span>
<span class="lineNum">    549 </span>              : 				else </span>
<span class="lineNum">    550 </span><span class="lineNoCov">    0 / 1     : 					*p++ = '\&quot;';			// No 0xa0, then append a space </span>
<span class="lineNum">    551 </span>              :  </span>
<span class="lineNum">    552 </span>              : 				// Open files are marked by '*' </span>
<span class="lineNum">    553 </span><span class="lineNoCov">    0 / 2     : 				if (de[DE_TYPE] &amp; 0x80) </span>
<span class="lineNum">    554 </span><span class="lineNoCov">    0 / 1     : 					*p++ = ' '; </span>
<span class="lineNum">    555 </span>              : 				else </span>
<span class="lineNum">    556 </span><span class="lineNoCov">    0 / 1     : 					*p++ = '*'; </span>
<span class="lineNum">    557 </span>              :  </span>
<span class="lineNum">    558 </span>              : 				// File type </span>
<span class="lineNum">    559 </span><span class="lineNoCov">    0 / 1     : 				*p++ = type_char_1[de[DE_TYPE] &amp; 7]; </span>
<span class="lineNum">    560 </span><span class="lineNoCov">    0 / 1     : 				*p++ = type_char_2[de[DE_TYPE] &amp; 7]; </span>
<span class="lineNum">    561 </span><span class="lineNoCov">    0 / 1     : 				*p++ = type_char_3[de[DE_TYPE] &amp; 7]; </span>
<span class="lineNum">    562 </span>              :  </span>
<span class="lineNum">    563 </span>              : 				// Protected files are marked by '&lt;' </span>
<span class="lineNum">    564 </span><span class="lineNoCov">    0 / 1     : 				if (de[DE_TYPE] &amp; 0x40) </span>
<span class="lineNum">    565 </span><span class="lineNoCov">    0 / 1     : 					*p++ = '&lt;'; </span>
<span class="lineNum">    566 </span>              : 				else </span>
<span class="lineNum">    567 </span><span class="lineNoCov">    0 / 1     : 					*p++ = ' '; </span>
<span class="lineNum">    568 </span>              :  </span>
<span class="lineNum">    569 </span>              : 				// Appropriate number of spaces at the end </span>
<span class="lineNum">    570 </span><span class="lineNoCov">    0 / 1     : 				*p++ = ' '; </span>
<span class="lineNum">    571 </span><span class="lineNoCov">    0 / 1     : 				if (n &gt;= 10) *p++ = ' '; </span>
<span class="lineNum">    572 </span><span class="lineNoCov">    0 / 1     : 				if (n &gt;= 100) *p++ = ' '; </span>
<span class="lineNum">    573 </span><span class="lineNoCov">    0 / 2     : 				*p++ = 0; </span>
<span class="lineNum">    574 </span>              : 			} </span>
<span class="lineNum">    575 </span>              : 		} </span>
<span class="lineNum">    576 </span>              : 	} </span>
<span class="lineNum">    577 </span>              :  </span>
<span class="lineNum">    578 </span>              : 	// Final line, count number of free blocks </span>
<span class="lineNum">    579 </span>              : 	int n = 0; </span>
<span class="lineNum">    580 </span><span class="lineNoCov">    0 / 1     : 	for (int i=1; i&lt;=35; i++) { </span>
<span class="lineNum">    581 </span><span class="lineNoCov">    0 / 1     : 		if (i != DIR_TRACK)	// exclude track 18 </span>
<span class="lineNum">    582 </span><span class="lineNoCov">    0 / 1     : 			n += num_free_blocks(i); </span>
<span class="lineNum">    583 </span>              : 	} </span>
<span class="lineNum">    584 </span>              :  </span>
<span class="lineNum">    585 </span><span class="lineNoCov">    0 / 2     : 	*p++ = 0x01;		// Dummy line link </span>
<span class="lineNum">    586 </span><span class="lineNoCov">    0 / 1     : 	*p++ = 0x01; </span>
<span class="lineNum">    587 </span><span class="lineNoCov">    0 / 1     : 	*p++ = n &amp; 0xff;	// Number of free blocks as line number </span>
<span class="lineNum">    588 </span><span class="lineNoCov">    0 / 1     : 	*p++ = (n &gt;&gt; 8) &amp; 0xff; </span>
<span class="lineNum">    589 </span>              :  </span>
<span class="lineNum">    590 </span><span class="lineNoCov">    0 / 1     : 	*p++ = 'B'; </span>
<span class="lineNum">    591 </span><span class="lineNoCov">    0 / 1     : 	*p++ = 'L'; </span>
<span class="lineNum">    592 </span><span class="lineNoCov">    0 / 1     : 	*p++ = 'O'; </span>
<span class="lineNum">    593 </span><span class="lineNoCov">    0 / 1     : 	*p++ = 'C'; </span>
<span class="lineNum">    594 </span><span class="lineNoCov">    0 / 1     : 	*p++ = 'K'; </span>
<span class="lineNum">    595 </span><span class="lineNoCov">    0 / 1     : 	*p++ = 'S'; </span>
<span class="lineNum">    596 </span><span class="lineNoCov">    0 / 1     : 	*p++ = ' '; </span>
<span class="lineNum">    597 </span><span class="lineNoCov">    0 / 1     : 	*p++ = 'F'; </span>
<span class="lineNum">    598 </span><span class="lineNoCov">    0 / 1     : 	*p++ = 'R'; </span>
<span class="lineNum">    599 </span><span class="lineNoCov">    0 / 1     : 	*p++ = 'E'; </span>
<span class="lineNum">    600 </span><span class="lineNoCov">    0 / 1     : 	*p++ = 'E'; </span>
<span class="lineNum">    601 </span><span class="lineNoCov">    0 / 2     : 	*p++ = '.'; </span>
<span class="lineNum">    602 </span>              :  </span>
<span class="lineNum">    603 </span>              : 	memset(p, ' ', 13); </span>
<span class="lineNum">    604 </span>              : 	p += 13; </span>
<span class="lineNum">    605 </span>              :  </span>
<span class="lineNum">    606 </span><span class="lineNoCov">    0 / 1     : 	*p++ = 0; </span>
<span class="lineNum">    607 </span><span class="lineNoCov">    0 / 1     : 	*p++ = 0; </span>
<span class="lineNum">    608 </span><span class="lineNoCov">    0 / 1     : 	*p++ = 0; </span>
<span class="lineNum">    609 </span>              :  </span>
<span class="lineNum">    610 </span><span class="lineNoCov">    0 / 1     : 	ch[0].buf_len = p - ch[0].buf; </span>
<span class="lineNum">    611 </span>              : 	return ST_OK; </span>
<span class="lineNum">    612 </span><span class="lineNoCov">    0 / 1     : } </span>
<span class="lineNum">    613 </span>              :  </span>
<span class="lineNum">    614 </span>              :  </span>
<span class="lineNum">    615 </span>              : /* </span>
<span class="lineNum">    616 </span>              :  *  Open channel for direct buffer access </span>
<span class="lineNum">    617 </span>              :  */ </span>
<span class="lineNum">    618 </span>              :  </span>
<span class="lineNum">    619 </span>              : uint8 ImageDrive::open_direct(int channel, const uint8 *name) </span>
<span class="lineNum">    620 </span><span class="lineNoCov">    0 / 1     : { </span>
<span class="lineNum">    621 </span>              : 	int buf = -1; </span>
<span class="lineNum">    622 </span>              :  </span>
<span class="lineNum">    623 </span><span class="lineNoCov">    0 / 1     : 	if (name[1] == 0) </span>
<span class="lineNum">    624 </span>              : 		buf = alloc_buffer(-1); </span>
<span class="lineNum">    625 </span>              : 	else </span>
<span class="lineNum">    626 </span><span class="lineNoCov">    0 / 1     : 		if ((name[1] &gt;= '0') &amp;&amp; (name[1] &lt;= '3') &amp;&amp; (name[2] == 0)) </span>
<span class="lineNum">    627 </span><span class="lineNoCov">    0 / 1     : 			buf = alloc_buffer(name[1] - '0'); </span>
<span class="lineNum">    628 </span>              :  </span>
<span class="lineNum">    629 </span>              : 	if (buf == -1) { </span>
<span class="lineNum">    630 </span><span class="lineNoCov">    0 / 1     : 		set_error(ERR_NOCHANNEL); </span>
<span class="lineNum">    631 </span>              : 		return ST_OK; </span>
<span class="lineNum">    632 </span>              : 	} </span>
<span class="lineNum">    633 </span>              :  </span>
<span class="lineNum">    634 </span>              : 	// The buffers are in the 1541 RAM at $300 and are 256 bytes each </span>
<span class="lineNum">    635 </span><span class="lineNoCov">    0 / 2     : 	ch[channel].mode = CHMOD_DIRECT; </span>
<span class="lineNum">    636 </span><span class="lineNoCov">    0 / 2     : 	ch[channel].buf = ram + 0x300 + buf * 0x100; </span>
<span class="lineNum">    637 </span><span class="lineNoCov">    0 / 1     : 	ch[channel].buf_num = buf; </span>
<span class="lineNum">    638 </span>              :  </span>
<span class="lineNum">    639 </span>              : 	// Store actual buffer number in buffer </span>
<span class="lineNum">    640 </span><span class="lineNoCov">    0 / 2     : 	ch[channel].buf[1] = buf + '0'; </span>
<span class="lineNum">    641 </span><span class="lineNoCov">    0 / 1     : 	ch[channel].buf_len = 1; </span>
<span class="lineNum">    642 </span><span class="lineNoCov">    0 / 2     : 	ch[channel].buf_ptr = ch[channel].buf + 1; </span>
<span class="lineNum">    643 </span>              :  </span>
<span class="lineNum">    644 </span><span class="lineNoCov">    0 / 1     : 	return ST_OK; </span>
<span class="lineNum">    645 </span><span class="lineNoCov">    0 / 1     : } </span>
<span class="lineNum">    646 </span>              :  </span>
<span class="lineNum">    647 </span>              :  </span>
<span class="lineNum">    648 </span>              : /* </span>
<span class="lineNum">    649 </span>              :  *  Close channel </span>
<span class="lineNum">    650 </span>              :  */ </span>
<span class="lineNum">    651 </span>              :  </span>
<span class="lineNum">    652 </span>              : uint8 ImageDrive::Close(int channel) </span>
<span class="lineNum">    653 </span><span class="lineCov">    1 / 1     : { </span>
<span class="lineNum">    654 </span>              : 	D(bug(&quot;ImageDrive::Close channel %d\n&quot;, channel)); </span>
<span class="lineNum">    655 </span>              :  </span>
<span class="lineNum">    656 </span><span class="linePartCov">    1 / 2     : 	switch (ch[channel].mode) { </span>
<span class="lineNum">    657 </span>              : 		case CHMOD_FREE: </span>
<span class="lineNum">    658 </span>              : 			break; </span>
<span class="lineNum">    659 </span>              :   </span>
<span class="lineNum">    660 </span>              : 		case CHMOD_COMMAND: </span>
<span class="lineNum">    661 </span><span class="lineNoCov">    0 / 1     : 			close_all_channels(); </span>
<span class="lineNum">    662 </span>              : 			break; </span>
<span class="lineNum">    663 </span>              :  </span>
<span class="lineNum">    664 </span>              : 		case CHMOD_DIRECT: </span>
<span class="lineNum">    665 </span>              : 			free_buffer(ch[channel].buf_num); </span>
<span class="lineNum">    666 </span>              : 			ch[channel].buf = NULL; </span>
<span class="lineNum">    667 </span>              : 			ch[channel].mode = CHMOD_FREE; </span>
<span class="lineNum">    668 </span>              : 			break; </span>
<span class="lineNum">    669 </span>              :  </span>
<span class="lineNum">    670 </span>              : 		case CHMOD_FILE: </span>
<span class="lineNum">    671 </span><span class="lineNoCov">    0 / 1     : 			if (ch[channel].writing) { </span>
<span class="lineNum">    672 </span>              :  </span>
<span class="lineNum">    673 </span>              : 				// Current block empty? Then write CR character </span>
<span class="lineNum">    674 </span><span class="lineNoCov">    0 / 1     : 				if (ch[channel].buf_len == 2) { </span>
<span class="lineNum">    675 </span><span class="lineNoCov">    0 / 1     : 					ch[channel].buf[2] = 0x0d; </span>
<span class="lineNum">    676 </span><span class="lineNoCov">    0 / 1     : 					ch[channel].buf_len++; </span>
<span class="lineNum">    677 </span>              : 				} </span>
<span class="lineNum">    678 </span>              :  </span>
<span class="lineNum">    679 </span>              : 				// Write last data block </span>
<span class="lineNum">    680 </span><span class="lineNoCov">    0 / 1     : 				ch[channel].buf[0] = 0; </span>
<span class="lineNum">    681 </span><span class="lineNoCov">    0 / 1     : 				ch[channel].buf[1] = ch[channel].buf_len - 1; </span>
<span class="lineNum">    682 </span>              : 				D(bug(&quot; writing last data block\n&quot;)); </span>
<span class="lineNum">    683 </span><span class="lineNoCov">    0 / 1     : 				if (!write_sector(ch[channel].track, ch[channel].sector, ch[channel].buf)) </span>
<span class="lineNum">    684 </span>              : 					goto free; </span>
<span class="lineNum">    685 </span>              :  </span>
<span class="lineNum">    686 </span>              : 				// Close write file in directory </span>
<span class="lineNum">    687 </span><span class="lineNoCov">    0 / 1     : 				read_sector(ch[channel].dir_track, ch[channel].dir_sector, dir); </span>
<span class="lineNum">    688 </span><span class="lineNoCov">    0 / 1     : 				uint8 *de = dir + DIR_ENTRIES + ch[channel].entry * SIZEOF_DE; </span>
<span class="lineNum">    689 </span><span class="lineNoCov">    0 / 1     : 				de[DE_TYPE] |= 0x80; </span>
<span class="lineNum">    690 </span><span class="lineNoCov">    0 / 1     : 				de[DE_NUM_BLOCKS_L] = ch[channel].num_blocks &amp; 0xff; </span>
<span class="lineNum">    691 </span><span class="lineNoCov">    0 / 2     : 				de[DE_NUM_BLOCKS_H] = ch[channel].num_blocks &gt;&gt; 8; </span>
<span class="lineNum">    692 </span><span class="lineNoCov">    0 / 2     : 				if (de[DE_OVR_TRACK]) { </span>
<span class="lineNum">    693 </span>              : 					// Overwriting, free old data blocks and set pointer to new ones </span>
<span class="lineNum">    694 </span><span class="lineNoCov">    0 / 1     : 					free_block_chain(de[DE_TRACK], de[DE_SECTOR]); </span>
<span class="lineNum">    695 </span><span class="lineNoCov">    0 / 2     : 					de[DE_TRACK] = de[DE_OVR_TRACK]; </span>
<span class="lineNum">    696 </span><span class="lineNoCov">    0 / 2     : 					de[DE_SECTOR] = de[DE_OVR_SECTOR]; </span>
<span class="lineNum">    697 </span><span class="lineNoCov">    0 / 3     : 					de[DE_OVR_TRACK] = de[DE_OVR_SECTOR] = 0; </span>
<span class="lineNum">    698 </span>              : 				} </span>
<span class="lineNum">    699 </span><span class="lineNoCov">    0 / 1     : 				write_sector(ch[channel].dir_track, ch[channel].dir_sector, dir); </span>
<span class="lineNum">    700 </span>              : 				D(bug(&quot; directory entry updated\n&quot;)); </span>
<span class="lineNum">    701 </span>              : 			} </span>
<span class="lineNum">    702 </span>              : free:		free_buffer(ch[channel].buf_num); </span>
<span class="lineNum">    703 </span><span class="lineNoCov">    0 / 1     : 			ch[channel].buf = NULL; </span>
<span class="lineNum">    704 </span><span class="lineNoCov">    0 / 1     : 			ch[channel].mode = CHMOD_FREE; </span>
<span class="lineNum">    705 </span><span class="lineNoCov">    0 / 1     : 			break; </span>
<span class="lineNum">    706 </span>              :  </span>
<span class="lineNum">    707 </span>              : 		case CHMOD_DIRECTORY: </span>
<span class="lineNum">    708 </span><span class="lineNoCov">    0 / 1     : 			delete[] ch[channel].buf; </span>
<span class="lineNum">    709 </span><span class="lineNoCov">    0 / 1     : 			ch[channel].buf = NULL; </span>
<span class="lineNum">    710 </span><span class="lineNoCov">    0 / 1     : 			ch[channel].mode = CHMOD_FREE; </span>
<span class="lineNum">    711 </span>              : 			break; </span>
<span class="lineNum">    712 </span>              : 	} </span>
<span class="lineNum">    713 </span>              :  </span>
<span class="lineNum">    714 </span>              : 	return ST_OK; </span>
<span class="lineNum">    715 </span><span class="lineCov">    1 / 1     : } </span>
<span class="lineNum">    716 </span>              :  </span>
<span class="lineNum">    717 </span>              :  </span>
<span class="lineNum">    718 </span>              : /* </span>
<span class="lineNum">    719 </span>              :  *  Close all channels </span>
<span class="lineNum">    720 </span>              :  */ </span>
<span class="lineNum">    721 </span>              :  </span>
<span class="lineNum">    722 </span>              : void ImageDrive::close_all_channels() </span>
<span class="lineNum">    723 </span><span class="lineCov">    2 / 2     : { </span>
<span class="lineNum">    724 </span><span class="lineCov">    2 / 2     : 	for (int i=0; i&lt;15; i++) </span>
<span class="lineNum">    725 </span><span class="lineCov">    2 / 2     : 		Close(i); </span>
<span class="lineNum">    726 </span><span class="lineCov">    1 / 1     : 	Close(16); </span>
<span class="lineNum">    727 </span><span class="lineCov">    1 / 1     : 	Close(17); </span>
<span class="lineNum">    728 </span>              :  </span>
<span class="lineNum">    729 </span><span class="lineCov">    1 / 1     : 	cmd_len = 0; </span>
<span class="lineNum">    730 </span><span class="lineCov">    1 / 1     : } </span>
<span class="lineNum">    731 </span>              :  </span>
<span class="lineNum">    732 </span>              :  </span>
<span class="lineNum">    733 </span>              : /* </span>
<span class="lineNum">    734 </span>              :  *  Read from channel </span>
<span class="lineNum">    735 </span>              :  */ </span>
<span class="lineNum">    736 </span>              :  </span>
<span class="lineNum">    737 </span>              : uint8 ImageDrive::Read(int channel, uint8 &amp;byte) </span>
<span class="lineNum">    738 </span><span class="lineNoCov">    0 / 2     : { </span>
<span class="lineNum">    739 </span>              : //	D(bug(&quot;ImageDrive::Read channel %d\n&quot;, channel)); </span>
<span class="lineNum">    740 </span>              :  </span>
<span class="lineNum">    741 </span><span class="lineNoCov">    0 / 1     : 	switch (ch[channel].mode) { </span>
<span class="lineNum">    742 </span>              : 		case CHMOD_FREE: </span>
<span class="lineNum">    743 </span><span class="lineNoCov">    0 / 1     : 			if (current_error == ERR_OK) </span>
<span class="lineNum">    744 </span><span class="lineNoCov">    0 / 1     : 				set_error(ERR_FILENOTOPEN); </span>
<span class="lineNum">    745 </span>              : 			break; </span>
<span class="lineNum">    746 </span>              :  </span>
<span class="lineNum">    747 </span>              : 		case CHMOD_COMMAND: </span>
<span class="lineNum">    748 </span>              : 			// Read error channel </span>
<span class="lineNum">    749 </span><span class="lineNoCov">    0 / 1     : 			byte = *error_ptr++; </span>
<span class="lineNum">    750 </span><span class="lineNoCov">    0 / 1     : 			if (--error_len) </span>
<span class="lineNum">    751 </span>              : 				return ST_OK; </span>
<span class="lineNum">    752 </span>              : 			else { </span>
<span class="lineNum">    753 </span><span class="lineNoCov">    0 / 1     : 				set_error(ERR_OK); </span>
<span class="lineNum">    754 </span><span class="lineNoCov">    0 / 1     : 				return ST_EOF; </span>
<span class="lineNum">    755 </span>              : 			} </span>
<span class="lineNum">    756 </span>              : 			break; </span>
<span class="lineNum">    757 </span>              :  </span>
<span class="lineNum">    758 </span>              : 		case CHMOD_FILE: </span>
<span class="lineNum">    759 </span><span class="lineNoCov">    0 / 1     : 			if (ch[channel].writing) </span>
<span class="lineNum">    760 </span>              : 				return ST_READ_TIMEOUT; </span>
<span class="lineNum">    761 </span><span class="lineNoCov">    0 / 1     : 			if (current_error != ERR_OK) </span>
<span class="lineNum">    762 </span>              : 				return ST_READ_TIMEOUT; </span>
<span class="lineNum">    763 </span>              :  </span>
<span class="lineNum">    764 </span>              : 			// Read next block if necessary </span>
<span class="lineNum">    765 </span><span class="lineNoCov">    0 / 2     : 			if (ch[channel].buf_len == 0 &amp;&amp; ch[channel].buf[0]) { </span>
<span class="lineNum">    766 </span>              : 				D(bug(&quot; reading next data block track %d, sector %d\n&quot;, ch[channel].buf[0], ch[channel].buf[1])); </span>
<span class="lineNum">    767 </span><span class="lineNoCov">    0 / 1     : 				if (!read_sector(ch[channel].buf[0], ch[channel].buf[1], ch[channel].buf)) </span>
<span class="lineNum">    768 </span>              : 					return ST_READ_TIMEOUT; </span>
<span class="lineNum">    769 </span><span class="lineNoCov">    0 / 1     : 				ch[channel].buf_ptr = ch[channel].buf + 2; </span>
<span class="lineNum">    770 </span>              :  </span>
<span class="lineNum">    771 </span>              : 				// Determine block length </span>
<span class="lineNum">    772 </span><span class="lineNoCov">    0 / 1     : 				ch[channel].buf_len = ch[channel].buf[0] ? 254 : ch[channel].buf[1] - 1; </span>
<span class="lineNum">    773 </span>              : 			} </span>
<span class="lineNum">    774 </span>              :  </span>
<span class="lineNum">    775 </span><span class="lineNoCov">    0 / 1     : 			if (ch[channel].buf_len &gt; 0) { </span>
<span class="lineNum">    776 </span><span class="lineNoCov">    0 / 1     : 				byte = *(ch[channel].buf_ptr)++; </span>
<span class="lineNum">    777 </span><span class="lineNoCov">    0 / 1     : 				if (--(ch[channel].buf_len) == 0 &amp;&amp; ch[channel].buf[0] == 0) </span>
<span class="lineNum">    778 </span>              : 					return ST_EOF; </span>
<span class="lineNum">    779 </span>              : 				else </span>
<span class="lineNum">    780 </span>              : 					return ST_OK; </span>
<span class="lineNum">    781 </span>              : 			} else </span>
<span class="lineNum">    782 </span>              : 				return ST_READ_TIMEOUT; </span>
<span class="lineNum">    783 </span>              : 			break; </span>
<span class="lineNum">    784 </span>              :  </span>
<span class="lineNum">    785 </span>              : 		case CHMOD_DIRECTORY: </span>
<span class="lineNum">    786 </span>              : 		case CHMOD_DIRECT: </span>
<span class="lineNum">    787 </span><span class="lineNoCov">    0 / 1     : 			if (ch[channel].buf_len &gt; 0) { </span>
<span class="lineNum">    788 </span><span class="lineNoCov">    0 / 1     : 				byte = *(ch[channel].buf_ptr)++; </span>
<span class="lineNum">    789 </span><span class="lineNoCov">    0 / 3     : 				if (--(ch[channel].buf_len)) </span>
<span class="lineNum">    790 </span>              : 					return ST_OK; </span>
<span class="lineNum">    791 </span>              : 				else </span>
<span class="lineNum">    792 </span>              : 					return ST_EOF; </span>
<span class="lineNum">    793 </span>              : 			} else </span>
<span class="lineNum">    794 </span>              : 				return ST_READ_TIMEOUT; </span>
<span class="lineNum">    795 </span>              : 			break; </span>
<span class="lineNum">    796 </span>              : 	} </span>
<span class="lineNum">    797 </span>              : 	return ST_READ_TIMEOUT; </span>
<span class="lineNum">    798 </span><span class="lineNoCov">    0 / 1     : } </span>
<span class="lineNum">    799 </span>              :  </span>
<span class="lineNum">    800 </span>              :  </span>
<span class="lineNum">    801 </span>              : /* </span>
<span class="lineNum">    802 </span>              :  *  Write byte to channel </span>
<span class="lineNum">    803 </span>              :  */ </span>
<span class="lineNum">    804 </span>              :  </span>
<span class="lineNum">    805 </span>              : uint8 ImageDrive::Write(int channel, uint8 byte, bool eoi) </span>
<span class="lineNum">    806 </span><span class="lineNoCov">    0 / 2     : { </span>
<span class="lineNum">    807 </span>              : //	D(bug(&quot;ImageDrive::Write channel %d, byte %02x, eoi %d\n&quot;, channel, byte, eoi)); </span>
<span class="lineNum">    808 </span>              :  </span>
<span class="lineNum">    809 </span><span class="lineNoCov">    0 / 2     : 	switch (ch[channel].mode) { </span>
<span class="lineNum">    810 </span>              : 		case CHMOD_FREE: </span>
<span class="lineNum">    811 </span><span class="lineNoCov">    0 / 1     : 			if (current_error == ERR_OK) </span>
<span class="lineNum">    812 </span><span class="lineNoCov">    0 / 1     : 				set_error(ERR_FILENOTOPEN); </span>
<span class="lineNum">    813 </span>              : 			break; </span>
<span class="lineNum">    814 </span>              :  </span>
<span class="lineNum">    815 </span>              : 		case CHMOD_COMMAND: </span>
<span class="lineNum">    816 </span>              : 			// Collect characters and execute command on EOI </span>
<span class="lineNum">    817 </span><span class="lineNoCov">    0 / 1     : 			if (cmd_len &gt; 58) { </span>
<span class="lineNum">    818 </span><span class="lineNoCov">    0 / 1     : 				set_error(ERR_SYNTAX32); </span>
<span class="lineNum">    819 </span><span class="lineNoCov">    0 / 1     : 				return ST_TIMEOUT; </span>
<span class="lineNum">    820 </span>              : 			} </span>
<span class="lineNum">    821 </span>              :  </span>
<span class="lineNum">    822 </span><span class="lineNoCov">    0 / 2     : 			cmd_buf[cmd_len++] = byte; </span>
<span class="lineNum">    823 </span>              :  </span>
<span class="lineNum">    824 </span><span class="lineNoCov">    0 / 2     : 			if (eoi) { </span>
<span class="lineNum">    825 </span><span class="lineNoCov">    0 / 1     : 				execute_cmd(cmd_buf, cmd_len); </span>
<span class="lineNum">    826 </span><span class="lineNoCov">    0 / 1     : 				cmd_len = 0; </span>
<span class="lineNum">    827 </span>              : 			} </span>
<span class="lineNum">    828 </span>              : 			return ST_OK; </span>
<span class="lineNum">    829 </span>              :  </span>
<span class="lineNum">    830 </span>              : 		case CHMOD_DIRECTORY: </span>
<span class="lineNum">    831 </span><span class="lineNoCov">    0 / 1     : 			set_error(ERR_WRITEFILEOPEN); </span>
<span class="lineNum">    832 </span><span class="lineNoCov">    0 / 1     : 			break; </span>
<span class="lineNum">    833 </span>              :  </span>
<span class="lineNum">    834 </span>              : 		case CHMOD_FILE: </span>
<span class="lineNum">    835 </span><span class="lineNoCov">    0 / 1     : 			if (!ch[channel].writing) </span>
<span class="lineNum">    836 </span>              : 				return ST_TIMEOUT; </span>
<span class="lineNum">    837 </span><span class="lineNoCov">    0 / 1     : 			if (current_error != ERR_OK) </span>
<span class="lineNum">    838 </span>              : 				return ST_TIMEOUT; </span>
<span class="lineNum">    839 </span>              :  </span>
<span class="lineNum">    840 </span>              : 			// Buffer full? </span>
<span class="lineNum">    841 </span><span class="lineNoCov">    0 / 1     : 			if (ch[channel].buf_len &gt;= 256) { </span>
<span class="lineNum">    842 </span>              :  </span>
<span class="lineNum">    843 </span>              : 				// Yes, allocate new block </span>
<span class="lineNum">    844 </span><span class="lineNoCov">    0 / 3     : 				int track = ch[channel].track, sector = ch[channel].sector; </span>
<span class="lineNum">    845 </span><span class="lineNoCov">    0 / 3     : 				if (!alloc_next_block(track, sector, DATA_INTERLEAVE)) </span>
<span class="lineNum">    846 </span>              : 					return ST_TIMEOUT; </span>
<span class="lineNum">    847 </span><span class="lineNoCov">    0 / 1     : 				ch[channel].num_blocks++; </span>
<span class="lineNum">    848 </span>              : 				D(bug(&quot;next data block on track %d, sector %d\n&quot;, track, sector)); </span>
<span class="lineNum">    849 </span>              :  </span>
<span class="lineNum">    850 </span>              : 				// Write buffer with link to new block </span>
<span class="lineNum">    851 </span><span class="lineNoCov">    0 / 2     : 				ch[channel].buf[0] = track; </span>
<span class="lineNum">    852 </span><span class="lineNoCov">    0 / 1     : 				ch[channel].buf[1] = sector; </span>
<span class="lineNum">    853 </span><span class="lineNoCov">    0 / 1     : 				write_sector(ch[channel].track, ch[channel].sector, ch[channel].buf); </span>
<span class="lineNum">    854 </span>              :  </span>
<span class="lineNum">    855 </span>              : 				// Reset buffer </span>
<span class="lineNum">    856 </span><span class="lineNoCov">    0 / 2     : 				ch[channel].buf_ptr = ch[channel].buf + 2; </span>
<span class="lineNum">    857 </span><span class="lineNoCov">    0 / 1     : 				ch[channel].buf_len = 2; </span>
<span class="lineNum">    858 </span><span class="lineNoCov">    0 / 2     : 				ch[channel].track = track; </span>
<span class="lineNum">    859 </span><span class="lineNoCov">    0 / 3     : 				ch[channel].sector = sector; </span>
<span class="lineNum">    860 </span>              : 			} </span>
<span class="lineNum">    861 </span><span class="lineNoCov">    0 / 1     : 			*(ch[channel].buf_ptr)++ = byte; </span>
<span class="lineNum">    862 </span><span class="lineNoCov">    0 / 1     : 			ch[channel].buf_len++; </span>
<span class="lineNum">    863 </span><span class="lineNoCov">    0 / 1     : 			return ST_OK; </span>
<span class="lineNum">    864 </span>              :  </span>
<span class="lineNum">    865 </span>              : 		case CHMOD_DIRECT: </span>
<span class="lineNum">    866 </span><span class="lineNoCov">    0 / 1     : 			if (ch[channel].buf_len &lt; 256) { </span>
<span class="lineNum">    867 </span><span class="lineNoCov">    0 / 1     : 				*(ch[channel].buf_ptr)++ = byte; </span>
<span class="lineNum">    868 </span><span class="lineNoCov">    0 / 1     : 				ch[channel].buf_len++; </span>
<span class="lineNum">    869 </span><span class="lineNoCov">    0 / 2     : 				return ST_OK; </span>
<span class="lineNum">    870 </span>              : 			} else </span>
<span class="lineNum">    871 </span>              : 				return ST_TIMEOUT; </span>
<span class="lineNum">    872 </span>              : 			break; </span>
<span class="lineNum">    873 </span>              : 	} </span>
<span class="lineNum">    874 </span>              : 	return ST_TIMEOUT; </span>
<span class="lineNum">    875 </span><span class="lineNoCov">    0 / 1     : } </span>
<span class="lineNum">    876 </span>              :  </span>
<span class="lineNum">    877 </span>              :  </span>
<span class="lineNum">    878 </span>              : /* </span>
<span class="lineNum">    879 </span>              :  *  Reset drive </span>
<span class="lineNum">    880 </span>              :  */ </span>
<span class="lineNum">    881 </span>              :  </span>
<span class="lineNum">    882 </span>              : void ImageDrive::Reset(void) </span>
<span class="lineNum">    883 </span><span class="lineCov">    2 / 2     : { </span>
<span class="lineNum">    884 </span><span class="lineCov">    1 / 1     : 	close_all_channels(); </span>
<span class="lineNum">    885 </span>              :  </span>
<span class="lineNum">    886 </span><span class="lineCov">    1 / 1     : 	cmd_len = 0; </span>
<span class="lineNum">    887 </span>              : 	for (int i=0; i&lt;4; i++) </span>
<span class="lineNum">    888 </span><span class="lineCov">    1 / 1     : 		buf_free[i] = true; </span>
<span class="lineNum">    889 </span>              :  </span>
<span class="lineNum">    890 </span><span class="lineCov">    2 / 2     : 	if (bam_dirty) { </span>
<span class="lineNum">    891 </span><span class="lineNoCov">    0 / 1     : 		write_sector(DIR_TRACK, 0, bam); </span>
<span class="lineNum">    892 </span><span class="lineNoCov">    0 / 1     : 		bam_dirty = false; </span>
<span class="lineNum">    893 </span>              : 	} </span>
<span class="lineNum">    894 </span>              :  </span>
<span class="lineNum">    895 </span>              : 	memset(ram, 0, sizeof(ram)); </span>
<span class="lineNum">    896 </span>              :  </span>
<span class="lineNum">    897 </span><span class="lineCov">    2 / 2     : 	read_sector(DIR_TRACK, 0, bam); </span>
<span class="lineNum">    898 </span>              :  </span>
<span class="lineNum">    899 </span><span class="lineCov">    1 / 1     : 	set_error(ERR_STARTUP); </span>
<span class="lineNum">    900 </span><span class="lineCov">    1 / 1     : } </span>
<span class="lineNum">    901 </span>              :  </span>
<span class="lineNum">    902 </span>              :  </span>
<span class="lineNum">    903 </span>              : /* </span>
<span class="lineNum">    904 </span>              :  *  Allocate floppy buffer </span>
<span class="lineNum">    905 </span>              :  *   -&gt; Desired buffer number or -1 </span>
<span class="lineNum">    906 </span>              :  *   &lt;- Allocated buffer number or -1 </span>
<span class="lineNum">    907 </span>              :  */ </span>
<span class="lineNum">    908 </span>              :  </span>
<span class="lineNum">    909 </span>              : int ImageDrive::alloc_buffer(int want) </span>
<span class="lineNum">    910 </span><span class="lineNoCov">    0 / 2     : { </span>
<span class="lineNum">    911 </span><span class="lineNoCov">    0 / 1     : 	if (want == -1) { </span>
<span class="lineNum">    912 </span>              : 		for (want=3; want&gt;=0; want--) </span>
<span class="lineNum">    913 </span><span class="lineNoCov">    0 / 13    : 			if (buf_free[want]) { </span>
<span class="lineNum">    914 </span><span class="lineNoCov">    0 / 3     : 				buf_free[want] = false; </span>
<span class="lineNum">    915 </span>              : 				return want; </span>
<span class="lineNum">    916 </span>              : 			} </span>
<span class="lineNum">    917 </span>              : 		return -1; </span>
<span class="lineNum">    918 </span>              : 	} </span>
<span class="lineNum">    919 </span>              :  </span>
<span class="lineNum">    920 </span><span class="lineNoCov">    0 / 1     : 	if (want &lt; 4) </span>
<span class="lineNum">    921 </span><span class="lineNoCov">    0 / 3     : 		if (buf_free[want]) { </span>
<span class="lineNum">    922 </span><span class="lineNoCov">    0 / 2     : 			buf_free[want] = false; </span>
<span class="lineNum">    923 </span>              : 			return want; </span>
<span class="lineNum">    924 </span>              : 		} else </span>
<span class="lineNum">    925 </span>              : 			return -1; </span>
<span class="lineNum">    926 </span>              : 	else </span>
<span class="lineNum">    927 </span>              : 		return -1; </span>
<span class="lineNum">    928 </span><span class="lineNoCov">    0 / 2     : } </span>
<span class="lineNum">    929 </span>              :  </span>
<span class="lineNum">    930 </span>              :  </span>
<span class="lineNum">    931 </span>              : /* </span>
<span class="lineNum">    932 </span>              :  *  Free floppy buffer </span>
<span class="lineNum">    933 </span>              :  */ </span>
<span class="lineNum">    934 </span>              :  </span>
<span class="lineNum">    935 </span>              : void ImageDrive::free_buffer(int buf) </span>
<span class="lineNum">    936 </span><span class="lineNoCov">    0 / 1     : { </span>
<span class="lineNum">    937 </span><span class="lineNoCov">    0 / 5     : 	buf_free[buf] = true; </span>
<span class="lineNum">    938 </span><span class="lineNoCov">    0 / 1     : } </span>
<span class="lineNum">    939 </span>              :  </span>
<span class="lineNum">    940 </span>              :  </span>
<span class="lineNum">    941 </span>              : /* </span>
<span class="lineNum">    942 </span>              :  *  Search file in directory, return directory track/sector and entry number </span>
<span class="lineNum">    943 </span>              :  *  false: not found, true: found </span>
<span class="lineNum">    944 </span>              :  */ </span>
<span class="lineNum">    945 </span>              :  </span>
<span class="lineNum">    946 </span>              : // Return true if name 'n' matches pattern 'p' </span>
<span class="lineNum">    947 </span>              : static bool match(const uint8 *p, int p_len, const uint8 *n) </span>
<span class="lineNum">    948 </span>              : { </span>
<span class="lineNum">    949 </span><span class="lineNoCov">    0 / 3     : 	if (p_len &gt; 16) </span>
<span class="lineNum">    950 </span>              : 		p_len = 16; </span>
<span class="lineNum">    951 </span>              :  </span>
<span class="lineNum">    952 </span>              : 	int c = 0; </span>
<span class="lineNum">    953 </span><span class="lineNoCov">    0 / 12    : 	while (p_len-- &gt; 0) { </span>
<span class="lineNum">    954 </span><span class="lineNoCov">    0 / 3     : 		if (*p == '*')	// Wildcard '*' matches all following characters </span>
<span class="lineNum">    955 </span>              : 			return true; </span>
<span class="lineNum">    956 </span><span class="lineNoCov">    0 / 3     : 		if ((*p != *n) &amp;&amp; (*p != '?'))	// Wildcard '?' matches single character </span>
<span class="lineNum">    957 </span>              : 			return false; </span>
<span class="lineNum">    958 </span><span class="lineNoCov">    0 / 2     : 		p++; n++; c++; </span>
<span class="lineNum">    959 </span>              : 	} </span>
<span class="lineNum">    960 </span>              :  </span>
<span class="lineNum">    961 </span>              : 	return *n == 0xa0 || c == 16; </span>
<span class="lineNum">    962 </span>              : } </span>
<span class="lineNum">    963 </span>              :  </span>
<span class="lineNum">    964 </span>              : bool ImageDrive::find_file(const uint8 *pattern, int pattern_len, int &amp;dir_track, int &amp;dir_sector, int &amp;entry, bool cont) </span>
<span class="lineNum">    965 </span><span class="lineNoCov">    0 / 2     : { </span>
<span class="lineNum">    966 </span>              : 	// Counter to prevent cyclic directories from resulting in an infinite loop </span>
<span class="lineNum">    967 </span>              : 	int num_dir_blocks = 0; </span>
<span class="lineNum">    968 </span>              :  </span>
<span class="lineNum">    969 </span>              : 	// Pointer to current directory entry </span>
<span class="lineNum">    970 </span>              : 	uint8 *de = NULL; </span>
<span class="lineNum">    971 </span><span class="lineNoCov">    0 / 1     : 	if (cont) </span>
<span class="lineNum">    972 </span><span class="lineNoCov">    0 / 1     : 		de = dir + DIR_ENTRIES + entry * SIZEOF_DE; </span>
<span class="lineNum">    973 </span>              : 	else { </span>
<span class="lineNum">    974 </span><span class="lineNoCov">    0 / 2     : 		dir[DIR_NEXT_TRACK] = DIR_TRACK; </span>
<span class="lineNum">    975 </span><span class="lineNoCov">    0 / 1     : 		dir[DIR_NEXT_SECTOR] = 1; </span>
<span class="lineNum">    976 </span><span class="lineNoCov">    0 / 4     : 		entry = 8; </span>
<span class="lineNum">    977 </span>              : 	} </span>
<span class="lineNum">    978 </span>              :  </span>
<span class="lineNum">    979 </span><span class="lineNoCov">    0 / 2     : 	while (num_dir_blocks &lt; num_sectors[DIR_TRACK]) { </span>
<span class="lineNum">    980 </span>              :  </span>
<span class="lineNum">    981 </span>              : 		// Goto next entry </span>
<span class="lineNum">    982 </span><span class="lineNoCov">    0 / 7     : 		entry++; de += SIZEOF_DE; </span>
<span class="lineNum">    983 </span><span class="lineNoCov">    0 / 4     : 		if (entry &gt;= 8) { </span>
<span class="lineNum">    984 </span>              :  </span>
<span class="lineNum">    985 </span>              : 			// Read next directory block </span>
<span class="lineNum">    986 </span><span class="lineNoCov">    0 / 1     : 			if (dir[DIR_NEXT_TRACK] == 0) </span>
<span class="lineNum">    987 </span>              : 				return false; </span>
<span class="lineNum">    988 </span><span class="lineNoCov">    0 / 1     : 			if (!read_sector(dir_track = dir[DIR_NEXT_TRACK], dir_sector = dir[DIR_NEXT_SECTOR], dir)) </span>
<span class="lineNum">    989 </span>              : 				return false; </span>
<span class="lineNum">    990 </span><span class="lineNoCov">    0 / 1     : 			num_dir_blocks++; </span>
<span class="lineNum">    991 </span><span class="lineNoCov">    0 / 2     : 			entry = 0; </span>
<span class="lineNum">    992 </span><span class="lineNoCov">    0 / 2     : 			de = dir + DIR_ENTRIES; </span>
<span class="lineNum">    993 </span>              : 		} </span>
<span class="lineNum">    994 </span>              :  </span>
<span class="lineNum">    995 </span>              : 		// Does entry match pattern? </span>
<span class="lineNum">    996 </span><span class="lineNoCov">    0 / 3     : 		if (de[DE_TYPE] &amp;&amp; match(pattern, pattern_len, de + DE_NAME) &amp;&amp; </span>
<span class="lineNum">    997 </span><span class="lineNoCov">    0 / 1     : 				(de[DE_NUM_BLOCKS_L] | (de[DE_NUM_BLOCKS_H] &lt;&lt; 8)) &gt; 0) </span>
<span class="lineNum">    998 </span>              : 			return true; </span>
<span class="lineNum">    999 </span>              : 	} </span>
<span class="lineNum">   1000 </span>              : 	return false; </span>
<span class="lineNum">   1001 </span><span class="lineNoCov">    0 / 1     : } </span>
<span class="lineNum">   1002 </span>              :  </span>
<span class="lineNum">   1003 </span>              : bool ImageDrive::find_first_file(const uint8 *pattern, int pattern_len, int &amp;dir_track, int &amp;dir_sector, int &amp;entry) </span>
<span class="lineNum">   1004 </span><span class="lineNoCov">    0 / 1     : { </span>
<span class="lineNum">   1005 </span><span class="lineNoCov">    0 / 1     : 	return find_file(pattern, pattern_len, dir_track, dir_sector, entry, false); </span>
<span class="lineNum">   1006 </span><span class="lineNoCov">    0 / 1     : } </span>
<span class="lineNum">   1007 </span>              :  </span>
<span class="lineNum">   1008 </span>              : bool ImageDrive::find_next_file(const uint8 *pattern, int pattern_len, int &amp;dir_track, int &amp;dir_sector, int &amp;entry) </span>
<span class="lineNum">   1009 </span><span class="lineNoCov">    0 / 1     : { </span>
<span class="lineNum">   1010 </span><span class="lineNoCov">    0 / 1     : 	return find_file(pattern, pattern_len, dir_track, dir_sector, entry, true); </span>
<span class="lineNum">   1011 </span><span class="lineNoCov">    0 / 1     : } </span>
<span class="lineNum">   1012 </span>              :  </span>
<span class="lineNum">   1013 </span>              :  </span>
<span class="lineNum">   1014 </span>              : /* </span>
<span class="lineNum">   1015 </span>              :  *  Allocate new entry in directory, returns false on error (usually when </span>
<span class="lineNum">   1016 </span>              :  *  all sectors of track 18 are allocated) </span>
<span class="lineNum">   1017 </span>              :  *  The track/sector and entry numbers are returned </span>
<span class="lineNum">   1018 </span>              :  */ </span>
<span class="lineNum">   1019 </span>              :  </span>
<span class="lineNum">   1020 </span>              : bool ImageDrive::alloc_dir_entry(int &amp;track, int &amp;sector, int &amp;entry) </span>
<span class="lineNum">   1021 </span><span class="lineNoCov">    0 / 2     : { </span>
<span class="lineNum">   1022 </span>              : 	// First look for free entry in existing directory blocks </span>
<span class="lineNum">   1023 </span><span class="lineNoCov">    0 / 1     : 	dir[DIR_NEXT_TRACK] = DIR_TRACK; </span>
<span class="lineNum">   1024 </span><span class="lineNoCov">    0 / 1     : 	dir[DIR_NEXT_SECTOR] = 1; </span>
<span class="lineNum">   1025 </span><span class="lineNoCov">    0 / 1     : 	while (dir[DIR_NEXT_TRACK]) { </span>
<span class="lineNum">   1026 </span><span class="lineNoCov">    0 / 2     : 		if (!read_sector(track = dir[DIR_NEXT_TRACK], sector = dir[DIR_NEXT_SECTOR], dir)) </span>
<span class="lineNum">   1027 </span>              : 			return false; </span>
<span class="lineNum">   1028 </span>              :  </span>
<span class="lineNum">   1029 </span><span class="lineNoCov">    0 / 2     : 		uint8 *de = dir + DIR_ENTRIES; </span>
<span class="lineNum">   1030 </span><span class="lineNoCov">    0 / 3     : 		for (entry=0; entry&lt;8; entry++, de+=SIZEOF_DE) { </span>
<span class="lineNum">   1031 </span><span class="lineNoCov">    0 / 2     : 			if (de[DE_TYPE] == 0) { </span>
<span class="lineNum">   1032 </span>              : 				D(bug(&quot; allocated entry %d in dir track %d, sector %d\n&quot;, entry, track, sector)); </span>
<span class="lineNum">   1033 </span>              : 				return true; </span>
<span class="lineNum">   1034 </span>              : 			} </span>
<span class="lineNum">   1035 </span>              : 		} </span>
<span class="lineNum">   1036 </span>              : 	} </span>
<span class="lineNum">   1037 </span>              :  </span>
<span class="lineNum">   1038 </span>              : 	// No free entry found, allocate new directory block </span>
<span class="lineNum">   1039 </span><span class="lineNoCov">    0 / 1     : 	int last_track = track, last_sector = sector; </span>
<span class="lineNum">   1040 </span><span class="lineNoCov">    0 / 1     : 	if (!alloc_next_block(track, sector, DIR_INTERLEAVE)) </span>
<span class="lineNum">   1041 </span>              : 		return false; </span>
<span class="lineNum">   1042 </span>              : 	D(bug(&quot; new directory block track %d, sector %d\n&quot;, track, sector)); </span>
<span class="lineNum">   1043 </span>              :  </span>
<span class="lineNum">   1044 </span>              : 	// Write link to new block to last block </span>
<span class="lineNum">   1045 </span><span class="lineNoCov">    0 / 1     : 	dir[DIR_NEXT_TRACK] = track; </span>
<span class="lineNum">   1046 </span><span class="lineNoCov">    0 / 1     : 	dir[DIR_NEXT_SECTOR] = sector; </span>
<span class="lineNum">   1047 </span><span class="lineNoCov">    0 / 1     : 	write_sector(last_track, last_sector, dir); </span>
<span class="lineNum">   1048 </span>              :  </span>
<span class="lineNum">   1049 </span>              : 	// Write new empty directory block and return first entry </span>
<span class="lineNum">   1050 </span>              : 	memset(dir, 0, 256); </span>
<span class="lineNum">   1051 </span><span class="lineNoCov">    0 / 1     : 	dir[DIR_NEXT_SECTOR] = 0xff; </span>
<span class="lineNum">   1052 </span><span class="lineNoCov">    0 / 1     : 	write_sector(track, sector, dir); </span>
<span class="lineNum">   1053 </span><span class="lineNoCov">    0 / 1     : 	entry = 0; </span>
<span class="lineNum">   1054 </span><span class="lineNoCov">    0 / 2     : 	return true; </span>
<span class="lineNum">   1055 </span><span class="lineNoCov">    0 / 4     : } </span>
<span class="lineNum">   1056 </span>              :  </span>
<span class="lineNum">   1057 </span>              : /* </span>
<span class="lineNum">   1058 </span>              :  *  Test if block is free in BAM (track/sector are not checked for validity) </span>
<span class="lineNum">   1059 </span>              :  */ </span>
<span class="lineNum">   1060 </span>              :  </span>
<span class="lineNum">   1061 </span>              : bool ImageDrive::is_block_free(int track, int sector) </span>
<span class="lineNum">   1062 </span><span class="lineNoCov">    0 / 4     : { </span>
<span class="lineNum">   1063 </span>              : 	uint8 *p = bam + BAM_BITMAP + (track - 1) * 4; </span>
<span class="lineNum">   1064 </span>              : 	int byte = sector / 8 + 1; </span>
<span class="lineNum">   1065 </span>              : 	int bit = sector &amp; 7; </span>
<span class="lineNum">   1066 </span>              : 	return p[byte] &amp; (1 &lt;&lt; bit); </span>
<span class="lineNum">   1067 </span><span class="lineNoCov">    0 / 3     : } </span>
<span class="lineNum">   1068 </span>              :  </span>
<span class="lineNum">   1069 </span>              :  </span>
<span class="lineNum">   1070 </span>              : /* </span>
<span class="lineNum">   1071 </span>              :  *  Get number of free blocks on a track </span>
<span class="lineNum">   1072 </span>              :  */ </span>
<span class="lineNum">   1073 </span>              :  </span>
<span class="lineNum">   1074 </span>              : int ImageDrive::num_free_blocks(int track) </span>
<span class="lineNum">   1075 </span><span class="lineNoCov">    0 / 3     : { </span>
<span class="lineNum">   1076 </span><span class="lineNoCov">    0 / 2     : 	return bam[BAM_BITMAP + (track - 1) * 4]; </span>
<span class="lineNum">   1077 </span><span class="lineNoCov">    0 / 2     : } </span>
<span class="lineNum">   1078 </span>              :  </span>
<span class="lineNum">   1079 </span>              :  </span>
<span class="lineNum">   1080 </span>              : /* </span>
<span class="lineNum">   1081 </span>              :  *  Clear BAM, mark all blocks as free </span>
<span class="lineNum">   1082 </span>              :  */ </span>
<span class="lineNum">   1083 </span>              :  </span>
<span class="lineNum">   1084 </span>              : static void clear_bam(uint8 *bam) </span>
<span class="lineNum">   1085 </span>              : { </span>
<span class="lineNum">   1086 </span><span class="lineNoCov">    0 / 2     : 	for (int track=1; track&lt;=35; track++) { </span>
<span class="lineNum">   1087 </span>              : 		static const uint8 num2bits[8] = {0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff}; </span>
<span class="lineNum">   1088 </span><span class="lineNoCov">    0 / 4     : 		(bam + BAM_BITMAP)[(track-1) * 4 + 0] = num_sectors[track]; </span>
<span class="lineNum">   1089 </span><span class="lineNoCov">    0 / 2     : 		(bam + BAM_BITMAP)[(track-1) * 4 + 1] = 0xff; </span>
<span class="lineNum">   1090 </span><span class="lineNoCov">    0 / 2     : 		(bam + BAM_BITMAP)[(track-1) * 4 + 2] = 0xff; </span>
<span class="lineNum">   1091 </span><span class="lineNoCov">    0 / 2     : 		(bam + BAM_BITMAP)[(track-1) * 4 + 3] = num2bits[num_sectors[track] - 16]; </span>
<span class="lineNum">   1092 </span>              : 	} </span>
<span class="lineNum">   1093 </span>              : } </span>
<span class="lineNum">   1094 </span>              :  </span>
<span class="lineNum">   1095 </span>              :  </span>
<span class="lineNum">   1096 </span>              : /* </span>
<span class="lineNum">   1097 </span>              :  *  Allocate block in BAM, returns error code </span>
<span class="lineNum">   1098 </span>              :  */ </span>
<span class="lineNum">   1099 </span>              :  </span>
<span class="lineNum">   1100 </span>              : int ImageDrive::alloc_block(int track, int sector) </span>
<span class="lineNum">   1101 </span><span class="lineNoCov">    0 / 1     : { </span>
<span class="lineNum">   1102 </span><span class="lineNoCov">    0 / 1     : 	if (track &lt; 1 || track &gt; 35 || sector &lt; 0 || sector &gt;= num_sectors[track]) </span>
<span class="lineNum">   1103 </span>              : 		return ERR_ILLEGALTS; </span>
<span class="lineNum">   1104 </span>              :  </span>
<span class="lineNum">   1105 </span><span class="lineNoCov">    0 / 2     : 	uint8 *p = bam + BAM_BITMAP + (track - 1) * 4; </span>
<span class="lineNum">   1106 </span>              : 	int byte = sector / 8 + 1; </span>
<span class="lineNum">   1107 </span><span class="lineNoCov">    0 / 2     : 	int bit = sector &amp; 7; </span>
<span class="lineNum">   1108 </span>              :  </span>
<span class="lineNum">   1109 </span>              : 	// Block free? </span>
<span class="lineNum">   1110 </span><span class="lineNoCov">    0 / 3     : 	if (p[byte] &amp; (1 &lt;&lt; bit)) { </span>
<span class="lineNum">   1111 </span>              :  </span>
<span class="lineNum">   1112 </span>              : 		// Yes, allocate and decrement free block count </span>
<span class="lineNum">   1113 </span>              : 		D(bug(&quot;allocating block at track %d, sector %d\n&quot;, track, sector)); </span>
<span class="lineNum">   1114 </span><span class="lineNoCov">    0 / 1     : 		p[byte] &amp;= ~(1 &lt;&lt; bit); </span>
<span class="lineNum">   1115 </span><span class="lineNoCov">    0 / 1     : 		p[0]--; </span>
<span class="lineNum">   1116 </span><span class="lineNoCov">    0 / 2     : 		bam_dirty = true; </span>
<span class="lineNum">   1117 </span><span class="lineNoCov">    0 / 1     : 		return ERR_OK; </span>
<span class="lineNum">   1118 </span>              :  </span>
<span class="lineNum">   1119 </span>              : 	} else </span>
<span class="lineNum">   1120 </span>              : 		return ERR_NOBLOCK; </span>
<span class="lineNum">   1121 </span><span class="lineNoCov">    0 / 1     : } </span>
<span class="lineNum">   1122 </span>              :  </span>
<span class="lineNum">   1123 </span>              :  </span>
<span class="lineNum">   1124 </span>              : /* </span>
<span class="lineNum">   1125 </span>              :  *  Free block in BAM, returns error code </span>
<span class="lineNum">   1126 </span>              :  */ </span>
<span class="lineNum">   1127 </span>              :  </span>
<span class="lineNum">   1128 </span>              : int ImageDrive::free_block(int track, int sector) </span>
<span class="lineNum">   1129 </span><span class="lineNoCov">    0 / 1     : { </span>
<span class="lineNum">   1130 </span><span class="lineNoCov">    0 / 1     : 	if (track &lt; 1 || track &gt; 35 || sector &lt; 0 || sector &gt;= num_sectors[track]) </span>
<span class="lineNum">   1131 </span>              : 		return ERR_ILLEGALTS; </span>
<span class="lineNum">   1132 </span>              :  </span>
<span class="lineNum">   1133 </span><span class="lineNoCov">    0 / 2     : 	uint8 *p = bam + BAM_BITMAP + (track - 1) * 4; </span>
<span class="lineNum">   1134 </span>              : 	int byte = sector / 8 + 1; </span>
<span class="lineNum">   1135 </span><span class="lineNoCov">    0 / 2     : 	int bit = sector &amp; 7; </span>
<span class="lineNum">   1136 </span>              :  </span>
<span class="lineNum">   1137 </span>              : 	// Block allocated? </span>
<span class="lineNum">   1138 </span><span class="lineNoCov">    0 / 3     : 	if (!(p[byte] &amp; (1 &lt;&lt; bit))) { </span>
<span class="lineNum">   1139 </span>              :  </span>
<span class="lineNum">   1140 </span>              : 		// Yes, free and increment free block count </span>
<span class="lineNum">   1141 </span>              : 		D(bug(&quot;freeing block at track %d, sector %d\n&quot;, track, sector)); </span>
<span class="lineNum">   1142 </span><span class="lineNoCov">    0 / 1     : 		p[byte] |= (1 &lt;&lt; bit); </span>
<span class="lineNum">   1143 </span><span class="lineNoCov">    0 / 1     : 		p[0]++; </span>
<span class="lineNum">   1144 </span><span class="lineNoCov">    0 / 2     : 		bam_dirty = true; </span>
<span class="lineNum">   1145 </span>              : 	} </span>
<span class="lineNum">   1146 </span>              : 	return ERR_OK; </span>
<span class="lineNum">   1147 </span><span class="lineNoCov">    0 / 1     : } </span>
<span class="lineNum">   1148 </span>              :  </span>
<span class="lineNum">   1149 </span>              :  </span>
<span class="lineNum">   1150 </span>              : /* </span>
<span class="lineNum">   1151 </span>              :  *  Allocate chain of data blocks in BAM </span>
<span class="lineNum">   1152 </span>              :  */ </span>
<span class="lineNum">   1153 </span>              :  </span>
<span class="lineNum">   1154 </span>              : bool ImageDrive::alloc_block_chain(int track, int sector) </span>
<span class="lineNum">   1155 </span><span class="lineNoCov">    0 / 2     : { </span>
<span class="lineNum">   1156 </span>              : 	uint8 buf[256]; </span>
<span class="lineNum">   1157 </span><span class="lineNoCov">    0 / 2     : 	while (alloc_block(track, sector) == ERR_OK) { </span>
<span class="lineNum">   1158 </span><span class="lineNoCov">    0 / 1     : 		if (!read_sector(track, sector, buf)) </span>
<span class="lineNum">   1159 </span>              : 			return false; </span>
<span class="lineNum">   1160 </span><span class="lineNoCov">    0 / 1     : 		track = buf[0]; </span>
<span class="lineNum">   1161 </span><span class="lineNoCov">    0 / 1     : 		sector = buf[1]; </span>
<span class="lineNum">   1162 </span>              : 	} </span>
<span class="lineNum">   1163 </span>              : 	return true; </span>
<span class="lineNum">   1164 </span><span class="lineNoCov">    0 / 1     : } </span>
<span class="lineNum">   1165 </span>              :  </span>
<span class="lineNum">   1166 </span>              :  </span>
<span class="lineNum">   1167 </span>              : /* </span>
<span class="lineNum">   1168 </span>              :  *  Free chain of data blocks in BAM </span>
<span class="lineNum">   1169 </span>              :  */ </span>
<span class="lineNum">   1170 </span>              :  </span>
<span class="lineNum">   1171 </span>              : bool ImageDrive::free_block_chain(int track, int sector) </span>
<span class="lineNum">   1172 </span><span class="lineNoCov">    0 / 2     : { </span>
<span class="lineNum">   1173 </span>              : 	uint8 buf[256]; </span>
<span class="lineNum">   1174 </span><span class="lineNoCov">    0 / 2     : 	while (free_block(track, sector) == ERR_OK) { </span>
<span class="lineNum">   1175 </span><span class="lineNoCov">    0 / 1     : 		if (!read_sector(track, sector, buf)) </span>
<span class="lineNum">   1176 </span>              : 			return false; </span>
<span class="lineNum">   1177 </span><span class="lineNoCov">    0 / 1     : 		track = buf[0]; </span>
<span class="lineNum">   1178 </span><span class="lineNoCov">    0 / 1     : 		sector = buf[1]; </span>
<span class="lineNum">   1179 </span>              : 	} </span>
<span class="lineNum">   1180 </span>              : 	return true; </span>
<span class="lineNum">   1181 </span><span class="lineNoCov">    0 / 1     : } </span>
<span class="lineNum">   1182 </span>              :  </span>
<span class="lineNum">   1183 </span>              :  </span>
<span class="lineNum">   1184 </span>              : /* </span>
<span class="lineNum">   1185 </span>              :  *  Search and allocate next free block, returns false if no more blocks </span>
<span class="lineNum">   1186 </span>              :  *  are free (ERR_DISKFULL is also set in this case) </span>
<span class="lineNum">   1187 </span>              :  *  &quot;track&quot; and &quot;sector&quot; must be set to the block where the search should </span>
<span class="lineNum">   1188 </span>              :  *  begin </span>
<span class="lineNum">   1189 </span>              :  */ </span>
<span class="lineNum">   1190 </span>              :  </span>
<span class="lineNum">   1191 </span><span class="lineNoCov">    0 / 1     : bool ImageDrive::alloc_next_block(int &amp;track, int &amp;sector, int interleave) </span>
<span class="lineNum">   1192 </span><span class="lineNoCov">    0 / 3     : { </span>
<span class="lineNum">   1193 </span>              : 	// Find track with free blocks </span>
<span class="lineNum">   1194 </span>              : 	bool side_changed = false; </span>
<span class="lineNum">   1195 </span><span class="lineNoCov">    0 / 2     : 	while (num_free_blocks(track) == 0) { </span>
<span class="lineNum">   1196 </span><span class="lineNoCov">    0 / 1     : 		if (track == DIR_TRACK) {	// Directory doesn't grow to other tracks </span>
<span class="lineNum">   1197 </span><span class="lineNoCov">    0 / 1     : full:		track = sector = 0; </span>
<span class="lineNum">   1198 </span><span class="lineNoCov">    0 / 1     : 			set_error(ERR_DISKFULL); </span>
<span class="lineNum">   1199 </span>              : 			return false; </span>
<span class="lineNum">   1200 </span><span class="lineNoCov">    0 / 1     : 		} else if (track &gt; DIR_TRACK) { </span>
<span class="lineNum">   1201 </span><span class="lineNoCov">    0 / 2     : 			track++; </span>
<span class="lineNum">   1202 </span><span class="lineNoCov">    0 / 2     : 			if (track &gt; 35) { </span>
<span class="lineNum">   1203 </span><span class="lineNoCov">    0 / 1     : 				if (!side_changed) </span>
<span class="lineNum">   1204 </span>              : 					side_changed = true; </span>
<span class="lineNum">   1205 </span>              : 				else </span>
<span class="lineNum">   1206 </span>              : 					goto full; </span>
<span class="lineNum">   1207 </span><span class="lineNoCov">    0 / 1     : 				track = DIR_TRACK - 1; </span>
<span class="lineNum">   1208 </span><span class="lineNoCov">    0 / 1     : 				sector = 0; </span>
<span class="lineNum">   1209 </span>              : 			} </span>
<span class="lineNum">   1210 </span>              : 		} else { </span>
<span class="lineNum">   1211 </span><span class="lineNoCov">    0 / 2     : 			track--; </span>
<span class="lineNum">   1212 </span><span class="lineNoCov">    0 / 2     : 			if (track &lt; 1) { </span>
<span class="lineNum">   1213 </span><span class="lineNoCov">    0 / 1     : 				if (!side_changed) </span>
<span class="lineNum">   1214 </span>              : 					side_changed = true; </span>
<span class="lineNum">   1215 </span>              : 				else </span>
<span class="lineNum">   1216 </span>              : 					goto full; </span>
<span class="lineNum">   1217 </span><span class="lineNoCov">    0 / 1     : 				track = DIR_TRACK + 1; </span>
<span class="lineNum">   1218 </span><span class="lineNoCov">    0 / 1     : 				sector = 0; </span>
<span class="lineNum">   1219 </span>              : 			} </span>
<span class="lineNum">   1220 </span>              : 		} </span>
<span class="lineNum">   1221 </span>              : 	} </span>
<span class="lineNum">   1222 </span>              :  </span>
<span class="lineNum">   1223 </span>              : 	// Find next free block on track </span>
<span class="lineNum">   1224 </span><span class="lineNoCov">    0 / 1     : 	int num = num_sectors[track]; </span>
<span class="lineNum">   1225 </span><span class="lineNoCov">    0 / 3     : 	sector = sector + interleave; </span>
<span class="lineNum">   1226 </span><span class="lineNoCov">    0 / 2     : 	if (sector &gt;= num) { </span>
<span class="lineNum">   1227 </span><span class="lineNoCov">    0 / 1     : 		sector -= num; </span>
<span class="lineNum">   1228 </span><span class="lineNoCov">    0 / 1     : 		if (sector) </span>
<span class="lineNum">   1229 </span><span class="lineNoCov">    0 / 1     : 			sector--; </span>
<span class="lineNum">   1230 </span>              : 	} </span>
<span class="lineNum">   1231 </span><span class="lineNoCov">    0 / 1     : 	while (!is_block_free(track, sector)) { </span>
<span class="lineNum">   1232 </span><span class="lineNoCov">    0 / 1     : 		sector++; </span>
<span class="lineNum">   1233 </span><span class="lineNoCov">    0 / 1     : 		if (sector &gt;= num_sectors[track]) { </span>
<span class="lineNum">   1234 </span><span class="lineNoCov">    0 / 1     : 			sector = 0; </span>
<span class="lineNum">   1235 </span><span class="lineNoCov">    0 / 3     : 			while (!is_block_free(track, sector)) { </span>
<span class="lineNum">   1236 </span><span class="lineNoCov">    0 / 1     : 				sector++; </span>
<span class="lineNum">   1237 </span><span class="lineNoCov">    0 / 1     : 				if (sector &gt;= num_sectors[track]) { </span>
<span class="lineNum">   1238 </span>              : 					// Something is wrong: the BAM free block count for this </span>
<span class="lineNum">   1239 </span>              : 					// track was &gt;0, but we found no free blocks </span>
<span class="lineNum">   1240 </span><span class="lineNoCov">    0 / 1     : 					track = sector = 0; </span>
<span class="lineNum">   1241 </span><span class="lineNoCov">    0 / 1     : 					set_error(ERR_DIRERROR); </span>
<span class="lineNum">   1242 </span><span class="lineNoCov">    0 / 1     : 					return false; </span>
<span class="lineNum">   1243 </span>              : 				} </span>
<span class="lineNum">   1244 </span>              : 			} </span>
<span class="lineNum">   1245 </span>              : 		} </span>
<span class="lineNum">   1246 </span>              : 	} </span>
<span class="lineNum">   1247 </span>              :  </span>
<span class="lineNum">   1248 </span><span class="lineNoCov">    0 / 2     : 	alloc_block(track, sector); </span>
<span class="lineNum">   1249 </span>              : 	return true; </span>
<span class="lineNum">   1250 </span><span class="lineNoCov">    0 / 3     : } </span>
<span class="lineNum">   1251 </span>              :  </span>
<span class="lineNum">   1252 </span>              :  </span>
<span class="lineNum">   1253 </span>              : /* </span>
<span class="lineNum">   1254 </span>              :  *  Sector reading/writing routines </span>
<span class="lineNum">   1255 </span>              :  */ </span>
<span class="lineNum">   1256 </span>              :  </span>
<span class="lineNum">   1257 </span>              : static long offset_from_ts(const image_file_desc &amp;desc, int track, int sector) </span>
<span class="lineNum">   1258 </span>              : { </span>
<span class="lineNum">   1259 </span><span class="linePartCov">    3 / 6     : 	if ((track &lt; 1) || (track &gt; desc.num_tracks) </span>
<span class="lineNum">   1260 </span><span class="linePartCov">    1 / 2     : 	 || (sector &lt; 0) || (sector &gt;= num_sectors[track])) </span>
<span class="lineNum">   1261 </span>              : 		return -1; </span>
<span class="lineNum">   1262 </span>              :  </span>
<span class="lineNum">   1263 </span><span class="linePartCov">    1 / 2     : 	return ((accum_num_sectors[track] + sector) &lt;&lt; 8) + desc.header_size; </span>
<span class="lineNum">   1264 </span>              : } </span>
<span class="lineNum">   1265 </span>              :  </span>
<span class="lineNum">   1266 </span>              : // Get number of sectors per given track </span>
<span class="lineNum">   1267 </span>              : int sectors_per_track(const image_file_desc &amp;desc, int track) </span>
<span class="lineNum">   1268 </span><span class="lineNoCov">    0 / 3     : { </span>
<span class="lineNum">   1269 </span>              : 	return num_sectors[track]; </span>
<span class="lineNum">   1270 </span><span class="lineNoCov">    0 / 2     : } </span>
<span class="lineNum">   1271 </span>              :  </span>
<span class="lineNum">   1272 </span>              : // Get reference to error info byte of given track/sector </span>
<span class="lineNum">   1273 </span>              : uint8 &amp;error_info_for_sector(image_file_desc &amp;desc, int track, int sector) </span>
<span class="lineNum">   1274 </span><span class="lineNoCov">    0 / 3     : { </span>
<span class="lineNum">   1275 </span>              : 	return desc.error_info[accum_num_sectors[track] + sector]; </span>
<span class="lineNum">   1276 </span><span class="lineNoCov">    0 / 2     : } </span>
<span class="lineNum">   1277 </span>              :  </span>
<span class="lineNum">   1278 </span>              : static inline const uint8 &amp;error_info_for_sector(const image_file_desc &amp;desc, int track, int sector) </span>
<span class="lineNum">   1279 </span>              : { </span>
<span class="lineNum">   1280 </span>              : 	return desc.error_info[accum_num_sectors[track] + sector]; </span>
<span class="lineNum">   1281 </span>              : } </span>
<span class="lineNum">   1282 </span>              :  </span>
<span class="lineNum">   1283 </span>              : const int conv_job_error[16] = { </span>
<span class="lineNum">   1284 </span>              : 	ERR_OK,				// 0 -&gt; 00 OK </span>
<span class="lineNum">   1285 </span>              : 	ERR_OK,				// 1 -&gt; 00 OK </span>
<span class="lineNum">   1286 </span>              : 	ERR_READ20,			// 2 -&gt; 20 READ ERROR </span>
<span class="lineNum">   1287 </span>              : 	ERR_READ21,			// 3 -&gt; 21 READ ERROR </span>
<span class="lineNum">   1288 </span>              : 	ERR_READ22,			// 4 -&gt; 22 READ ERROR </span>
<span class="lineNum">   1289 </span>              : 	ERR_READ23,			// 5 -&gt; 23 READ ERROR </span>
<span class="lineNum">   1290 </span>              : 	ERR_READ24,			// 6 -&gt; 24 READ ERROR (undetected by 1541) </span>
<span class="lineNum">   1291 </span>              : 	ERR_WRITE25,		// 7 -&gt; 25 WRITE ERROR </span>
<span class="lineNum">   1292 </span>              : 	ERR_WRITEPROTECT,	// 8 -&gt; 26 WRITE PROTECT ON </span>
<span class="lineNum">   1293 </span>              : 	ERR_READ27,			// 9 -&gt; 27 READ ERROR </span>
<span class="lineNum">   1294 </span>              : 	ERR_WRITE28,		// 10 -&gt; 28 WRITE ERROR </span>
<span class="lineNum">   1295 </span>              : 	ERR_DISKID,			// 11 -&gt; 29 DISK ID MISMATCH </span>
<span class="lineNum">   1296 </span>              : 	ERR_OK,				// 12 -&gt; 00 OK </span>
<span class="lineNum">   1297 </span>              : 	ERR_OK,				// 13 -&gt; 00 OK </span>
<span class="lineNum">   1298 </span>              : 	ERR_OK,				// 14 -&gt; 00 OK </span>
<span class="lineNum">   1299 </span>              : 	ERR_NOTREADY		// 15 -&gt; 74 DRIVE NOT READY </span>
<span class="lineNum">   1300 </span>              : }; </span>
<span class="lineNum">   1301 </span>              :  </span>
<span class="lineNum">   1302 </span>              : // Read sector, return error code </span>
<span class="lineNum">   1303 </span>              : static int read_sector(FILE *f, const image_file_desc &amp;desc, int track, int sector, uint8 *buffer) </span>
<span class="lineNum">   1304 </span><span class="lineCov">    3 / 3     : { </span>
<span class="lineNum">   1305 </span>              : 	// Convert track/sector to byte offset in file </span>
<span class="lineNum">   1306 </span>              : 	long offset = offset_from_ts(desc, track, sector); </span>
<span class="lineNum">   1307 </span><span class="lineCov">    1 / 1     : 	if (offset &lt; 0) </span>
<span class="lineNum">   1308 </span>              : 		return ERR_ILLEGALTS; </span>
<span class="lineNum">   1309 </span>              :  </span>
<span class="lineNum">   1310 </span><span class="lineCov">    1 / 1     : 	if (f == NULL) </span>
<span class="lineNum">   1311 </span>              : 		return ERR_NOTREADY; </span>
<span class="lineNum">   1312 </span>              :  </span>
<span class="lineNum">   1313 </span><span class="lineCov">    1 / 1     : 	fseek(f, offset, SEEK_SET); </span>
<span class="lineNum">   1314 </span><span class="lineCov">    1 / 1     : 	if (fread(buffer, 1, 256, f) != 256) </span>
<span class="lineNum">   1315 </span>              : 		return ERR_READ22; </span>
<span class="lineNum">   1316 </span>              : 	else { </span>
<span class="lineNum">   1317 </span>              : 		unsigned int error = error_info_for_sector(desc, track, sector); </span>
<span class="lineNum">   1318 </span><span class="lineCov">    2 / 2     : 		return conv_job_error[error &amp; 0x0f]; </span>
<span class="lineNum">   1319 </span>              : 	} </span>
<span class="lineNum">   1320 </span><span class="lineCov">    1 / 1     : } </span>
<span class="lineNum">   1321 </span>              :  </span>
<span class="lineNum">   1322 </span>              : // Write sector, return error code </span>
<span class="lineNum">   1323 </span>              : static int write_sector(FILE *f, const image_file_desc &amp;desc, int track, int sector, uint8 *buffer) </span>
<span class="lineNum">   1324 </span><span class="lineNoCov">    0 / 2     : { </span>
<span class="lineNum">   1325 </span>              : 	// Convert track/sector to byte offset in file </span>
<span class="lineNum">   1326 </span>              : 	long offset = offset_from_ts(desc, track, sector); </span>
<span class="lineNum">   1327 </span><span class="lineNoCov">    0 / 1     : 	if (offset &lt; 0) </span>
<span class="lineNum">   1328 </span>              : 		return ERR_ILLEGALTS; </span>
<span class="lineNum">   1329 </span>              :  </span>
<span class="lineNum">   1330 </span><span class="lineNoCov">    0 / 1     : 	if (f == NULL) </span>
<span class="lineNum">   1331 </span>              : 		return ERR_NOTREADY; </span>
<span class="lineNum">   1332 </span>              :  </span>
<span class="lineNum">   1333 </span><span class="lineNoCov">    0 / 1     : 	fseek(f, offset, SEEK_SET); </span>
<span class="lineNum">   1334 </span><span class="lineNoCov">    0 / 3     : 	if (fwrite(buffer, 1, 256, f) != 256) </span>
<span class="lineNum">   1335 </span>              : 		return ERR_WRITE25; </span>
<span class="lineNum">   1336 </span>              : 	else </span>
<span class="lineNum">   1337 </span>              : 		return ERR_OK; </span>
<span class="lineNum">   1338 </span><span class="lineNoCov">    0 / 3     : } </span>
<span class="lineNum">   1339 </span>              :  </span>
<span class="lineNum">   1340 </span>              : // Read sector and set error message, returns false on error </span>
<span class="lineNum">   1341 </span>              : bool ImageDrive::read_sector(int track, int sector, uint8 *buffer) </span>
<span class="lineNum">   1342 </span><span class="lineCov">    3 / 3     : { </span>
<span class="lineNum">   1343 </span><span class="lineCov">    2 / 2     : 	int error = ::read_sector(the_file, desc, track, sector, buffer); </span>
<span class="lineNum">   1344 </span><span class="lineCov">    1 / 1     : 	if (error) </span>
<span class="lineNum">   1345 </span><span class="lineCov">    2 / 2     : 		set_error(error, track, sector); </span>
<span class="lineNum">   1346 </span>              : 	return error == ERR_OK; </span>
<span class="lineNum">   1347 </span><span class="lineCov">    2 / 2     : } </span>
<span class="lineNum">   1348 </span>              :  </span>
<span class="lineNum">   1349 </span>              : // Write sector and set error message, returns false on error </span>
<span class="lineNum">   1350 </span>              : bool ImageDrive::write_sector(int track, int sector, uint8 *buffer) </span>
<span class="lineNum">   1351 </span><span class="lineNoCov">    0 / 3     : { </span>
<span class="lineNum">   1352 </span><span class="lineNoCov">    0 / 2     : 	int error = ::write_sector(the_file, desc, track, sector, buffer); </span>
<span class="lineNum">   1353 </span><span class="lineNoCov">    0 / 1     : 	if (error) </span>
<span class="lineNum">   1354 </span><span class="lineNoCov">    0 / 2     : 		set_error(error, track, sector); </span>
<span class="lineNum">   1355 </span>              : 	return error == ERR_OK; </span>
<span class="lineNum">   1356 </span><span class="lineNoCov">    0 / 2     : } </span>
<span class="lineNum">   1357 </span>              :  </span>
<span class="lineNum">   1358 </span>              : // Write error info back to image file </span>
<span class="lineNum">   1359 </span>              : static void write_back_error_info(FILE *f, const image_file_desc &amp;desc) </span>
<span class="lineNum">   1360 </span>              : { </span>
<span class="lineNum">   1361 </span><span class="lineNoCov">    0 / 1     : 	if (desc.type == TYPE_D64 &amp;&amp; desc.has_error_info) { </span>
<span class="lineNum">   1362 </span><span class="lineNoCov">    0 / 2     : 		int num_sectors = desc.num_tracks == 40 ? NUM_SECTORS_40 : NUM_SECTORS_35; </span>
<span class="lineNum">   1363 </span><span class="lineNoCov">    0 / 2     : 		fseek(f, num_sectors * 256, SEEK_SET); </span>
<span class="lineNum">   1364 </span><span class="lineNoCov">    0 / 1     : 		fwrite(desc.error_info, num_sectors, 1, f); </span>
<span class="lineNum">   1365 </span>              : 	} </span>
<span class="lineNum">   1366 </span>              : } </span>
<span class="lineNum">   1367 </span>              :  </span>
<span class="lineNum">   1368 </span>              : // Format disk image </span>
<span class="lineNum">   1369 </span>              : static bool format_image(FILE *f, image_file_desc &amp;desc, bool lowlevel, uint8 id1, uint8 id2, const uint8 *disk_name, int disk_name_len) </span>
<span class="lineNum">   1370 </span><span class="lineNoCov">    0 / 3     : { </span>
<span class="lineNum">   1371 </span>              : 	uint8 p[256]; </span>
<span class="lineNum">   1372 </span>              :  </span>
<span class="lineNum">   1373 </span><span class="lineNoCov">    0 / 2     : 	if (lowlevel) { </span>
<span class="lineNum">   1374 </span>              :  </span>
<span class="lineNum">   1375 </span>              : 		// Fill buffer with 1541 empty sector pattern (4b 01 01 ..., </span>
<span class="lineNum">   1376 </span>              : 		// except on track 1 where it's 01 01 01 ...) </span>
<span class="lineNum">   1377 </span>              : 		memset(p, 1, 256); </span>
<span class="lineNum">   1378 </span>              :  </span>
<span class="lineNum">   1379 </span>              : 		// Overwrite all blocks </span>
<span class="lineNum">   1380 </span><span class="lineNoCov">    0 / 1     : 		for (int track=1; track&lt;=35; track++) { </span>
<span class="lineNum">   1381 </span><span class="lineNoCov">    0 / 1     : 			if (track == 2) </span>
<span class="lineNum">   1382 </span><span class="lineNoCov">    0 / 1     : 				p[0] = 0x4b; </span>
<span class="lineNum">   1383 </span><span class="lineNoCov">    0 / 1     : 			for (int sector=0; sector&lt;num_sectors[track]; sector++) { </span>
<span class="lineNum">   1384 </span><span class="lineNoCov">    0 / 1     : 				if (write_sector(f, desc, track, sector, p) != ERR_OK) </span>
<span class="lineNum">   1385 </span>              : 					return false; </span>
<span class="lineNum">   1386 </span>              : 			} </span>
<span class="lineNum">   1387 </span>              : 		} </span>
<span class="lineNum">   1388 </span>              :  </span>
<span class="lineNum">   1389 </span>              : 		// Clear and write error info </span>
<span class="lineNum">   1390 </span><span class="lineNoCov">    0 / 2     : 		memset(desc.error_info, 1, sizeof(desc.error_info)); </span>
<span class="lineNum">   1391 </span>              : 		write_back_error_info(f, desc); </span>
<span class="lineNum">   1392 </span>              :  </span>
<span class="lineNum">   1393 </span>              : 		// Clear BAM </span>
<span class="lineNum">   1394 </span>              : 		memset(p, 0, 256); </span>
<span class="lineNum">   1395 </span>              :  </span>
<span class="lineNum">   1396 </span>              : 	} else { </span>
<span class="lineNum">   1397 </span>              :  </span>
<span class="lineNum">   1398 </span>              : 		// Read BAM </span>
<span class="lineNum">   1399 </span><span class="lineNoCov">    0 / 1     : 		if (read_sector(f, desc, DIR_TRACK, 0, p) != ERR_OK) </span>
<span class="lineNum">   1400 </span>              : 			return false; </span>
<span class="lineNum">   1401 </span>              : 	} </span>
<span class="lineNum">   1402 </span>              :  </span>
<span class="lineNum">   1403 </span>              : 	// Create and write empty BAM </span>
<span class="lineNum">   1404 </span><span class="lineNoCov">    0 / 1     : 	p[BAM_DIR_TRACK] = DIR_TRACK; </span>
<span class="lineNum">   1405 </span><span class="lineNoCov">    0 / 1     : 	p[BAM_DIR_SECTOR] = 1; </span>
<span class="lineNum">   1406 </span><span class="lineNoCov">    0 / 2     : 	p[BAM_FMT_TYPE] = 'A'; </span>
<span class="lineNum">   1407 </span>              : 	clear_bam(p); </span>
<span class="lineNum">   1408 </span><span class="lineNoCov">    0 / 1     : 	p[BAM_BITMAP + (DIR_TRACK - 1) * 4 + 0] -= 2;	// Allocate BAM and first directory block </span>
<span class="lineNum">   1409 </span><span class="lineNoCov">    0 / 1     : 	p[BAM_BITMAP + (DIR_TRACK - 1) * 4 + 1] &amp;= 0xfc; </span>
<span class="lineNum">   1410 </span>              : 	memset(p + BAM_DISK_NAME, 0xa0, 27); </span>
<span class="lineNum">   1411 </span>              : 	if (disk_name_len &gt; 16) </span>
<span class="lineNum">   1412 </span>              : 		disk_name_len = 16; </span>
<span class="lineNum">   1413 </span>              : 	memcpy(p + BAM_DISK_NAME, disk_name, disk_name_len); </span>
<span class="lineNum">   1414 </span><span class="lineNoCov">    0 / 2     : 	p[BAM_DISK_ID] = id1; </span>
<span class="lineNum">   1415 </span><span class="lineNoCov">    0 / 2     : 	p[BAM_DISK_ID + 1] = id2; </span>
<span class="lineNum">   1416 </span><span class="lineNoCov">    0 / 1     : 	p[BAM_FMT_CHAR] = '2'; </span>
<span class="lineNum">   1417 </span><span class="lineNoCov">    0 / 1     : 	p[BAM_FMT_CHAR + 1] = 'A'; </span>
<span class="lineNum">   1418 </span><span class="lineNoCov">    0 / 3     : 	if (write_sector(f, desc, DIR_TRACK, 0, p) != ERR_OK) </span>
<span class="lineNum">   1419 </span>              : 		return false; </span>
<span class="lineNum">   1420 </span>              :  </span>
<span class="lineNum">   1421 </span>              : 	// Create and write empty directory </span>
<span class="lineNum">   1422 </span>              : 	memset(p, 0, 256); </span>
<span class="lineNum">   1423 </span><span class="lineNoCov">    0 / 1     : 	p[1] = 255; </span>
<span class="lineNum">   1424 </span><span class="lineNoCov">    0 / 4     : 	return write_sector(f, desc, DIR_TRACK, 1, p) == ERR_OK; </span>
<span class="lineNum">   1425 </span><span class="lineNoCov">    0 / 2     : } </span>
<span class="lineNum">   1426 </span>              :  </span>
<span class="lineNum">   1427 </span>              :  </span>
<span class="lineNum">   1428 </span>              : /* </span>
<span class="lineNum">   1429 </span>              :  *  Execute drive commands </span>
<span class="lineNum">   1430 </span>              :  */ </span>
<span class="lineNum">   1431 </span>              :  </span>
<span class="lineNum">   1432 </span>              : // BLOCK-READ:channel,0,track,sector </span>
<span class="lineNum">   1433 </span>              : void ImageDrive::block_read_cmd(int channel, int track, int sector, bool user_cmd) </span>
<span class="lineNum">   1434 </span><span class="lineNoCov">    0 / 3     : { </span>
<span class="lineNum">   1435 </span><span class="lineNoCov">    0 / 2     : 	if (channel &gt;= 16 || ch[channel].mode != CHMOD_DIRECT) { </span>
<span class="lineNum">   1436 </span><span class="lineNoCov">    0 / 5     : 		set_error(ERR_NOCHANNEL); </span>
<span class="lineNum">   1437 </span>              : 		return; </span>
<span class="lineNum">   1438 </span>              : 	} </span>
<span class="lineNum">   1439 </span><span class="lineNoCov">    0 / 1     : 	if (!read_sector(track, sector, ch[channel].buf)) </span>
<span class="lineNum">   1440 </span>              : 		return; </span>
<span class="lineNum">   1441 </span><span class="lineNoCov">    0 / 1     : 	if (user_cmd) { </span>
<span class="lineNum">   1442 </span><span class="lineNoCov">    0 / 1     : 		ch[channel].buf_len = 256; </span>
<span class="lineNum">   1443 </span><span class="lineNoCov">    0 / 2     : 		ch[channel].buf_ptr = ch[channel].buf; </span>
<span class="lineNum">   1444 </span>              : 	} else { </span>
<span class="lineNum">   1445 </span><span class="lineNoCov">    0 / 2     : 		ch[channel].buf_len = ch[channel].buf[0]; </span>
<span class="lineNum">   1446 </span><span class="lineNoCov">    0 / 1     : 		ch[channel].buf_ptr = ch[channel].buf + 1; </span>
<span class="lineNum">   1447 </span>              : 	} </span>
<span class="lineNum">   1448 </span><span class="lineNoCov">    0 / 5     : } </span>
<span class="lineNum">   1449 </span>              :  </span>
<span class="lineNum">   1450 </span>              : // BLOCK-WRITE:channel,0,track,sector </span>
<span class="lineNum">   1451 </span>              : void ImageDrive::block_write_cmd(int channel, int track, int sector, bool user_cmd) </span>
<span class="lineNum">   1452 </span><span class="lineNoCov">    0 / 3     : { </span>
<span class="lineNum">   1453 </span><span class="lineNoCov">    0 / 2     : 	if (write_protected) { </span>
<span class="lineNum">   1454 </span><span class="lineNoCov">    0 / 1     : 		set_error(ERR_WRITEPROTECT); </span>
<span class="lineNum">   1455 </span>              : 		return; </span>
<span class="lineNum">   1456 </span>              : 	} </span>
<span class="lineNum">   1457 </span><span class="lineNoCov">    0 / 1     : 	if (channel &gt;= 16 || ch[channel].mode != CHMOD_DIRECT) { </span>
<span class="lineNum">   1458 </span><span class="lineNoCov">    0 / 2     : 		set_error(ERR_NOCHANNEL); </span>
<span class="lineNum">   1459 </span>              : 		return; </span>
<span class="lineNum">   1460 </span>              : 	} </span>
<span class="lineNum">   1461 </span><span class="lineNoCov">    0 / 1     : 	if (!user_cmd) </span>
<span class="lineNum">   1462 </span><span class="lineNoCov">    0 / 1     : 		ch[channel].buf[0] = ch[channel].buf_len ? ch[channel].buf_len - 1 : 1; </span>
<span class="lineNum">   1463 </span><span class="lineNoCov">    0 / 1     : 	if (!write_sector(track, sector, ch[channel].buf)) </span>
<span class="lineNum">   1464 </span>              : 		return; </span>
<span class="lineNum">   1465 </span><span class="lineNoCov">    0 / 1     : 	if (!user_cmd) { </span>
<span class="lineNum">   1466 </span><span class="lineNoCov">    0 / 1     : 		ch[channel].buf_len = 1; </span>
<span class="lineNum">   1467 </span><span class="lineNoCov">    0 / 2     : 		ch[channel].buf_ptr = ch[channel].buf + 1; </span>
<span class="lineNum">   1468 </span>              : 	} </span>
<span class="lineNum">   1469 </span><span class="lineNoCov">    0 / 2     : } </span>
<span class="lineNum">   1470 </span>              :  </span>
<span class="lineNum">   1471 </span>              : // BLOCK-ALLOCATE:0,track,sector </span>
<span class="lineNum">   1472 </span>              : void ImageDrive::block_allocate_cmd(int track, int sector) </span>
<span class="lineNum">   1473 </span><span class="lineNoCov">    0 / 2     : { </span>
<span class="lineNum">   1474 </span><span class="lineNoCov">    0 / 1     : 	int err = alloc_block(track, sector); </span>
<span class="lineNum">   1475 </span><span class="lineNoCov">    0 / 1     : 	if (err) { </span>
<span class="lineNum">   1476 </span><span class="lineNoCov">    0 / 1     : 		if (err == ERR_NOBLOCK) { </span>
<span class="lineNum">   1477 </span>              : 			// Find next free block and return its track/sector address in the </span>
<span class="lineNum">   1478 </span>              : 			// error message (only look on higher tracks) </span>
<span class="lineNum">   1479 </span>              : 			for (;;) { </span>
<span class="lineNum">   1480 </span><span class="lineNoCov">    0 / 1     : 				sector++; </span>
<span class="lineNum">   1481 </span><span class="lineNoCov">    0 / 1     : 				if (sector &gt;= num_sectors[track]) { </span>
<span class="lineNum">   1482 </span><span class="lineNoCov">    0 / 1     : 					track++; </span>
<span class="lineNum">   1483 </span>              : 					sector = 0; </span>
<span class="lineNum">   1484 </span><span class="lineNoCov">    0 / 1     : 					if (track &gt; 35) { </span>
<span class="lineNum">   1485 </span><span class="lineNoCov">    0 / 1     : 						set_error(ERR_NOBLOCK, 0, 0); </span>
<span class="lineNum">   1486 </span><span class="lineNoCov">    0 / 2     : 						return; </span>
<span class="lineNum">   1487 </span>              : 					} </span>
<span class="lineNum">   1488 </span>              : 				} </span>
<span class="lineNum">   1489 </span><span class="lineNoCov">    0 / 1     : 				if (is_block_free(track, sector)) { </span>
<span class="lineNum">   1490 </span><span class="lineNoCov">    0 / 1     : 					set_error(ERR_NOBLOCK, track, sector); </span>
<span class="lineNum">   1491 </span><span class="lineNoCov">    0 / 1     : 					return; </span>
<span class="lineNum">   1492 </span>              : 				} </span>
<span class="lineNum">   1493 </span>              : 			} </span>
<span class="lineNum">   1494 </span>              : 		} else </span>
<span class="lineNum">   1495 </span><span class="lineNoCov">    0 / 1     : 			set_error(err, track, sector); </span>
<span class="lineNum">   1496 </span>              : 	} </span>
<span class="lineNum">   1497 </span><span class="lineNoCov">    0 / 1     : } </span>
<span class="lineNum">   1498 </span>              :  </span>
<span class="lineNum">   1499 </span>              : // BLOCK-FREE:0,track,sector </span>
<span class="lineNum">   1500 </span>              : void ImageDrive::block_free_cmd(int track, int sector) </span>
<span class="lineNum">   1501 </span><span class="lineNoCov">    0 / 2     : { </span>
<span class="lineNum">   1502 </span><span class="lineNoCov">    0 / 1     : 	int err = free_block(track, sector); </span>
<span class="lineNum">   1503 </span><span class="lineNoCov">    0 / 1     : 	if (err) </span>
<span class="lineNum">   1504 </span><span class="lineNoCov">    0 / 1     : 		set_error(err, track, sector); </span>
<span class="lineNum">   1505 </span><span class="lineNoCov">    0 / 1     : } </span>
<span class="lineNum">   1506 </span>              :  </span>
<span class="lineNum">   1507 </span>              : // BUFFER-POINTER:channel,pos </span>
<span class="lineNum">   1508 </span>              : void ImageDrive::buffer_pointer_cmd(int channel, int pos) </span>
<span class="lineNum">   1509 </span><span class="lineNoCov">    0 / 2     : { </span>
<span class="lineNum">   1510 </span><span class="lineNoCov">    0 / 1     : 	if (channel &gt;= 16 || ch[channel].mode != CHMOD_DIRECT) { </span>
<span class="lineNum">   1511 </span><span class="lineNoCov">    0 / 1     : 		set_error(ERR_NOCHANNEL); </span>
<span class="lineNum">   1512 </span>              : 		return; </span>
<span class="lineNum">   1513 </span>              : 	} </span>
<span class="lineNum">   1514 </span><span class="lineNoCov">    0 / 1     : 	ch[channel].buf_ptr = ch[channel].buf + pos; </span>
<span class="lineNum">   1515 </span><span class="lineNoCov">    0 / 1     : 	ch[channel].buf_len = 256 - pos; </span>
<span class="lineNum">   1516 </span><span class="lineNoCov">    0 / 2     : } </span>
<span class="lineNum">   1517 </span>              :  </span>
<span class="lineNum">   1518 </span>              : // M-R&lt;adr low&gt;&lt;adr high&gt;[&lt;number&gt;] </span>
<span class="lineNum">   1519 </span>              : void ImageDrive::mem_read_cmd(uint16 adr, uint8 len) </span>
<span class="lineNum">   1520 </span><span class="lineNoCov">    0 / 2     : { </span>
<span class="lineNum">   1521 </span><span class="lineNoCov">    0 / 2     : 	error_len = len; </span>
<span class="lineNum">   1522 </span><span class="lineNoCov">    0 / 2     : 	if (adr &gt;= 0x300 &amp;&amp; adr &lt; 0x1000) { </span>
<span class="lineNum">   1523 </span>              : 		// Read from RAM </span>
<span class="lineNum">   1524 </span><span class="lineNoCov">    0 / 1     : 		error_ptr = (char *)ram + (adr &amp; 0x7ff); </span>
<span class="lineNum">   1525 </span><span class="lineNoCov">    0 / 1     : 	} else if (adr &gt;= 0xc000) { </span>
<span class="lineNum">   1526 </span>              : 		// Read from ROM </span>
<span class="lineNum">   1527 </span><span class="lineNoCov">    0 / 1     : 		error_ptr = (char *)(TheC64-&gt;ROM1541) + (adr - 0xc000); </span>
<span class="lineNum">   1528 </span>              : 	} else { </span>
<span class="lineNum">   1529 </span><span class="lineNoCov">    0 / 1     : 		unsupp_cmd(); </span>
<span class="lineNum">   1530 </span><span class="lineNoCov">    0 / 1     : 		memset(error_buf, 0, len); </span>
<span class="lineNum">   1531 </span><span class="lineNoCov">    0 / 1     : 		error_ptr = error_buf; </span>
<span class="lineNum">   1532 </span>              : 	} </span>
<span class="lineNum">   1533 </span><span class="lineNoCov">    0 / 1     : } </span>
<span class="lineNum">   1534 </span>              :  </span>
<span class="lineNum">   1535 </span>              : // M-W&lt;adr low&gt;&lt;adr high&gt;&lt;number&gt;&lt;data...&gt; </span>
<span class="lineNum">   1536 </span>              : void ImageDrive::mem_write_cmd(uint16 adr, uint8 len, uint8 *p) </span>
<span class="lineNum">   1537 </span><span class="lineNoCov">    0 / 2     : { </span>
<span class="lineNum">   1538 </span><span class="lineNoCov">    0 / 2     : 	while (len) { </span>
<span class="lineNum">   1539 </span><span class="lineNoCov">    0 / 1     : 		if (adr &gt;= 0x300 &amp;&amp; adr &lt; 0x1000) { </span>
<span class="lineNum">   1540 </span>              : 			// Write to RAM </span>
<span class="lineNum">   1541 </span><span class="lineNoCov">    0 / 1     : 			ram[adr &amp; 0x7ff] = *p; </span>
<span class="lineNum">   1542 </span><span class="lineNoCov">    0 / 1     : 		} else if (adr &lt; 0xc000) { </span>
<span class="lineNum">   1543 </span><span class="lineNoCov">    0 / 2     : 			unsupp_cmd(); </span>
<span class="lineNum">   1544 </span>              : 			return; </span>
<span class="lineNum">   1545 </span>              : 		} </span>
<span class="lineNum">   1546 </span><span class="lineNoCov">    0 / 1     : 		len--; adr++; p++; </span>
<span class="lineNum">   1547 </span>              : 	} </span>
<span class="lineNum">   1548 </span><span class="lineNoCov">    0 / 2     : } </span>
<span class="lineNum">   1549 </span>              :  </span>
<span class="lineNum">   1550 </span>              : //   COPY:new=file1,file2,... </span>
<span class="lineNum">   1551 </span>              : //        ^   ^ </span>
<span class="lineNum">   1552 </span>              : // new_file   old_files </span>
<span class="lineNum">   1553 </span>              : void ImageDrive::copy_cmd(const uint8 *new_file, int new_file_len, const uint8 *old_files, int old_files_len) </span>
<span class="lineNum">   1554 </span><span class="lineNoCov">    0 / 3     : { </span>
<span class="lineNum">   1555 </span>              : 	// Check if destination file is already present </span>
<span class="lineNum">   1556 </span>              : 	int dir_track, dir_sector, entry; </span>
<span class="lineNum">   1557 </span><span class="lineNoCov">    0 / 2     : 	if (find_first_file(new_file, new_file_len, dir_track, dir_sector, entry)) { </span>
<span class="lineNum">   1558 </span><span class="lineNoCov">    0 / 1     : 		set_error(ERR_FILEEXISTS); </span>
<span class="lineNum">   1559 </span>              : 		return; </span>
<span class="lineNum">   1560 </span>              : 	} </span>
<span class="lineNum">   1561 </span>              :  </span>
<span class="lineNum">   1562 </span>              : 	// Loop for all source files </span>
<span class="lineNum">   1563 </span>              : 	bool first = true; </span>
<span class="lineNum">   1564 </span><span class="lineNoCov">    0 / 2     : 	while (old_files_len &gt; 0) { </span>
<span class="lineNum">   1565 </span>              : 		uint8 *comma = (uint8 *)memchr(old_files, ',', old_files_len); </span>
<span class="lineNum">   1566 </span><span class="lineNoCov">    0 / 2     : 		int name_len = comma ? comma - old_files : old_files_len; </span>
<span class="lineNum">   1567 </span>              :  </span>
<span class="lineNum">   1568 </span>              : 		// Check if source file is present </span>
<span class="lineNum">   1569 </span><span class="lineNoCov">    0 / 1     : 		if (!find_first_file(old_files, name_len, dir_track, dir_sector, entry)) { </span>
<span class="lineNum">   1570 </span><span class="lineNoCov">    0 / 1     : 			set_error(ERR_FILENOTFOUND); </span>
<span class="lineNum">   1571 </span><span class="lineNoCov">    0 / 1     : 			Close(17); </span>
<span class="lineNum">   1572 </span>              : 			return; </span>
<span class="lineNum">   1573 </span>              : 		} </span>
<span class="lineNum">   1574 </span><span class="lineNoCov">    0 / 3     : 		uint8 *de = dir + DIR_ENTRIES + entry * SIZEOF_DE; </span>
<span class="lineNum">   1575 </span><span class="lineNoCov">    0 / 1     : 		uint8 type = de[DE_TYPE] &amp; 7, track = de[DE_TRACK], sector = de[DE_SECTOR]; </span>
<span class="lineNum">   1576 </span>              :  </span>
<span class="lineNum">   1577 </span>              : 		// If this is the first source file, open internal write channel for destination file </span>
<span class="lineNum">   1578 </span><span class="lineNoCov">    0 / 2     : 		if (first) { </span>
<span class="lineNum">   1579 </span><span class="lineNoCov">    0 / 1     : 			create_file(17, new_file, new_file_len, type, false); </span>
<span class="lineNum">   1580 </span><span class="lineNoCov">    0 / 1     : 			if (ch[17].mode == CHMOD_FREE) </span>
<span class="lineNum">   1581 </span>              : 				return; </span>
<span class="lineNum">   1582 </span>              : 			first = false; </span>
<span class="lineNum">   1583 </span>              : 		} </span>
<span class="lineNum">   1584 </span>              :  </span>
<span class="lineNum">   1585 </span>              : 		// Open internal read channel for source file </span>
<span class="lineNum">   1586 </span><span class="lineNoCov">    0 / 1     : 		open_file_ts(16, track, sector); </span>
<span class="lineNum">   1587 </span><span class="lineNoCov">    0 / 1     : 		if (ch[16].mode == CHMOD_FREE) { </span>
<span class="lineNum">   1588 </span>              : 			Close(17); </span>
<span class="lineNum">   1589 </span>              : 			return; </span>
<span class="lineNum">   1590 </span>              : 		} </span>
<span class="lineNum">   1591 </span>              :  </span>
<span class="lineNum">   1592 </span>              : 		// Copy file </span>
<span class="lineNum">   1593 </span>              : 		uint8 byte, st; </span>
<span class="lineNum">   1594 </span><span class="lineNoCov">    0 / 1     : 		do { </span>
<span class="lineNum">   1595 </span><span class="lineNoCov">    0 / 1     : 			st = Read(16, byte); </span>
<span class="lineNum">   1596 </span><span class="lineNoCov">    0 / 1     : 			Write(17, byte, false); </span>
<span class="lineNum">   1597 </span>              : 		} while (st == ST_OK); </span>
<span class="lineNum">   1598 </span><span class="lineNoCov">    0 / 1     : 		Close(16); </span>
<span class="lineNum">   1599 </span><span class="lineNoCov">    0 / 1     : 		if (st != ST_EOF) { </span>
<span class="lineNum">   1600 </span>              : 			Close(17); </span>
<span class="lineNum">   1601 </span>              : 			return; </span>
<span class="lineNum">   1602 </span>              : 		} </span>
<span class="lineNum">   1603 </span>              :  </span>
<span class="lineNum">   1604 </span><span class="lineNoCov">    0 / 1     : 		if (comma) { </span>
<span class="lineNum">   1605 </span><span class="lineNoCov">    0 / 1     : 			old_files_len -= name_len + 1; </span>
<span class="lineNum">   1606 </span><span class="lineNoCov">    0 / 1     : 			old_files = comma + 1; </span>
<span class="lineNum">   1607 </span>              : 		} else </span>
<span class="lineNum">   1608 </span>              : 			old_files_len = 0; </span>
<span class="lineNum">   1609 </span>              : 	} </span>
<span class="lineNum">   1610 </span><span class="lineNoCov">    0 / 1     : 	Close(17); </span>
<span class="lineNum">   1611 </span><span class="lineNoCov">    0 / 3     : } </span>
<span class="lineNum">   1612 </span>              :  </span>
<span class="lineNum">   1613 </span>              : // RENAME:new=old </span>
<span class="lineNum">   1614 </span>              : //        ^   ^ </span>
<span class="lineNum">   1615 </span>              : // new_file   old_file </span>
<span class="lineNum">   1616 </span>              : void ImageDrive::rename_cmd(const uint8 *new_file, int new_file_len, const uint8 *old_file, int old_file_len) </span>
<span class="lineNum">   1617 </span><span class="lineNoCov">    0 / 3     : { </span>
<span class="lineNum">   1618 </span>              : 	// Check if destination file is already present </span>
<span class="lineNum">   1619 </span>              : 	int dir_track, dir_sector, entry; </span>
<span class="lineNum">   1620 </span><span class="lineNoCov">    0 / 3     : 	if (find_first_file(new_file, new_file_len, dir_track, dir_sector, entry)) { </span>
<span class="lineNum">   1621 </span><span class="lineNoCov">    0 / 1     : 		set_error(ERR_FILEEXISTS); </span>
<span class="lineNum">   1622 </span><span class="lineNoCov">    0 / 1     : 		return; </span>
<span class="lineNum">   1623 </span>              : 	} </span>
<span class="lineNum">   1624 </span>              :  </span>
<span class="lineNum">   1625 </span>              : 	// Check if source file is present </span>
<span class="lineNum">   1626 </span><span class="lineNoCov">    0 / 1     : 	if (!find_first_file(old_file, old_file_len, dir_track, dir_sector, entry)) { </span>
<span class="lineNum">   1627 </span><span class="lineNoCov">    0 / 1     : 		set_error(ERR_FILENOTFOUND); </span>
<span class="lineNum">   1628 </span><span class="lineNoCov">    0 / 1     : 		return; </span>
<span class="lineNum">   1629 </span>              : 	} </span>
<span class="lineNum">   1630 </span>              :  </span>
<span class="lineNum">   1631 </span>              : 	// Check for write-protection </span>
<span class="lineNum">   1632 </span><span class="lineNoCov">    0 / 1     : 	if (write_protected) { </span>
<span class="lineNum">   1633 </span><span class="lineNoCov">    0 / 1     : 		set_error(ERR_WRITEPROTECT); </span>
<span class="lineNum">   1634 </span><span class="lineNoCov">    0 / 1     : 		return; </span>
<span class="lineNum">   1635 </span>              : 	} </span>
<span class="lineNum">   1636 </span>              :  </span>
<span class="lineNum">   1637 </span>              : 	// Rename file in directory entry </span>
<span class="lineNum">   1638 </span><span class="lineNoCov">    0 / 1     : 	uint8 *p = dir + DIR_ENTRIES + entry * SIZEOF_DE; </span>
<span class="lineNum">   1639 </span><span class="lineNoCov">    0 / 2     : 	memset(p + DE_NAME, 0xa0, 16); </span>
<span class="lineNum">   1640 </span>              : 	memcpy(p + DE_NAME, new_file, new_file_len); </span>
<span class="lineNum">   1641 </span><span class="lineNoCov">    0 / 1     : 	write_sector(dir_track, dir_sector, dir); </span>
<span class="lineNum">   1642 </span><span class="lineNoCov">    0 / 1     : } </span>
<span class="lineNum">   1643 </span>              :  </span>
<span class="lineNum">   1644 </span>              : // SCRATCH:file1,file2,... </span>
<span class="lineNum">   1645 </span>              : //         ^ </span>
<span class="lineNum">   1646 </span>              : //         files </span>
<span class="lineNum">   1647 </span>              : void ImageDrive::scratch_cmd(const uint8 *files, int files_len) </span>
<span class="lineNum">   1648 </span><span class="lineNoCov">    0 / 2     : { </span>
<span class="lineNum">   1649 </span>              : 	// Check for write-protection </span>
<span class="lineNum">   1650 </span><span class="lineNoCov">    0 / 1     : 	if (write_protected) { </span>
<span class="lineNum">   1651 </span><span class="lineNoCov">    0 / 1     : 		set_error(ERR_WRITEPROTECT); </span>
<span class="lineNum">   1652 </span>              : 		return; </span>
<span class="lineNum">   1653 </span>              : 	} </span>
<span class="lineNum">   1654 </span>              :  </span>
<span class="lineNum">   1655 </span>              : 	// Loop for all files </span>
<span class="lineNum">   1656 </span>              : 	int num_files = 0; </span>
<span class="lineNum">   1657 </span><span class="lineNoCov">    0 / 2     : 	while (files_len &gt; 0) { </span>
<span class="lineNum">   1658 </span>              : 		uint8 *comma = (uint8 *)memchr(files, ',', files_len); </span>
<span class="lineNum">   1659 </span><span class="lineNoCov">    0 / 1     : 		int name_len = comma ? comma - files : files_len; </span>
<span class="lineNum">   1660 </span>              :  </span>
<span class="lineNum">   1661 </span>              : 		int dir_track, dir_sector, entry; </span>
<span class="lineNum">   1662 </span><span class="lineNoCov">    0 / 1     : 		if (find_first_file(files, name_len, dir_track, dir_sector, entry)) { </span>
<span class="lineNum">   1663 </span><span class="lineNoCov">    0 / 1     : 			do { </span>
<span class="lineNum">   1664 </span><span class="lineNoCov">    0 / 2     : 				uint8 *de = dir + DIR_ENTRIES + entry * SIZEOF_DE; </span>
<span class="lineNum">   1665 </span>              :  </span>
<span class="lineNum">   1666 </span>              : 				// File protected? Then skip </span>
<span class="lineNum">   1667 </span><span class="lineNoCov">    0 / 1     : 				if (de[DE_TYPE] &amp; 0x40) </span>
<span class="lineNum">   1668 </span>              : 					continue; </span>
<span class="lineNum">   1669 </span>              :  </span>
<span class="lineNum">   1670 </span>              : 				// Free allocated data blocks and side sectors </span>
<span class="lineNum">   1671 </span><span class="lineNoCov">    0 / 1     : 				free_block_chain(de[DE_TRACK], de[DE_SECTOR]); </span>
<span class="lineNum">   1672 </span><span class="lineNoCov">    0 / 1     : 				free_block_chain(de[DE_SIDE_TRACK], de[DE_SIDE_SECTOR]); </span>
<span class="lineNum">   1673 </span>              :  </span>
<span class="lineNum">   1674 </span>              : 				// Clear file type </span>
<span class="lineNum">   1675 </span><span class="lineNoCov">    0 / 1     : 				de[DE_TYPE] = 0; </span>
<span class="lineNum">   1676 </span>              :  </span>
<span class="lineNum">   1677 </span>              : 				// Write directory block back </span>
<span class="lineNum">   1678 </span><span class="lineNoCov">    0 / 1     : 				write_sector(dir_track, dir_sector, dir); </span>
<span class="lineNum">   1679 </span><span class="lineNoCov">    0 / 1     : 				num_files++; </span>
<span class="lineNum">   1680 </span>              : 			} while (find_next_file(files, name_len, dir_track, dir_sector, entry)); </span>
<span class="lineNum">   1681 </span>              : 		} </span>
<span class="lineNum">   1682 </span>              :  </span>
<span class="lineNum">   1683 </span><span class="lineNoCov">    0 / 1     : 		if (comma) { </span>
<span class="lineNum">   1684 </span><span class="lineNoCov">    0 / 1     : 			files_len -= name_len + 1; </span>
<span class="lineNum">   1685 </span><span class="lineNoCov">    0 / 1     : 			files = comma + 1; </span>
<span class="lineNum">   1686 </span>              : 		} else </span>
<span class="lineNum">   1687 </span>              : 			files_len = 0; </span>
<span class="lineNum">   1688 </span>              : 	} </span>
<span class="lineNum">   1689 </span>              :  </span>
<span class="lineNum">   1690 </span>              : 	// Report number of files scratched </span>
<span class="lineNum">   1691 </span><span class="lineNoCov">    0 / 1     : 	set_error(ERR_SCRATCHED, num_files); </span>
<span class="lineNum">   1692 </span><span class="lineNoCov">    0 / 2     : } </span>
<span class="lineNum">   1693 </span>              :  </span>
<span class="lineNum">   1694 </span>              : // INITIALIZE </span>
<span class="lineNum">   1695 </span>              : void ImageDrive::initialize_cmd(void) </span>
<span class="lineNum">   1696 </span><span class="lineNoCov">    0 / 2     : { </span>
<span class="lineNum">   1697 </span>              : 	// Close all channels and re-read BAM </span>
<span class="lineNum">   1698 </span><span class="lineNoCov">    0 / 1     : 	close_all_channels(); </span>
<span class="lineNum">   1699 </span><span class="lineNoCov">    0 / 1     : 	if (bam_dirty) { </span>
<span class="lineNum">   1700 </span><span class="lineNoCov">    0 / 1     : 		write_sector(DIR_TRACK, 0, bam); </span>
<span class="lineNum">   1701 </span><span class="lineNoCov">    0 / 1     : 		bam_dirty = false; </span>
<span class="lineNum">   1702 </span>              : 	} </span>
<span class="lineNum">   1703 </span><span class="lineNoCov">    0 / 1     : 	read_sector(DIR_TRACK, 0, bam); </span>
<span class="lineNum">   1704 </span><span class="lineNoCov">    0 / 1     : } </span>
<span class="lineNum">   1705 </span>              :  </span>
<span class="lineNum">   1706 </span>              : // NEW:name,id </span>
<span class="lineNum">   1707 </span>              : //     ^   ^ </span>
<span class="lineNum">   1708 </span>              : //  name   comma (or NULL) </span>
<span class="lineNum">   1709 </span>              : void ImageDrive::new_cmd(const uint8 *name, int name_len, const uint8 *comma) </span>
<span class="lineNum">   1710 </span><span class="lineNoCov">    0 / 3     : { </span>
<span class="lineNum">   1711 </span>              : 	// Check for write-protection </span>
<span class="lineNum">   1712 </span><span class="lineNoCov">    0 / 2     : 	if (write_protected) { </span>
<span class="lineNum">   1713 </span><span class="lineNoCov">    0 / 2     : 		set_error(ERR_WRITEPROTECT); </span>
<span class="lineNum">   1714 </span>              : 		return; </span>
<span class="lineNum">   1715 </span>              : 	} </span>
<span class="lineNum">   1716 </span>              :  </span>
<span class="lineNum">   1717 </span>              : 	// Remember current ID </span>
<span class="lineNum">   1718 </span><span class="lineNoCov">    0 / 2     : 	uint8 id1 = bam[BAM_DISK_ID], id2 = bam[BAM_DISK_ID + 1]; </span>
<span class="lineNum">   1719 </span>              :  </span>
<span class="lineNum">   1720 </span>              : 	// Formatting with ID? </span>
<span class="lineNum">   1721 </span><span class="lineNoCov">    0 / 2     : 	if (comma) { </span>
<span class="lineNum">   1722 </span>              :  </span>
<span class="lineNum">   1723 </span><span class="lineNoCov">    0 / 1     : 		close_all_channels(); </span>
<span class="lineNum">   1724 </span>              :  </span>
<span class="lineNum">   1725 </span>              : 		// Clear BAM buffer </span>
<span class="lineNum">   1726 </span>              : 		memset(bam, 0, 256); </span>
<span class="lineNum">   1727 </span>              :  </span>
<span class="lineNum">   1728 </span>              : 		// Get ID from command </span>
<span class="lineNum">   1729 </span><span class="lineNoCov">    0 / 1     : 		if (comma[1]) { </span>
<span class="lineNum">   1730 </span>              : 			id1 = comma[1]; </span>
<span class="lineNum">   1731 </span><span class="lineNoCov">    0 / 2     : 			id2 = comma[2] ? comma[2] : ' '; </span>
<span class="lineNum">   1732 </span>              : 		} else { </span>
<span class="lineNum">   1733 </span>              : 			id1 = id2 = ' '; </span>
<span class="lineNum">   1734 </span>              : 		} </span>
<span class="lineNum">   1735 </span>              : 	} </span>
<span class="lineNum">   1736 </span>              :  </span>
<span class="lineNum">   1737 </span>              : 	// Format disk image </span>
<span class="lineNum">   1738 </span><span class="lineNoCov">    0 / 1     : 	format_image(the_file, desc, comma, id1, id2, name, name_len); </span>
<span class="lineNum">   1739 </span>              :  </span>
<span class="lineNum">   1740 </span>              : 	// Re-read BAM </span>
<span class="lineNum">   1741 </span><span class="lineNoCov">    0 / 1     : 	read_sector(DIR_TRACK, 0, bam); </span>
<span class="lineNum">   1742 </span><span class="lineNoCov">    0 / 1     : 	bam_dirty = false; </span>
<span class="lineNum">   1743 </span><span class="lineNoCov">    0 / 2     : } </span>
<span class="lineNum">   1744 </span>              :  </span>
<span class="lineNum">   1745 </span>              : // VALIDATE </span>
<span class="lineNum">   1746 </span><span class="lineNoCov">    0 / 2     : void ImageDrive::validate_cmd(void) </span>
<span class="lineNum">   1747 </span><span class="lineNoCov">    0 / 4     : { </span>
<span class="lineNum">   1748 </span>              : 	// Backup of old BAM in case something goes amiss </span>
<span class="lineNum">   1749 </span>              : 	uint8 old_bam[256]; </span>
<span class="lineNum">   1750 </span>              : 	memcpy(old_bam, bam, 256); </span>
<span class="lineNum">   1751 </span>              :  </span>
<span class="lineNum">   1752 </span>              : 	// Clear BAM </span>
<span class="lineNum">   1753 </span><span class="lineNoCov">    0 / 1     : 	clear_bam(bam); </span>
<span class="lineNum">   1754 </span><span class="lineNoCov">    0 / 1     : 	bam_dirty = true; </span>
<span class="lineNum">   1755 </span>              :  </span>
<span class="lineNum">   1756 </span>              : 	// Allocate BAM and directory </span>
<span class="lineNum">   1757 </span><span class="lineNoCov">    0 / 1     : 	if (!alloc_block_chain(DIR_TRACK, 0)) { </span>
<span class="lineNum">   1758 </span>              : 		memcpy(bam, old_bam, 256); </span>
<span class="lineNum">   1759 </span>              : 		return; </span>
<span class="lineNum">   1760 </span>              : 	} </span>
<span class="lineNum">   1761 </span>              :  </span>
<span class="lineNum">   1762 </span>              : 	// Allocate all file data and side sector blocks </span>
<span class="lineNum">   1763 </span>              : 	int dir_track, dir_sector, entry; </span>
<span class="lineNum">   1764 </span><span class="lineNoCov">    0 / 1     : 	if (find_first_file((uint8 *)&quot;*&quot;, 1, dir_track, dir_sector, entry)) { </span>
<span class="lineNum">   1765 </span><span class="lineNoCov">    0 / 1     : 		do { </span>
<span class="lineNum">   1766 </span><span class="lineNoCov">    0 / 2     : 			uint8 *de = dir + DIR_ENTRIES + entry * SIZEOF_DE; </span>
<span class="lineNum">   1767 </span>              :  </span>
<span class="lineNum">   1768 </span><span class="lineNoCov">    0 / 1     : 			if (de[DE_TYPE] &amp; 0x80) { </span>
<span class="lineNum">   1769 </span>              : 				// Closed file, allocate all file data and side sector blocks </span>
<span class="lineNum">   1770 </span><span class="lineNoCov">    0 / 2     : 				if (!alloc_block_chain(de[DE_TRACK], de[DE_SECTOR]) || !alloc_block_chain(de[DE_SIDE_TRACK], de[DE_SIDE_SECTOR])) { </span>
<span class="lineNum">   1771 </span>              : 					memcpy(bam, old_bam, 256); </span>
<span class="lineNum">   1772 </span>              : 					return; </span>
<span class="lineNum">   1773 </span>              : 				} </span>
<span class="lineNum">   1774 </span>              : 			} else { </span>
<span class="lineNum">   1775 </span>              : 				// Open file, delete it </span>
<span class="lineNum">   1776 </span><span class="lineNoCov">    0 / 1     : 				de[DE_TYPE] = 0; </span>
<span class="lineNum">   1777 </span><span class="lineNoCov">    0 / 1     : 				write_sector(dir_track, dir_sector, dir); </span>
<span class="lineNum">   1778 </span>              : 			} </span>
<span class="lineNum">   1779 </span>              : 		} while (find_next_file((uint8 *)&quot;*&quot;, 1, dir_track, dir_sector, entry)); </span>
<span class="lineNum">   1780 </span>              : 	} </span>
<span class="lineNum">   1781 </span><span class="lineNoCov">    0 / 2     : } </span>
<span class="lineNum">   1782 </span>              :  </span>
<span class="lineNum">   1783 </span>              :  </span>
<span class="lineNum">   1784 </span>              : /* </span>
<span class="lineNum">   1785 </span>              :  *  Check whether file with given header (64 bytes) and size looks like one </span>
<span class="lineNum">   1786 </span>              :  *  of the file types supported by this module </span>
<span class="lineNum">   1787 </span>              :  */ </span>
<span class="lineNum">   1788 </span>              :  </span>
<span class="lineNum">   1789 </span>              : static bool is_d64_file(const uint8 *header, long size) </span>
<span class="lineNum">   1790 </span>              : { </span>
<span class="lineNum">   1791 </span>              : 	return size == NUM_SECTORS_35 * 256 || size == NUM_SECTORS_35 * 257 </span>
<span class="lineNum">   1792 </span><span class="lineCov">    4 / 4     : 	    || size == NUM_SECTORS_40 * 256 || size == NUM_SECTORS_40 * 257; </span>
<span class="lineNum">   1793 </span>              : } </span>
<span class="lineNum">   1794 </span>              :  </span>
<span class="lineNum">   1795 </span>              : static bool is_ed64_file(const uint8 *header, long size) </span>
<span class="lineNum">   1796 </span>              : { </span>
<span class="lineNum">   1797 </span>              : 	// 35-track d64 file with header ID at the end (only used internally for </span>
<span class="lineNum">   1798 </span>              : 	// converted zipcode files) </span>
<span class="lineNum">   1799 </span>              : 	return size == NUM_SECTORS_35 * 256 + 2; </span>
<span class="lineNum">   1800 </span>              : } </span>
<span class="lineNum">   1801 </span>              :  </span>
<span class="lineNum">   1802 </span>              : static bool is_x64_file(const uint8 *header, long size) </span>
<span class="lineNum">   1803 </span>              : { </span>
<span class="lineNum">   1804 </span><span class="lineCov">    3 / 3     : 	return memcmp(header, &quot;C\x15\x41\x64\x01\x02&quot;, 6) == 0; </span>
<span class="lineNum">   1805 </span>              : } </span>
<span class="lineNum">   1806 </span>              :  </span>
<span class="lineNum">   1807 </span>              : static bool is_zipcode_file(const char *path) </span>
<span class="lineNum">   1808 </span>              : { </span>
<span class="lineNum">   1809 </span>              : #if 0 </span>
<span class="lineNum">   1810 </span>              : 	string base, part; </span>
<span class="lineNum">   1811 </span>              : 	SplitPath(path, base, part); </span>
<span class="lineNum">   1812 </span>              : 	return part.length() &gt; 2 &amp;&amp; part[0] &gt;= '1' &amp;&amp; part[0] &lt;= '4' &amp;&amp; part[1] == '!'; </span>
<span class="lineNum">   1813 </span>              : #else </span>
<span class="lineNum">   1814 </span>              : 	return false; </span>
<span class="lineNum">   1815 </span>              : #endif </span>
<span class="lineNum">   1816 </span>              : } </span>
<span class="lineNum">   1817 </span>              :  </span>
<span class="lineNum">   1818 </span><span class="lineCov">    2 / 2     : bool IsImageFile(const char *path, const uint8 *header, long size) </span>
<span class="lineNum">   1819 </span><span class="lineCov">    2 / 2     : { </span>
<span class="lineNum">   1820 </span>              : 	return is_d64_file(header, size) || is_x64_file(header, size) || is_zipcode_file(path); </span>
<span class="lineNum">   1821 </span><span class="lineCov">    3 / 3     : } </span>
<span class="lineNum">   1822 </span>              :  </span>
<span class="lineNum">   1823 </span>              :  </span>
<span class="lineNum">   1824 </span>              : #if 0 </span>
<span class="lineNum">   1825 </span>              : /* </span>
<span class="lineNum">   1826 </span>              :  *  Convert zipcode file to extended d64 file (d64 file with header ID) </span>
<span class="lineNum">   1827 </span>              :  */ </span>
<span class="lineNum">   1828 </span>              :  </span>
<span class="lineNum">   1829 </span>              : static FILE *open_zipcode_file(FILE *old, int num, const string &amp;base, string &amp;part, uint8 &amp;id1, uint8 &amp;id2) </span>
<span class="lineNum">   1830 </span>              : { </span>
<span class="lineNum">   1831 </span>              : 	if (old) </span>
<span class="lineNum">   1832 </span>              : 		fclose(old); </span>
<span class="lineNum">   1833 </span>              : 	part[0] = num + '1'; </span>
<span class="lineNum">   1834 </span>              : 	FILE *f = fopen(AddToPath(base, part).c_str(), &quot;rb&quot;); </span>
<span class="lineNum">   1835 </span>              : 	if (f == NULL) </span>
<span class="lineNum">   1836 </span>              : 		return NULL; </span>
<span class="lineNum">   1837 </span>              : 	if (fseek(f, 2, SEEK_SET) &lt; 0) { </span>
<span class="lineNum">   1838 </span>              : 		fclose(f); </span>
<span class="lineNum">   1839 </span>              : 		return NULL; </span>
<span class="lineNum">   1840 </span>              : 	} </span>
<span class="lineNum">   1841 </span>              : 	if (num == 0) { </span>
<span class="lineNum">   1842 </span>              : 		id1 = getc(f); </span>
<span class="lineNum">   1843 </span>              : 		id2 = getc(f); </span>
<span class="lineNum">   1844 </span>              : 	} </span>
<span class="lineNum">   1845 </span>              : 	return f; </span>
<span class="lineNum">   1846 </span>              : } </span>
<span class="lineNum">   1847 </span>              :  </span>
<span class="lineNum">   1848 </span>              : static FILE *convert_zipcode_to_ed64(const string &amp;path) </span>
<span class="lineNum">   1849 </span>              : { </span>
<span class="lineNum">   1850 </span>              : 	FILE *in = NULL, *out = NULL; </span>
<span class="lineNum">   1851 </span>              : 	uint8 id1, id2; </span>
<span class="lineNum">   1852 </span>              :  </span>
<span class="lineNum">   1853 </span>              : 	// Split input file name </span>
<span class="lineNum">   1854 </span>              : 	string base, part; </span>
<span class="lineNum">   1855 </span>              : 	SplitPath(path, base, part); </span>
<span class="lineNum">   1856 </span>              :  </span>
<span class="lineNum">   1857 </span>              : 	// Open output file </span>
<span class="lineNum">   1858 </span>              : 	out = tmpfile(); </span>
<span class="lineNum">   1859 </span>              : 	if (out == NULL) </span>
<span class="lineNum">   1860 </span>              : 		goto error; </span>
<span class="lineNum">   1861 </span>              :  </span>
<span class="lineNum">   1862 </span>              : 	// Decode all tracks </span>
<span class="lineNum">   1863 </span>              : 	for (int track=1; track&lt;=35; track++) { </span>
<span class="lineNum">   1864 </span>              : 		int max_sect = 17 + ((track &lt; 31) ? 1 : 0) + ((track &lt; 25) ? 1 : 0) + ((track &lt; 18) ? 2 : 0); </span>
<span class="lineNum">   1865 </span>              :  </span>
<span class="lineNum">   1866 </span>              : 		// Select appropriate input file </span>
<span class="lineNum">   1867 </span>              : 		switch (track) { </span>
<span class="lineNum">   1868 </span>              : 			case 1: </span>
<span class="lineNum">   1869 </span>              : 				if ((in = open_zipcode_file(NULL, 0, base, part, id1, id2)) == NULL) </span>
<span class="lineNum">   1870 </span>              : 					goto error; </span>
<span class="lineNum">   1871 </span>              : 				break; </span>
<span class="lineNum">   1872 </span>              : 			case 9: </span>
<span class="lineNum">   1873 </span>              : 				if ((in = open_zipcode_file(in, 1, base, part, id1, id2)) == NULL) </span>
<span class="lineNum">   1874 </span>              : 					goto error; </span>
<span class="lineNum">   1875 </span>              : 				break; </span>
<span class="lineNum">   1876 </span>              : 			case 17: </span>
<span class="lineNum">   1877 </span>              : 				if ((in = open_zipcode_file(in, 2, base, part, id1, id2)) == NULL) </span>
<span class="lineNum">   1878 </span>              : 					goto error; </span>
<span class="lineNum">   1879 </span>              : 				break; </span>
<span class="lineNum">   1880 </span>              : 			case 26: </span>
<span class="lineNum">   1881 </span>              : 				if ((in = open_zipcode_file(in, 3, base, part, id1, id2)) == NULL) </span>
<span class="lineNum">   1882 </span>              : 					goto error; </span>
<span class="lineNum">   1883 </span>              : 				break; </span>
<span class="lineNum">   1884 </span>              : 		} </span>
<span class="lineNum">   1885 </span>              :  </span>
<span class="lineNum">   1886 </span>              : 		// Clear &quot;sector read&quot; flags </span>
<span class="lineNum">   1887 </span>              : 		bool sect_flag[21]; </span>
<span class="lineNum">   1888 </span>              : 		for (int i=0; i&lt;max_sect; i++) </span>
<span class="lineNum">   1889 </span>              : 			sect_flag[i] = false; </span>
<span class="lineNum">   1890 </span>              :  </span>
<span class="lineNum">   1891 </span>              : 		// Read track </span>
<span class="lineNum">   1892 </span>              : 		uint8 act_track[21 * 256]; </span>
<span class="lineNum">   1893 </span>              : 		for (int i=0; i&lt;max_sect; i++) { </span>
<span class="lineNum">   1894 </span>              :  </span>
<span class="lineNum">   1895 </span>              : 			// Read and verify track/sector number </span>
<span class="lineNum">   1896 </span>              : 			uint8 t = getc(in); </span>
<span class="lineNum">   1897 </span>              : 			uint8 s = getc(in); </span>
<span class="lineNum">   1898 </span>              : 			if ((t &amp; 0x3f) != track || s &gt;= max_sect || sect_flag[s] || feof(in)) </span>
<span class="lineNum">   1899 </span>              : 				goto error; </span>
<span class="lineNum">   1900 </span>              : 			sect_flag[s] = true; </span>
<span class="lineNum">   1901 </span>              : 			uint8 *p = act_track + s * 256; </span>
<span class="lineNum">   1902 </span>              :  </span>
<span class="lineNum">   1903 </span>              : 			// Uncompress sector </span>
<span class="lineNum">   1904 </span>              : 			if (t &amp; 0x80) { </span>
<span class="lineNum">   1905 </span>              : 				// Run-length encoded sector </span>
<span class="lineNum">   1906 </span>              : 				uint8 len = getc(in); </span>
<span class="lineNum">   1907 </span>              : 				uint8 rep = getc(in); </span>
<span class="lineNum">   1908 </span>              : 				int count = 0; </span>
<span class="lineNum">   1909 </span>              : 				for (int j=0; j&lt;len; j++) { </span>
<span class="lineNum">   1910 </span>              : 					if (feof(in)) </span>
<span class="lineNum">   1911 </span>              : 						goto error; </span>
<span class="lineNum">   1912 </span>              : 					uint8 c = getc(in); </span>
<span class="lineNum">   1913 </span>              : 					if (c != rep) </span>
<span class="lineNum">   1914 </span>              : 						p[count++] = c; </span>
<span class="lineNum">   1915 </span>              : 					else { </span>
<span class="lineNum">   1916 </span>              : 						uint8 repnum = getc(in); </span>
<span class="lineNum">   1917 </span>              : 						if (feof(in)) </span>
<span class="lineNum">   1918 </span>              : 							goto error; </span>
<span class="lineNum">   1919 </span>              : 						c = getc(in); </span>
<span class="lineNum">   1920 </span>              : 						j += 2; </span>
<span class="lineNum">   1921 </span>              : 						for (int k=0; k&lt;repnum; k++) </span>
<span class="lineNum">   1922 </span>              : 							p[count++] = c; </span>
<span class="lineNum">   1923 </span>              : 					} </span>
<span class="lineNum">   1924 </span>              : 				} </span>
<span class="lineNum">   1925 </span>              : 			} else if (t &amp; 0x40) { </span>
<span class="lineNum">   1926 </span>              : 				// Sector filled with constant byte </span>
<span class="lineNum">   1927 </span>              : 				if (feof(in)) </span>
<span class="lineNum">   1928 </span>              : 					goto error; </span>
<span class="lineNum">   1929 </span>              : 				uint8 c = getc(in); </span>
<span class="lineNum">   1930 </span>              : 				memset(p, c, 256); </span>
<span class="lineNum">   1931 </span>              : 			} else { </span>
<span class="lineNum">   1932 </span>              : 				// Plain sector </span>
<span class="lineNum">   1933 </span>              : 				if (fread(p, 1, 256, in) != 256) </span>
<span class="lineNum">   1934 </span>              : 					goto error; </span>
<span class="lineNum">   1935 </span>              : 			} </span>
<span class="lineNum">   1936 </span>              : 		} </span>
<span class="lineNum">   1937 </span>              :  </span>
<span class="lineNum">   1938 </span>              : 		// Write track </span>
<span class="lineNum">   1939 </span>              : 		if (fwrite(act_track, 256, max_sect, out) != (size_t)max_sect) </span>
<span class="lineNum">   1940 </span>              : 			goto error; </span>
<span class="lineNum">   1941 </span>              : 	} </span>
<span class="lineNum">   1942 </span>              :  </span>
<span class="lineNum">   1943 </span>              : 	// Write header ID </span>
<span class="lineNum">   1944 </span>              : 	putc(id1, out); </span>
<span class="lineNum">   1945 </span>              : 	putc(id2, out); </span>
<span class="lineNum">   1946 </span>              :  </span>
<span class="lineNum">   1947 </span>              : 	// Done </span>
<span class="lineNum">   1948 </span>              : 	fclose(in); </span>
<span class="lineNum">   1949 </span>              : 	fseek(out, 0, SEEK_SET); </span>
<span class="lineNum">   1950 </span>              : 	return out; </span>
<span class="lineNum">   1951 </span>              :  </span>
<span class="lineNum">   1952 </span>              : error: </span>
<span class="lineNum">   1953 </span>              : 	if (in) </span>
<span class="lineNum">   1954 </span>              : 		fclose(in); </span>
<span class="lineNum">   1955 </span>              : 	if (out) </span>
<span class="lineNum">   1956 </span>              : 		fclose(out); </span>
<span class="lineNum">   1957 </span>              : 	return NULL; </span>
<span class="lineNum">   1958 </span>              : } </span>
<span class="lineNum">   1959 </span>              : #endif </span>
<span class="lineNum">   1960 </span>              :  </span>
<span class="lineNum">   1961 </span>              :  </span>
<span class="lineNum">   1962 </span>              : /* </span>
<span class="lineNum">   1963 </span>              :  *  Open disk image file, return file handle </span>
<span class="lineNum">   1964 </span>              :  */ </span>
<span class="lineNum">   1965 </span>              :  </span>
<span class="lineNum">   1966 </span>              : static FILE *open_image_file(const char *path, bool write_mode) </span>
<span class="lineNum">   1967 </span>              : { </span>
<span class="lineNum">   1968 </span>              : #if 0 </span>
<span class="lineNum">   1969 </span>              : 	if (is_zipcode_file(path)) { </span>
<span class="lineNum">   1970 </span>              : 		if (write_mode) </span>
<span class="lineNum">   1971 </span>              : 			return NULL; </span>
<span class="lineNum">   1972 </span>              : 		else </span>
<span class="lineNum">   1973 </span>              : 			return convert_zipcode_to_ed64(path); </span>
<span class="lineNum">   1974 </span>              : 	} else </span>
<span class="lineNum">   1975 </span>              : #endif </span>
<span class="lineNum">   1976 </span><span class="linePartCov">    1 / 5     : 		return fopen(path, write_mode ? &quot;r+b&quot; : &quot;rb&quot;); </span>
<span class="lineNum">   1977 </span>              : } </span>
<span class="lineNum">   1978 </span>              :  </span>
<span class="lineNum">   1979 </span>              :  </span>
<span class="lineNum">   1980 </span>              : /* </span>
<span class="lineNum">   1981 </span>              :  *  Parse image file and fill in image_file_desc structure </span>
<span class="lineNum">   1982 </span>              :  */ </span>
<span class="lineNum">   1983 </span>              :  </span>
<span class="lineNum">   1984 </span>              : static bool parse_d64_file(FILE *f, image_file_desc &amp;desc, bool has_header_id) </span>
<span class="lineNum">   1985 </span><span class="lineCov">    2 / 2     : { </span>
<span class="lineNum">   1986 </span>              : 	// .d64 files have no header </span>
<span class="lineNum">   1987 </span><span class="lineCov">    2 / 2     : 	desc.type = has_header_id ? TYPE_ED64 : TYPE_D64; </span>
<span class="lineNum">   1988 </span><span class="lineCov">    1 / 1     : 	desc.header_size = 0; </span>
<span class="lineNum">   1989 </span>              :  </span>
<span class="lineNum">   1990 </span>              : 	// Determine number of tracks </span>
<span class="lineNum">   1991 </span><span class="lineCov">    1 / 1     : 	fseek(f, 0, SEEK_END); </span>
<span class="lineNum">   1992 </span><span class="lineCov">    2 / 2     : 	long size = ftell(f); </span>
<span class="lineNum">   1993 </span><span class="lineCov">    2 / 2     : 	if (size == NUM_SECTORS_40 * 256 || size == NUM_SECTORS_40 * 257) </span>
<span class="lineNum">   1994 </span><span class="lineNoCov">    0 / 1     : 		desc.num_tracks = 40; </span>
<span class="lineNum">   1995 </span>              : 	else </span>
<span class="lineNum">   1996 </span><span class="lineCov">    1 / 1     : 		desc.num_tracks = 35; </span>
<span class="lineNum">   1997 </span>              :  </span>
<span class="lineNum">   1998 </span><span class="linePartCov">    2 / 4     : 	if (has_header_id) { </span>
<span class="lineNum">   1999 </span>              : 		// Read header ID from image file (last 2 bytes) </span>
<span class="lineNum">   2000 </span><span class="lineNoCov">    0 / 1     : 		fseek(f, -2, SEEK_END); </span>
<span class="lineNum">   2001 </span><span class="lineNoCov">    0 / 1     : 		desc.id1 = getc(f); </span>
<span class="lineNum">   2002 </span><span class="lineNoCov">    0 / 1     : 		desc.id2 = getc(f); </span>
<span class="lineNum">   2003 </span>              : 	} else { </span>
<span class="lineNum">   2004 </span>              : 		// Read header ID from BAM (use error_info as buffer) </span>
<span class="lineNum">   2005 </span><span class="lineCov">    1 / 1     : 		fseek(f, accum_num_sectors[18] * 256, SEEK_SET); </span>
<span class="lineNum">   2006 </span><span class="lineCov">    1 / 1     : 		if (fread(desc.error_info, 1, 256, f) != 256) </span>
<span class="lineNum">   2007 </span>              : 			warning(&quot;Can't read all bytes\n&quot;); </span>
<span class="lineNum">   2008 </span><span class="lineCov">    2 / 2     : 		desc.id1 = desc.error_info[BAM_DISK_ID]; </span>
<span class="lineNum">   2009 </span><span class="lineCov">    1 / 1     : 		desc.id2 = desc.error_info[BAM_DISK_ID + 1]; </span>
<span class="lineNum">   2010 </span>              : 	} </span>
<span class="lineNum">   2011 </span>              :  </span>
<span class="lineNum">   2012 </span>              : 	// Read error info </span>
<span class="lineNum">   2013 </span>              : 	memset(desc.error_info, 1, sizeof(desc.error_info)); </span>
<span class="lineNum">   2014 </span><span class="lineCov">    1 / 1     : 	if (size == NUM_SECTORS_35 * 257) { </span>
<span class="lineNum">   2015 </span><span class="lineNoCov">    0 / 1     : 		fseek(f, NUM_SECTORS_35 * 256, SEEK_SET); </span>
<span class="lineNum">   2016 </span><span class="lineNoCov">    0 / 1     : 		if (fread(desc.error_info, NUM_SECTORS_35, 1, f) != NUM_SECTORS_35) </span>
<span class="lineNum">   2017 </span>              : 			warning(&quot;Can't read all sectors\n&quot;); </span>
<span class="lineNum">   2018 </span>              : 		desc.has_error_info = true; </span>
<span class="lineNum">   2019 </span><span class="lineCov">    1 / 1     : 	} else if (size == NUM_SECTORS_40 * 257) { </span>
<span class="lineNum">   2020 </span><span class="lineNoCov">    0 / 1     : 		fseek(f, NUM_SECTORS_40 * 256, SEEK_SET); </span>
<span class="lineNum">   2021 </span><span class="lineNoCov">    0 / 1     : 		if (fread(desc.error_info, NUM_SECTORS_40, 1, f) != NUM_SECTORS_40) </span>
<span class="lineNum">   2022 </span>              : 			warning(&quot;Can't read all sectors\n&quot;); </span>
<span class="lineNum">   2023 </span><span class="lineNoCov">    0 / 1     : 		desc.has_error_info = true; </span>
<span class="lineNum">   2024 </span>              : 	} else </span>
<span class="lineNum">   2025 </span><span class="lineCov">    1 / 1     : 		desc.has_error_info = false; </span>
<span class="lineNum">   2026 </span>              :  </span>
<span class="lineNum">   2027 </span>              : 	return true; </span>
<span class="lineNum">   2028 </span><span class="linePartCov">    1 / 2     : } </span>
<span class="lineNum">   2029 </span>              :  </span>
<span class="lineNum">   2030 </span>              : static bool parse_x64_file(FILE *f, image_file_desc &amp;desc) </span>
<span class="lineNum">   2031 </span>              : { </span>
<span class="lineNum">   2032 </span><span class="lineNoCov">    0 / 1     : 	desc.type = TYPE_X64; </span>
<span class="lineNum">   2033 </span><span class="lineNoCov">    0 / 1     : 	desc.header_size = 64; </span>
<span class="lineNum">   2034 </span>              :  </span>
<span class="lineNum">   2035 </span>              : 	// Read number of tracks </span>
<span class="lineNum">   2036 </span><span class="lineNoCov">    0 / 1     : 	fseek(f, 7, SEEK_SET); </span>
<span class="lineNum">   2037 </span><span class="lineNoCov">    0 / 1     : 	desc.num_tracks = getc(f); </span>
<span class="lineNum">   2038 </span><span class="lineNoCov">    0 / 1     : 	if (desc.num_tracks &lt; 35 || desc.num_tracks &gt; 40) </span>
<span class="lineNum">   2039 </span>              : 		return false; </span>
<span class="lineNum">   2040 </span>              :  </span>
<span class="lineNum">   2041 </span>              : 	// Read header ID from BAM (use error_info as buffer) </span>
<span class="lineNum">   2042 </span><span class="lineNoCov">    0 / 1     : 	fseek(f, desc.header_size + accum_num_sectors[18] * 256, SEEK_SET); </span>
<span class="lineNum">   2043 </span><span class="lineNoCov">    0 / 3     : 	if (fread(desc.error_info, 1, 256, f) != 256) </span>
<span class="lineNum">   2044 </span>              : 		warning(&quot;Can't read all bytes\n&quot;); </span>
<span class="lineNum">   2045 </span><span class="lineNoCov">    0 / 2     : 	desc.id1 = desc.error_info[BAM_DISK_ID]; </span>
<span class="lineNum">   2046 </span><span class="lineNoCov">    0 / 1     : 	desc.id2 = desc.error_info[BAM_DISK_ID + 1]; </span>
<span class="lineNum">   2047 </span>              :  </span>
<span class="lineNum">   2048 </span>              : 	// .x64 files have no error info </span>
<span class="lineNum">   2049 </span>              : 	memset(desc.error_info, 1, sizeof(desc.error_info)); </span>
<span class="lineNum">   2050 </span><span class="lineNoCov">    0 / 1     : 	desc.has_error_info = false; </span>
<span class="lineNum">   2051 </span>              : 	return true; </span>
<span class="lineNum">   2052 </span>              : } </span>
<span class="lineNum">   2053 </span>              :  </span>
<span class="lineNum">   2054 </span>              : static bool parse_image_file(FILE *f, image_file_desc &amp;desc) </span>
<span class="lineNum">   2055 </span><span class="lineCov">    2 / 2     : { </span>
<span class="lineNum">   2056 </span>              : 	// Read header </span>
<span class="lineNum">   2057 </span>              : 	uint8 header[64]; </span>
<span class="lineNum">   2058 </span><span class="lineCov">    1 / 1     : 	if (fread(header, 1, sizeof(header), f) != sizeof(header)) </span>
<span class="lineNum">   2059 </span>              : 		warning(&quot;Can't read all of the header\n&quot;); </span>
<span class="lineNum">   2060 </span>              :  </span>
<span class="lineNum">   2061 </span>              : 	// Determine file size </span>
<span class="lineNum">   2062 </span><span class="lineCov">    2 / 2     : 	fseek(f, 0, SEEK_END); </span>
<span class="lineNum">   2063 </span><span class="lineCov">    2 / 2     : 	long size = ftell(f); </span>
<span class="lineNum">   2064 </span>              :  </span>
<span class="lineNum">   2065 </span>              : 	// Determine file type and fill in image_file_desc structure </span>
<span class="lineNum">   2066 </span><span class="lineCov">    2 / 2     : 	if (is_x64_file(header, size)) </span>
<span class="lineNum">   2067 </span>              : 		return parse_x64_file(f, desc); </span>
<span class="lineNum">   2068 </span>              : 	else if (is_d64_file(header, size)) </span>
<span class="lineNum">   2069 </span><span class="lineCov">    1 / 1     : 		return parse_d64_file(f, desc, false); </span>
<span class="lineNum">   2070 </span><span class="lineNoCov">    0 / 1     : 	else if (is_ed64_file(header, size)) </span>
<span class="lineNum">   2071 </span><span class="lineNoCov">    0 / 1     : 		return parse_d64_file(f, desc, true); </span>
<span class="lineNum">   2072 </span>              : 	else </span>
<span class="lineNum">   2073 </span>              : 		return false; </span>
<span class="lineNum">   2074 </span><span class="linePartCov">    1 / 2     : } </span>
<span class="lineNum">   2075 </span>              :  </span>
<span class="lineNum">   2076 </span>              :  </span>
<span class="lineNum">   2077 </span>              : /* </span>
<span class="lineNum">   2078 </span>              :  *  Read directory of disk image file into (empty) c64_dir_entry vector, </span>
<span class="lineNum">   2079 </span>              :  *  returns false on error </span>
<span class="lineNum">   2080 </span>              :  */ </span>
<span class="lineNum">   2081 </span>              :  </span>
<span class="lineNum">   2082 </span><span class="lineNoCov">    0 / 3     : bool ReadImageDirectory(const char *path, vector&lt;c64_dir_entry&gt; &amp;vec) </span>
<span class="lineNum">   2083 </span><span class="lineNoCov">    0 / 4     : { </span>
<span class="lineNum">   2084 </span>              : 	bool result = false; </span>
<span class="lineNum">   2085 </span>              :  </span>
<span class="lineNum">   2086 </span>              : 	// Open file </span>
<span class="lineNum">   2087 </span>              : 	FILE *f = open_image_file(path, false); </span>
<span class="lineNum">   2088 </span><span class="lineNoCov">    0 / 3     : 	if (f) { </span>
<span class="lineNum">   2089 </span>              : 		int num_dir_blocks = 0; </span>
<span class="lineNum">   2090 </span>              :  </span>
<span class="lineNum">   2091 </span>              : 		// Determine file type and fill in image_file_desc structure </span>
<span class="lineNum">   2092 </span>              : 		image_file_desc desc; </span>
<span class="lineNum">   2093 </span><span class="lineNoCov">    0 / 1     : 		if (!parse_image_file(f, desc)) </span>
<span class="lineNum">   2094 </span>              : 			goto done; </span>
<span class="lineNum">   2095 </span>              :  </span>
<span class="lineNum">   2096 </span>              : 		// Scan all directory blocks </span>
<span class="lineNum">   2097 </span>              : 		uint8 dir[256]; </span>
<span class="lineNum">   2098 </span><span class="lineNoCov">    0 / 1     : 		dir[DIR_NEXT_TRACK] = DIR_TRACK; </span>
<span class="lineNum">   2099 </span><span class="lineNoCov">    0 / 2     : 		dir[DIR_NEXT_SECTOR] = 1; </span>
<span class="lineNum">   2100 </span>              :  </span>
<span class="lineNum">   2101 </span><span class="lineNoCov">    0 / 2     : 		while (dir[DIR_NEXT_TRACK] &amp;&amp; num_dir_blocks &lt; num_sectors[DIR_TRACK]) { </span>
<span class="lineNum">   2102 </span><span class="lineNoCov">    0 / 2     : 			if (read_sector(f, desc, dir[DIR_NEXT_TRACK], dir[DIR_NEXT_SECTOR], dir) != ERR_OK) </span>
<span class="lineNum">   2103 </span>              : 				break; </span>
<span class="lineNum">   2104 </span><span class="lineNoCov">    0 / 1     : 			num_dir_blocks++; </span>
<span class="lineNum">   2105 </span>              :  </span>
<span class="lineNum">   2106 </span>              : 			// Scan all 8 entries of a block </span>
<span class="lineNum">   2107 </span>              : 			uint8 *de = dir + DIR_ENTRIES; </span>
<span class="lineNum">   2108 </span><span class="lineNoCov">    0 / 3     : 			for (int j=0; j&lt;8; j++, de+=SIZEOF_DE) { </span>
<span class="lineNum">   2109 </span>              :  </span>
<span class="lineNum">   2110 </span>              : 				// Skip empty entries </span>
<span class="lineNum">   2111 </span><span class="lineNoCov">    0 / 1     : 				if (de[DE_TYPE] == 0) </span>
<span class="lineNum">   2112 </span>              : 					continue; </span>
<span class="lineNum">   2113 </span>              :  </span>
<span class="lineNum">   2114 </span>              : 				// Convert file name (strip everything after and including the first trailing space) </span>
<span class="lineNum">   2115 </span>              : 				uint8 name_buf[17]; </span>
<span class="lineNum">   2116 </span>              : 				memcpy(name_buf, de + DE_NAME, 16); </span>
<span class="lineNum">   2117 </span><span class="lineNoCov">    0 / 1     : 				name_buf[16] = 0; </span>
<span class="lineNum">   2118 </span>              : 				uint8 *p = (uint8 *)memchr(name_buf, 0xa0, 16); </span>
<span class="lineNum">   2119 </span><span class="lineNoCov">    0 / 1     : 				if (p) </span>
<span class="lineNum">   2120 </span><span class="lineNoCov">    0 / 1     : 					*p = 0; </span>
<span class="lineNum">   2121 </span>              :  </span>
<span class="lineNum">   2122 </span>              : 				// Convert file type </span>
<span class="lineNum">   2123 </span><span class="lineNoCov">    0 / 1     : 				int type = de[DE_TYPE] &amp; 7; </span>
<span class="lineNum">   2124 </span><span class="lineNoCov">    0 / 1     : 				if (type &gt; 4) </span>
<span class="lineNum">   2125 </span>              : 					type = FTYPE_UNKNOWN; </span>
<span class="lineNum">   2126 </span>              :  </span>
<span class="lineNum">   2127 </span>              : 				// Read start address </span>
<span class="lineNum">   2128 </span>              : 				uint8 sa_lo = 0, sa_hi = 0; </span>
<span class="lineNum">   2129 </span>              : 				uint8 buf[256]; </span>
<span class="lineNum">   2130 </span><span class="lineNoCov">    0 / 1     : 				if (read_sector(f, desc, de[DE_TRACK], de[DE_SECTOR], buf) == ERR_OK) { </span>
<span class="lineNum">   2131 </span><span class="lineNoCov">    0 / 1     : 					sa_lo = buf[2]; </span>
<span class="lineNum">   2132 </span><span class="lineNoCov">    0 / 2     : 					sa_hi = buf[3]; </span>
<span class="lineNum">   2133 </span>              : 				} </span>
<span class="lineNum">   2134 </span>              :  </span>
<span class="lineNum">   2135 </span>              : 				// Add entry </span>
<span class="lineNum">   2136 </span><span class="lineNoCov">    0 / 1     : 				vec.push_back(c64_dir_entry(name_buf, type, !(de[DE_TYPE] &amp; 0x80), de[DE_TYPE] &amp; 0x40, ((de[DE_NUM_BLOCKS_H] &lt;&lt; 8) + de[DE_NUM_BLOCKS_L]) * 254, 0, sa_lo, sa_hi)); </span>
<span class="lineNum">   2137 </span>              : 			} </span>
<span class="lineNum">   2138 </span>              : 		} </span>
<span class="lineNum">   2139 </span>              :  </span>
<span class="lineNum">   2140 </span>              : 		result = true; </span>
<span class="lineNum">   2141 </span><span class="lineNoCov">    0 / 1     : done:	fclose(f); </span>
<span class="lineNum">   2142 </span>              : 	} </span>
<span class="lineNum">   2143 </span>              : 	return result; </span>
<span class="lineNum">   2144 </span><span class="lineNoCov">    0 / 3     : } </span>
<span class="lineNum">   2145 </span>              :  </span>
<span class="lineNum">   2146 </span>              :  </span>
<span class="lineNum">   2147 </span>              : /* </span>
<span class="lineNum">   2148 </span>              :  *  Create new blank disk image file, returns false on error </span>
<span class="lineNum">   2149 </span>              :  */ </span>
<span class="lineNum">   2150 </span>              :  </span>
<span class="lineNum">   2151 </span>              : bool CreateImageFile(const char *path) </span>
<span class="lineNum">   2152 </span><span class="lineNoCov">    0 / 1     : { </span>
<span class="lineNum">   2153 </span>              : 	// Open file for writing </span>
<span class="lineNum">   2154 </span><span class="lineNoCov">    0 / 1     : 	FILE *f = fopen(path, &quot;wb&quot;); </span>
<span class="lineNum">   2155 </span><span class="lineNoCov">    0 / 1     : 	if (f == NULL) </span>
<span class="lineNum">   2156 </span>              : 		return false; </span>
<span class="lineNum">   2157 </span>              :  </span>
<span class="lineNum">   2158 </span>              : 	// Create descriptor </span>
<span class="lineNum">   2159 </span>              : 	image_file_desc desc; </span>
<span class="lineNum">   2160 </span><span class="lineNoCov">    0 / 1     : 	desc.type = TYPE_D64; </span>
<span class="lineNum">   2161 </span><span class="lineNoCov">    0 / 1     : 	desc.header_size = 0; </span>
<span class="lineNum">   2162 </span><span class="lineNoCov">    0 / 1     : 	desc.num_tracks = 35; </span>
<span class="lineNum">   2163 </span>              : 	desc.id1 = 'F'; </span>
<span class="lineNum">   2164 </span><span class="lineNoCov">    0 / 1     : 	desc.id1 = 'R'; </span>
<span class="lineNum">   2165 </span>              : 	memset(desc.error_info, 1, sizeof(desc.error_info)); </span>
<span class="lineNum">   2166 </span><span class="lineNoCov">    0 / 1     : 	desc.has_error_info = false; </span>
<span class="lineNum">   2167 </span>              :  </span>
<span class="lineNum">   2168 </span>              : 	// Format image file </span>
<span class="lineNum">   2169 </span><span class="lineNoCov">    0 / 3     : 	if (!format_image(f, desc, true, 'F', 'R', (uint8 *)&quot;D64 FILE&quot;, 8)) { </span>
<span class="lineNum">   2170 </span><span class="lineNoCov">    0 / 1     : 		fclose(f); </span>
<span class="lineNum">   2171 </span><span class="lineNoCov">    0 / 1     : 		remove(path); </span>
<span class="lineNum">   2172 </span><span class="lineNoCov">    0 / 1     : 		return false; </span>
<span class="lineNum">   2173 </span>              : 	} </span>
<span class="lineNum">   2174 </span>              :  </span>
<span class="lineNum">   2175 </span>              : 	// Close file </span>
<span class="lineNum">   2176 </span><span class="lineNoCov">    0 / 1     : 	fclose(f); </span>
<span class="lineNum">   2177 </span>              : 	return true; </span>
<span class="lineNum">   2178 </span><span class="lineNoCov">    0 / 2     : } </span>
</pre>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr><td class="versionInfo">Generated by: Kcov (based on <a href="http://bcov.sourceforge.net">bcov</a>)</td></tr>
</table>
<br/>
</body>
</html>
