<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Coverage - kcov</title>
  <link rel="stylesheet" type="text/css" href="bcov.css"/>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="title">Coverage Report</td></tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr>
    <td width="100%">
      <table cellpadding="1" border="0" width="100%">
        <tr>
          <td class="headerItem" width="20%">Command:</td>
          <td class="headerValue" width="80%" colspan=6>kcov</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Date:</td>
          <td class="headerValue" width="15%">2014-03-01 10:11:51</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Instrumented&nbsp;lines:</td>
          <td class="headerValue" width="10%">75</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Code&nbsp;covered:</td>
          <td class="coverPerLeftHi" width="15%">86.7%</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Executed&nbsp;lines:</td>
          <td class="headerValue" width="10%">65</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
</table>
<pre class="source">
<span class="lineNum">    1</span>              : #include &quot;writer-base.hh&quot; </span>
<span class="lineNum">    2</span>              : #include &lt;utils.hh&gt; </span>
<span class="lineNum">    3</span>              :  </span>
<span class="lineNum">    4</span>              : #include &lt;stdio.h&gt; </span>
<span class="lineNum">    5</span>              :  </span>
<span class="lineNum">    6</span>              : using namespace kcov; </span>
<span class="lineNum">    7</span>              :  </span>
<span class="lineNum">    8</span>              : struct summaryStruct </span>
<span class="lineNum">    9</span>              : { </span>
<span class="lineNum">   10</span>              : 	uint32_t nLines; </span>
<span class="lineNum">   11</span>              : 	uint32_t nExecutedLines; </span>
<span class="lineNum">   12</span>              : 	char name[256]; </span>
<span class="lineNum">   13</span>              : }; </span>
<span class="lineNum">   14</span>              :  </span>
<span class="lineNum">   15</span>              : int WriterBase::File::fileNameCount; </span>
<span class="lineNum">   16</span>              :  </span>
<span class="lineNum">   17</span><span class="lineCov">      1  /   1: WriterBase::WriterBase(IFileParser &amp;parser, IReporter &amp;reporter, IOutputHandler &amp;output) : </span>
<span class="lineNum">   18</span>              : 		m_fileParser(parser), m_reporter(reporter), </span>
<span class="lineNum">   19</span><span class="linePartCov">      1  /   2: 		m_filter(IFilter::getInstance()) </span>
<span class="lineNum">   20</span>              : { </span>
<span class="lineNum">   21</span><span class="lineCov">      1  /   1: 		m_commonPath = &quot;not set&quot;; </span>
<span class="lineNum">   22</span><span class="lineCov">      1  /   1: 		m_fileParser.registerLineListener(*this); </span>
<span class="lineNum">   23</span><span class="lineCov">      2  /   2: } </span>
<span class="lineNum">   24</span>              :  </span>
<span class="lineNum">   25</span><span class="lineCov">      1  /   1: WriterBase::File::File(const char *filename) : </span>
<span class="lineNum">   26</span><span class="linePartCov">      1  /   3: 						m_name(filename), m_codeLines(0), m_executedLines(0), m_lastLineNr(0) </span>
<span class="lineNum">   27</span>              : { </span>
<span class="lineNum">   28</span><span class="lineCov">      1  /   1: 	size_t pos = m_name.rfind(&#039;&#047;&#039;); </span>
<span class="lineNum">   29</span>              :  </span>
<span class="lineNum">   30</span><span class="lineCov">      1  /   1: 	if (pos != std::string::npos) </span>
<span class="lineNum">   31</span><span class="linePartCov">      1  /   2: 		m_fileName = m_name.substr(pos + 1, std::string::npos); </span>
<span class="lineNum">   32</span>              : 	else </span>
<span class="lineNum">   33</span><span class="lineNoCov">      0  /   1: 		m_fileName = m_name; </span>
<span class="lineNum">   34</span>              :  </span>
<span class="lineNum">   35</span>              : 	&#047;&#047; Make this name unique (we might have several files with the same name) </span>
<span class="lineNum">   36</span><span class="linePartCov">      1  /   2: 	m_outFileName = fmt(&quot;%s.%d.html&quot;, m_fileName.c_str(), fileNameCount); </span>
<span class="lineNum">   37</span><span class="lineCov">      1  /   1: 	fileNameCount++; </span>
<span class="lineNum">   38</span>              :  </span>
<span class="lineNum">   39</span><span class="lineCov">      1  /   1: 	readFile(filename); </span>
<span class="lineNum">   40</span><span class="lineCov">      2  /   2: } </span>
<span class="lineNum">   41</span>              :  </span>
<span class="lineNum">   42</span>              : void WriterBase::File::readFile(const char *filename) </span>
<span class="lineNum">   43</span><span class="lineCov">      1  /   1: { </span>
<span class="lineNum">   44</span><span class="lineCov">      1  /   1: 	FILE *fp = fopen(filename, &quot;r&quot;); </span>
<span class="lineNum">   45</span><span class="lineCov">      1  /   1: 	unsigned int lineNr = 1; </span>
<span class="lineNum">   46</span>              :  </span>
<span class="lineNum">   47</span><span class="lineCov">      1  /   1: 	panic_if(!fp, &quot;Can&#039;t open %s&quot;, filename); </span>
<span class="lineNum">   48</span>              :  </span>
<span class="lineNum">   49</span>              : 	while (1) </span>
<span class="lineNum">   50</span>              : 	{ </span>
<span class="lineNum">   51</span><span class="lineCov">      1  /   1: 		char *lineptr = nullptr; </span>
<span class="lineNum">   52</span>              : 		ssize_t res; </span>
<span class="lineNum">   53</span>              : 		size_t n; </span>
<span class="lineNum">   54</span>              :  </span>
<span class="lineNum">   55</span><span class="lineCov">      1  /   1: 		res = getline(&amp;lineptr, &amp;n, fp); </span>
<span class="lineNum">   56</span><span class="lineCov">      1  /   1: 		if (res &lt; 0) </span>
<span class="lineNum">   57</span>              : 			break; </span>
<span class="lineNum">   58</span><span class="linePartCov">      1  /   2: 		m_lineMap[lineNr] = std::string(lineptr); </span>
<span class="lineNum">   59</span>              :  </span>
<span class="lineNum">   60</span><span class="lineCov">      1  /   1: 		free((void *)lineptr); </span>
<span class="lineNum">   61</span><span class="lineCov">      1  /   1: 		lineNr++; </span>
<span class="lineNum">   62</span>              : 	} </span>
<span class="lineNum">   63</span>              :  </span>
<span class="lineNum">   64</span><span class="lineCov">      1  /   1: 	m_lastLineNr = lineNr; </span>
<span class="lineNum">   65</span>              :  </span>
<span class="lineNum">   66</span><span class="lineCov">      2  /   2: 	fclose(fp); </span>
<span class="lineNum">   67</span><span class="lineCov">      2  /   2: } </span>
<span class="lineNum">   68</span>              :  </span>
<span class="lineNum">   69</span>              :  </span>
<span class="lineNum">   70</span>              : void WriterBase::onLine(const char *file, unsigned int lineNr, unsigned long addr) </span>
<span class="lineNum">   71</span><span class="lineCov">      1  /   1: { </span>
<span class="lineNum">   72</span><span class="linePartCov">      1  /   2: 	if (!m_filter.runFilters(file)) </span>
<span class="lineNum">   73</span><span class="lineNoCov">      0  /   1: 		return; </span>
<span class="lineNum">   74</span>              :  </span>
<span class="lineNum">   75</span>              :  </span>
<span class="lineNum">   76</span><span class="linePartCov">      1  /   2: 	if (m_files.find(std::string(file)) != m_files.end()) </span>
<span class="lineNum">   77</span><span class="lineCov">      1  /   1: 		return; </span>
<span class="lineNum">   78</span>              :  </span>
<span class="lineNum">   79</span><span class="linePartCov">      1  /   2: 	if (m_nonExistingFiles.find(std::string(file)) != m_nonExistingFiles.end()) </span>
<span class="lineNum">   80</span><span class="lineNoCov">      0  /   1: 		return; </span>
<span class="lineNum">   81</span>              :  </span>
<span class="lineNum">   82</span><span class="lineCov">      1  /   1: 	if (!file_exists(file)) { </span>
<span class="lineNum">   83</span><span class="lineNoCov">      0  /   2: 		m_nonExistingFiles[std::string(file)] = nullptr; </span>
<span class="lineNum">   84</span><span class="lineNoCov">      0  /   1: 		return; </span>
<span class="lineNum">   85</span>              : 	} </span>
<span class="lineNum">   86</span>              :  </span>
<span class="lineNum">   87</span><span class="linePartCov">      1  /   2: 	m_files[std::string(file)] = new File(file); </span>
<span class="lineNum">   88</span><span class="lineCov">      1  /   1: } </span>
<span class="lineNum">   89</span>              :  </span>
<span class="lineNum">   90</span>              :  </span>
<span class="lineNum">   91</span>              : void *WriterBase::marshalSummary(IReporter::ExecutionSummary &amp;summary, </span>
<span class="lineNum">   92</span>              : 		std::string &amp;name, size_t *sz) </span>
<span class="lineNum">   93</span><span class="lineCov">      1  /   1: { </span>
<span class="lineNum">   94</span>              : 	struct summaryStruct *p; </span>
<span class="lineNum">   95</span>              :  </span>
<span class="lineNum">   96</span><span class="lineCov">      1  /   1: 	p = (struct summaryStruct *)xmalloc(sizeof(struct summaryStruct)); </span>
<span class="lineNum">   97</span><span class="lineCov">      1  /   1: 	memset(p, 0, sizeof(*p)); </span>
<span class="lineNum">   98</span>              :  </span>
<span class="lineNum">   99</span><span class="lineCov">      1  /   1: 	p-&gt;nLines = summary.m_lines; </span>
<span class="lineNum">  100</span><span class="lineCov">      1  /   1: 	p-&gt;nExecutedLines = summary.m_executedLines; </span>
<span class="lineNum">  101</span><span class="lineCov">      1  /   1: 	strncpy(p-&gt;name, name.c_str(), sizeof(p-&gt;name) - 1); </span>
<span class="lineNum">  102</span>              :  </span>
<span class="lineNum">  103</span><span class="lineCov">      1  /   1: 	*sz = sizeof(*p); </span>
<span class="lineNum">  104</span>              :  </span>
<span class="lineNum">  105</span><span class="lineCov">      1  /   1: 	return (void *)p; </span>
<span class="lineNum">  106</span><span class="lineCov">      1  /   1: } </span>
<span class="lineNum">  107</span>              :  </span>
<span class="lineNum">  108</span>              : bool WriterBase::unMarshalSummary(void *data, size_t sz, </span>
<span class="lineNum">  109</span>              : 		IReporter::ExecutionSummary &amp;summary, </span>
<span class="lineNum">  110</span>              : 		std::string &amp;name) </span>
<span class="lineNum">  111</span><span class="lineCov">      1  /   1: { </span>
<span class="lineNum">  112</span><span class="lineCov">      1  /   1: 	struct summaryStruct *p = (struct summaryStruct *)data; </span>
<span class="lineNum">  113</span>              :  </span>
<span class="lineNum">  114</span><span class="lineCov">      1  /   1: 	if (sz != sizeof(*p)) </span>
<span class="lineNum">  115</span><span class="lineNoCov">      0  /   1: 		return false; </span>
<span class="lineNum">  116</span>              :  </span>
<span class="lineNum">  117</span><span class="lineCov">      1  /   1: 	summary.m_lines = p-&gt;nLines; </span>
<span class="lineNum">  118</span><span class="lineCov">      1  /   1: 	summary.m_executedLines = p-&gt;nExecutedLines; </span>
<span class="lineNum">  119</span><span class="linePartCov">      1  /   2: 	name = std::string(p-&gt;name); </span>
<span class="lineNum">  120</span>              :  </span>
<span class="lineNum">  121</span><span class="lineCov">      1  /   1: 	return true; </span>
<span class="lineNum">  122</span><span class="lineCov">      1  /   1: } </span>
<span class="lineNum">  123</span>              :  </span>
<span class="lineNum">  124</span>              : void WriterBase::setupCommonPaths() </span>
<span class="lineNum">  125</span><span class="lineCov">      1  /   1: { </span>
<span class="lineNum">  126</span><span class="lineCov">      2  /   2: 	for (const auto &amp; it : m_files) { </span>
<span class="lineNum">  127</span><span class="lineCov">      1  /   1: 		File *file = it.second; </span>
<span class="lineNum">  128</span>              :  </span>
<span class="lineNum">  129</span><span class="lineCov">      1  /   1: 		if (m_commonPath == &quot;not set&quot;) </span>
<span class="lineNum">  130</span><span class="lineCov">      1  /   1: 			m_commonPath = file-&gt;m_name; </span>
<span class="lineNum">  131</span>              :  </span>
<span class="lineNum">  132</span>              : 		&#047;* Already matching? *&#047; </span>
<span class="lineNum">  133</span><span class="lineCov">      1  /   1: 		if (file-&gt;m_name.find(m_commonPath) == 0) </span>
<span class="lineNum">  134</span><span class="lineCov">      1  /   1: 			continue; </span>
<span class="lineNum">  135</span>              :  </span>
<span class="lineNum">  136</span>              : 		while (1) { </span>
<span class="lineNum">  137</span><span class="lineCov">      1  /   1: 			size_t pos = m_commonPath.rfind(&#039;&#047;&#039;); </span>
<span class="lineNum">  138</span><span class="lineCov">      1  /   1: 			if (pos == std::string::npos) </span>
<span class="lineNum">  139</span><span class="lineNoCov">      0  /   1: 				break; </span>
<span class="lineNum">  140</span>              :  </span>
<span class="lineNum">  141</span><span class="linePartCov">      1  /   2: 			m_commonPath = m_commonPath.substr(0, pos); </span>
<span class="lineNum">  142</span><span class="lineCov">      1  /   1: 			if (file-&gt;m_name.find(m_commonPath) == 0) </span>
<span class="lineNum">  143</span><span class="lineCov">      1  /   1: 				break; </span>
<span class="lineNum">  144</span>              : 		} </span>
<span class="lineNum">  145</span><span class="lineNoCov">      0  /   1: 	} </span>
<span class="lineNum">  146</span><span class="lineCov">      1  /   1: } </span>
<span class="lineNum">  147</span>              :  </span>
<span class="lineNum">  148</span>              : void WriterBase::stop() </span>
<span class="lineNum">  149</span><span class="lineNoCov">      0  /   1: { </span>
<span class="lineNum">  150</span><span class="lineNoCov">      0  /   1: } </span>
</pre>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr><td class="versionInfo">Generated by: <a href="http://simonkagstrom.github.com/kcov/index.html">Kcov</a></td></tr>
</table>
<br/>
</body>
</html>
