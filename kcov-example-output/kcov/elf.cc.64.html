<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Coverage - kcov</title>
  <link rel="stylesheet" type="text/css" href="bcov.css"/>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="title">Coverage Report</td></tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr>
    <td width="100%">
      <table cellpadding="1" border="0" width="100%">
        <tr>
          <td class="headerItem" width="20%">Command:</td>
          <td class="headerValue" width="80%" colspan=6>kcov</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Date:</td>
          <td class="headerValue" width="15%">2014-03-01 10:11:51</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Instrumented&nbsp;lines:</td>
          <td class="headerValue" width="10%">237</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Code&nbsp;covered:</td>
          <td class="coverPerLeftLo" width="15%">8.4%</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Executed&nbsp;lines:</td>
          <td class="headerValue" width="10%">20</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
</table>
<pre class="source">
<span class="lineNum">    1</span>              : #include &lt;file-parser.hh&gt; </span>
<span class="lineNum">    2</span>              : #include &lt;engine.hh&gt; </span>
<span class="lineNum">    3</span>              : #include &lt;utils.hh&gt; </span>
<span class="lineNum">    4</span>              : #include &lt;phdr_data.h&gt; </span>
<span class="lineNum">    5</span>              :  </span>
<span class="lineNum">    6</span>              : #include &lt;sys&#047;types.h&gt; </span>
<span class="lineNum">    7</span>              : #include &lt;sys&#047;stat.h&gt; </span>
<span class="lineNum">    8</span>              : #include &lt;fcntl.h&gt; </span>
<span class="lineNum">    9</span>              : #include &lt;unistd.h&gt; </span>
<span class="lineNum">   10</span>              : #include &lt;libelf.h&gt; </span>
<span class="lineNum">   11</span>              : #include &lt;dwarf.h&gt; </span>
<span class="lineNum">   12</span>              : #include &lt;elfutils&#047;libdw.h&gt; </span>
<span class="lineNum">   13</span>              : #include &lt;map&gt; </span>
<span class="lineNum">   14</span>              : #include &lt;list&gt; </span>
<span class="lineNum">   15</span>              : #include &lt;string&gt; </span>
<span class="lineNum">   16</span>              : #include &lt;configuration.hh&gt; </span>
<span class="lineNum">   17</span>              : #ifndef _GNU_SOURCE </span>
<span class="lineNum">   18</span>              : # define _GNU_SOURCE </span>
<span class="lineNum">   19</span>              : #endif </span>
<span class="lineNum">   20</span>              : #include &lt;link.h&gt; </span>
<span class="lineNum">   21</span>              :  </span>
<span class="lineNum">   22</span>              : using namespace kcov; </span>
<span class="lineNum">   23</span>              :  </span>
<span class="lineNum">   24</span>              : enum SymbolType </span>
<span class="lineNum">   25</span>              : { </span>
<span class="lineNum">   26</span>              : 	SYM_NORMAL = 0, </span>
<span class="lineNum">   27</span>              : 	SYM_DYNAMIC = 1, </span>
<span class="lineNum">   28</span>              : }; </span>
<span class="lineNum">   29</span>              :  </span>
<span class="lineNum">   30</span>              : class ElfInstance : public IFileParser </span>
<span class="lineNum">   31</span>              : { </span>
<span class="lineNum">   32</span>              : public: </span>
<span class="lineNum">   33</span><span class="lineNoCov">      0  /   1: 	ElfInstance() </span>
<span class="lineNum">   34</span><span class="linePartCov">      1  /   2: 	{ </span>
<span class="lineNum">   35</span><span class="lineCov">      1  /   1: 		m_elf = nullptr; </span>
<span class="lineNum">   36</span><span class="lineCov">      1  /   1: 		m_filename = &quot;&quot;; </span>
<span class="lineNum">   37</span><span class="lineCov">      1  /   1: 		m_checksum = 0; </span>
<span class="lineNum">   38</span><span class="lineCov">      1  /   1: 		m_elfIs32Bit = true; </span>
<span class="lineNum">   39</span><span class="lineCov">      1  /   1: 		m_isMainFile = true; </span>
<span class="lineNum">   40</span><span class="lineCov">      1  /   1: 		m_initialized = false; </span>
<span class="lineNum">   41</span>              :  </span>
<span class="lineNum">   42</span>              : 		&#047;******* Swap debug source root with runtime source root *****&#047; </span>
<span class="lineNum">   43</span><span class="lineCov">      1  /   1: 		origRoot = IConfiguration::getInstance().getOriginalPathPrefix(); </span>
<span class="lineNum">   44</span><span class="lineCov">      1  /   1: 		newRoot  = IConfiguration::getInstance().getNewPathPrefix(); </span>
<span class="lineNum">   45</span>              :  </span>
<span class="lineNum">   46</span><span class="lineCov">      1  /   1: 		IParserManager::getInstance().registerParser(*this); </span>
<span class="lineNum">   47</span><span class="linePartCov">      2  /   3: 	} </span>
<span class="lineNum">   48</span>              :  </span>
<span class="lineNum">   49</span><span class="linePartCov">      1  /   2: 	virtual ~ElfInstance() </span>
<span class="lineNum">   50</span><span class="lineCov">      1  /   1: 	{ </span>
<span class="lineNum">   51</span><span class="linePartCov">      1  /   3: 	} </span>
<span class="lineNum">   52</span>              :  </span>
<span class="lineNum">   53</span><span class="lineNoCov">      0  /   1: 	uint64_t getChecksum() </span>
<span class="lineNum">   54</span>              : 	{ </span>
<span class="lineNum">   55</span><span class="lineNoCov">      0  /   1: 		return m_checksum; </span>
<span class="lineNum">   56</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">   57</span>              :  </span>
<span class="lineNum">   58</span><span class="lineNoCov">      0  /   1: 	bool elfIs64Bit() </span>
<span class="lineNum">   59</span>              : 	{ </span>
<span class="lineNum">   60</span><span class="lineNoCov">      0  /   1: 		return !m_elfIs32Bit; </span>
<span class="lineNum">   61</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">   62</span>              :  </span>
<span class="lineNum">   63</span><span class="lineCov">      1  /   1: 	unsigned int matchParser(const std::string &amp;filename, uint8_t *data, size_t dataSize) </span>
<span class="lineNum">   64</span>              : 	{ </span>
<span class="lineNum">   65</span><span class="lineCov">      1  /   1: 		Elf32_Ehdr *hdr = (Elf32_Ehdr *)data; </span>
<span class="lineNum">   66</span>              :  </span>
<span class="lineNum">   67</span><span class="lineCov">      1  /   1: 		if (memcmp(hdr-&gt;e_ident, ELFMAG, strlen(ELFMAG)) == 0) </span>
<span class="lineNum">   68</span><span class="lineNoCov">      0  /   1: 			return match_perfect; </span>
<span class="lineNum">   69</span>              :  </span>
<span class="lineNum">   70</span><span class="lineCov">      1  /   1: 		return match_none; </span>
<span class="lineNum">   71</span><span class="linePartCov">      1  /   2: 	} </span>
<span class="lineNum">   72</span>              :  </span>
<span class="lineNum">   73</span><span class="lineNoCov">      0  /   1: 	bool addFile(const std::string &amp;filename, struct phdr_data_entry *data) </span>
<span class="lineNum">   74</span>              : 	{ </span>
<span class="lineNum">   75</span><span class="lineNoCov">      0  /   1: 		if (!m_initialized) { </span>
<span class="lineNum">   76</span><span class="lineNoCov">      0  /   1: 			panic_if(elf_version(EV_CURRENT) == EV_NONE, </span>
<span class="lineNum">   77</span>              : 					&quot;ELF version failed&#092;n&quot;); </span>
<span class="lineNum">   78</span><span class="lineNoCov">      0  /   1: 			m_initialized = true; </span>
<span class="lineNum">   79</span>              : 		} </span>
<span class="lineNum">   80</span>              :  </span>
<span class="lineNum">   81</span>              :  </span>
<span class="lineNum">   82</span><span class="lineNoCov">      0  /   1: 		m_filename = filename; </span>
<span class="lineNum">   83</span>              :  </span>
<span class="lineNum">   84</span><span class="lineNoCov">      0  /   1: 		m_buildId.clear(); </span>
<span class="lineNum">   85</span>              :  </span>
<span class="lineNum">   86</span><span class="lineNoCov">      0  /   1: 		m_curSegments.clear(); </span>
<span class="lineNum">   87</span><span class="lineNoCov">      0  /   1: 		m_executableSegments.clear(); </span>
<span class="lineNum">   88</span><span class="lineNoCov">      0  /   2: 		for (uint32_t i = 0; data &amp;&amp; i &lt; data-&gt;n_segments; i++) { </span>
<span class="lineNum">   89</span><span class="lineNoCov">      0  /   1: 			struct phdr_data_segment *seg = &amp;data-&gt;segments[i]; </span>
<span class="lineNum">   90</span>              :  </span>
<span class="lineNum">   91</span><span class="lineNoCov">      0  /   1: 			m_curSegments.push_back(Segment(seg-&gt;paddr, seg-&gt;vaddr, seg-&gt;size)); </span>
<span class="lineNum">   92</span>              : 		} </span>
<span class="lineNum">   93</span>              :  </span>
<span class="lineNum">   94</span><span class="lineNoCov">      0  /   1: 		return checkFile(); </span>
<span class="lineNum">   95</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">   96</span>              :  </span>
<span class="lineNum">   97</span><span class="lineNoCov">      0  /   1: 	bool checkFile() </span>
<span class="lineNum">   98</span>              : 	{ </span>
<span class="lineNum">   99</span>              : 		struct Elf *elf; </span>
<span class="lineNum">  100</span><span class="lineNoCov">      0  /   1: 		bool out = true; </span>
<span class="lineNum">  101</span>              : 		int fd; </span>
<span class="lineNum">  102</span>              :  </span>
<span class="lineNum">  103</span><span class="lineNoCov">      0  /   1: 		fd = ::open(m_filename.c_str(), O_RDONLY, 0); </span>
<span class="lineNum">  104</span><span class="lineNoCov">      0  /   1: 		if (fd &lt; 0) { </span>
<span class="lineNum">  105</span><span class="lineNoCov">      0  /   1: 				error(&quot;Cannot open %s&#092;n&quot;, m_filename.c_str()); </span>
<span class="lineNum">  106</span><span class="lineNoCov">      0  /   1: 				return false; </span>
<span class="lineNum">  107</span>              : 		} </span>
<span class="lineNum">  108</span>              :  </span>
<span class="lineNum">  109</span><span class="lineNoCov">      0  /   1: 		if (!(elf = elf_begin(fd, ELF_C_READ, nullptr)) ) { </span>
<span class="lineNum">  110</span><span class="lineNoCov">      0  /   1: 				error(&quot;elf_begin failed on %s&#092;n&quot;, m_filename.c_str()); </span>
<span class="lineNum">  111</span><span class="lineNoCov">      0  /   1: 				out = false; </span>
<span class="lineNum">  112</span><span class="lineNoCov">      0  /   1: 				goto out_open; </span>
<span class="lineNum">  113</span>              : 		} </span>
<span class="lineNum">  114</span><span class="lineNoCov">      0  /   1: 		if (elf_kind(elf) == ELF_K_NONE) </span>
<span class="lineNum">  115</span><span class="lineNoCov">      0  /   1: 			out = false; </span>
<span class="lineNum">  116</span>              :  </span>
<span class="lineNum">  117</span><span class="lineNoCov">      0  /   1: 		if (m_isMainFile) { </span>
<span class="lineNum">  118</span>              : 			char *raw; </span>
<span class="lineNum">  119</span>              : 			size_t sz; </span>
<span class="lineNum">  120</span>              :  </span>
<span class="lineNum">  121</span><span class="lineNoCov">      0  /   1: 			raw = elf_getident(elf, &amp;sz); </span>
<span class="lineNum">  122</span>              :  </span>
<span class="lineNum">  123</span><span class="lineNoCov">      0  /   1: 			if (raw &amp;&amp; sz &gt; EI_CLASS) { </span>
<span class="lineNum">  124</span><span class="lineNoCov">      0  /   1: 				m_elfIs32Bit = raw[EI_CLASS] == ELFCLASS32; </span>
<span class="lineNum">  125</span>              :  </span>
<span class="lineNum">  126</span><span class="lineNoCov">      0  /   1: 				if (elfIs64Bit() != machine_is_64bit()) </span>
<span class="lineNum">  127</span><span class="lineNoCov">      0  /   1: 					IConfiguration::getInstance().setParseSolibs(false); </span>
<span class="lineNum">  128</span>              : 			} </span>
<span class="lineNum">  129</span>              :  </span>
<span class="lineNum">  130</span><span class="lineNoCov">      0  /   1: 			m_checksum = m_elfIs32Bit ? elf32_checksum(elf) : elf64_checksum(elf); </span>
<span class="lineNum">  131</span>              : 		} </span>
<span class="lineNum">  132</span>              :  </span>
<span class="lineNum">  133</span><span class="lineNoCov">      0  /   1: 		elf_end(elf); </span>
<span class="lineNum">  134</span>              :  </span>
<span class="lineNum">  135</span>              : out_open: </span>
<span class="lineNum">  136</span><span class="lineNoCov">      0  /   1: 		close(fd); </span>
<span class="lineNum">  137</span>              :  </span>
<span class="lineNum">  138</span><span class="lineNoCov">      0  /   1: 		return out; </span>
<span class="lineNum">  139</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">  140</span>              :  </span>
<span class="lineNum">  141</span><span class="lineNoCov">      0  /   1: 	bool parse() </span>
<span class="lineNum">  142</span>              : 	{ </span>
<span class="lineNum">  143</span>              : 		struct stat st; </span>
<span class="lineNum">  144</span>              :  </span>
<span class="lineNum">  145</span><span class="lineNoCov">      0  /   1: 		if (lstat(m_filename.c_str(), &amp;st) &lt; 0) </span>
<span class="lineNum">  146</span><span class="lineNoCov">      0  /   1: 			return 0; </span>
<span class="lineNum">  147</span>              :  </span>
<span class="lineNum">  148</span><span class="lineNoCov">      0  /   1: 		parseOneElf(); </span>
<span class="lineNum">  149</span><span class="lineNoCov">      0  /   1: 		parseOneDwarf(); </span>
<span class="lineNum">  150</span>              :  </span>
<span class="lineNum">  151</span><span class="lineNoCov">      0  /   2: 		for (const auto &amp;it : m_fileListeners) </span>
<span class="lineNum">  152</span><span class="lineNoCov">      0  /   1: 			it-&gt;onFile(m_filename.c_str(), m_isMainFile ? IFileParser::FLG_NONE : IFileParser::FLG_TYPE_SOLIB); </span>
<span class="lineNum">  153</span>              :  </span>
<span class="lineNum">  154</span>              : 		&#047;&#047; After the first, all other are solibs </span>
<span class="lineNum">  155</span><span class="lineNoCov">      0  /   1: 		m_isMainFile = false; </span>
<span class="lineNum">  156</span>              :  </span>
<span class="lineNum">  157</span><span class="lineNoCov">      0  /   1: 		return true; </span>
<span class="lineNum">  158</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">  159</span>              :  </span>
<span class="lineNum">  160</span><span class="lineNoCov">      0  /   1: 	bool parseOneDwarf() </span>
<span class="lineNum">  161</span>              : 	{ </span>
<span class="lineNum">  162</span><span class="lineNoCov">      0  /   1: 		Dwarf_Off offset = 0; </span>
<span class="lineNum">  163</span><span class="lineNoCov">      0  /   1: 		Dwarf_Off last_offset = 0; </span>
<span class="lineNum">  164</span>              : 		size_t hdr_size; </span>
<span class="lineNum">  165</span>              : 		Dwarf *dbg; </span>
<span class="lineNum">  166</span>              : 		int fd; </span>
<span class="lineNum">  167</span>              :  </span>
<span class="lineNum">  168</span><span class="lineNoCov">      0  /   1: 		fd = ::open(m_filename.c_str(), O_RDONLY, 0); </span>
<span class="lineNum">  169</span><span class="lineNoCov">      0  /   1: 		if (fd &lt; 0) { </span>
<span class="lineNum">  170</span><span class="lineNoCov">      0  /   1: 				error(&quot;Cannot open %s&#092;n&quot;, m_filename.c_str()); </span>
<span class="lineNum">  171</span><span class="lineNoCov">      0  /   1: 				return false; </span>
<span class="lineNum">  172</span>              : 		} </span>
<span class="lineNum">  173</span>              :  </span>
<span class="lineNum">  174</span>              : 		&#047;* Initialize libdwarf *&#047; </span>
<span class="lineNum">  175</span><span class="lineNoCov">      0  /   1: 		dbg = dwarf_begin(fd, DWARF_C_READ); </span>
<span class="lineNum">  176</span>              :  </span>
<span class="lineNum">  177</span><span class="lineNoCov">      0  /   1: 		if (!dbg &amp;&amp; m_buildId.length() &gt; 0) { </span>
<span class="lineNum">  178</span>              : 			&#047;* Look for separate debug info *&#047; </span>
<span class="lineNum">  179</span><span class="lineNoCov">      0  /   1: 			std::string debug_file = std::string(&quot;&#047;usr&#047;lib&#047;debug&#047;.build-id&#047;&quot; + </span>
<span class="lineNum">  180</span><span class="lineNoCov">      0  /   1: 							     m_buildId.substr(0,2) + </span>
<span class="lineNum">  181</span><span class="lineNoCov">      0  /   2: 							     &quot;&#047;&quot; + </span>
<span class="lineNum">  182</span>              : 							     m_buildId.substr(2, std::string::npos) + </span>
<span class="lineNum">  183</span><span class="lineNoCov">      0  /   1: 							     &quot;.debug&quot;); </span>
<span class="lineNum">  184</span>              :  </span>
<span class="lineNum">  185</span><span class="lineNoCov">      0  /   1: 			close(fd); </span>
<span class="lineNum">  186</span><span class="lineNoCov">      0  /   1: 			fd = ::open(debug_file.c_str(), O_RDONLY, 0); </span>
<span class="lineNum">  187</span><span class="lineNoCov">      0  /   1: 			if (fd &lt; 0) { </span>
<span class="lineNum">  188</span>              : 				&#047;&#047; Some shared libraries have neither symbols nor build-id files </span>
<span class="lineNum">  189</span><span class="lineNoCov">      0  /   1: 				if (m_isMainFile) </span>
<span class="lineNum">  190</span><span class="lineNoCov">      0  /   1: 					error(&quot;Cannot open %s&#092;n&quot;, debug_file.c_str()); </span>
<span class="lineNum">  191</span><span class="lineNoCov">      0  /   1: 				return false; </span>
<span class="lineNum">  192</span>              : 			} </span>
<span class="lineNum">  193</span>              :  </span>
<span class="lineNum">  194</span><span class="lineNoCov">      0  /   2: 			dbg = dwarf_begin(fd, DWARF_C_READ); </span>
<span class="lineNum">  195</span>              : 		} </span>
<span class="lineNum">  196</span>              :  </span>
<span class="lineNum">  197</span><span class="lineNoCov">      0  /   1: 		if (!dbg) { </span>
<span class="lineNum">  198</span><span class="lineNoCov">      0  /   1: 			kcov_debug(ELF_MSG, &quot;No debug symbols in %s.&#092;n&quot;, m_filename.c_str()); </span>
<span class="lineNum">  199</span><span class="lineNoCov">      0  /   1: 			close(fd); </span>
<span class="lineNum">  200</span><span class="lineNoCov">      0  /   1: 			return false; </span>
<span class="lineNum">  201</span>              : 		} </span>
<span class="lineNum">  202</span>              :  </span>
<span class="lineNum">  203</span>              : 		&#047;* Iterate over the headers *&#047; </span>
<span class="lineNum">  204</span><span class="lineNoCov">      0  /   2: 		while (dwarf_nextcu(dbg, offset, &amp;offset, &amp;hdr_size, 0, 0, 0) == 0) { </span>
<span class="lineNum">  205</span>              : 			Dwarf_Lines* line_buffer; </span>
<span class="lineNum">  206</span>              : 			Dwarf_Files *file_buffer; </span>
<span class="lineNum">  207</span>              : 			size_t line_count; </span>
<span class="lineNum">  208</span>              : 			size_t file_count; </span>
<span class="lineNum">  209</span>              : 			Dwarf_Die die; </span>
<span class="lineNum">  210</span>              : 			unsigned int i; </span>
<span class="lineNum">  211</span>              :  </span>
<span class="lineNum">  212</span><span class="lineNoCov">      0  /   1: 			if (dwarf_offdie(dbg, last_offset + hdr_size, &amp;die) == nullptr) </span>
<span class="lineNum">  213</span><span class="lineNoCov">      0  /   2: 				goto out_err; </span>
<span class="lineNum">  214</span>              :  </span>
<span class="lineNum">  215</span><span class="lineNoCov">      0  /   1: 			last_offset = offset; </span>
<span class="lineNum">  216</span>              :  </span>
<span class="lineNum">  217</span>              : 			&#047;* Get the source lines *&#047; </span>
<span class="lineNum">  218</span><span class="lineNoCov">      0  /   1: 			if (dwarf_getsrclines(&amp;die, &amp;line_buffer, &amp;line_count) != 0) </span>
<span class="lineNum">  219</span><span class="lineNoCov">      0  /   1: 				continue; </span>
<span class="lineNum">  220</span>              :  </span>
<span class="lineNum">  221</span>              : 			&#047;* And the files *&#047; </span>
<span class="lineNum">  222</span><span class="lineNoCov">      0  /   1: 			if (dwarf_getsrcfiles(&amp;die, &amp;file_buffer, &amp;file_count) != 0) </span>
<span class="lineNum">  223</span><span class="lineNoCov">      0  /   1: 				continue; </span>
<span class="lineNum">  224</span>              :  </span>
<span class="lineNum">  225</span>              : 			&#047;* Store them *&#047; </span>
<span class="lineNum">  226</span><span class="lineNoCov">      0  /   2: 			for (i = 0; i &lt; line_count; i++) { </span>
<span class="lineNum">  227</span>              : 				Dwarf_Line *line; </span>
<span class="lineNum">  228</span>              : 				int line_nr; </span>
<span class="lineNum">  229</span>              : 				const char* line_source; </span>
<span class="lineNum">  230</span>              : 				Dwarf_Word mtime, len; </span>
<span class="lineNum">  231</span>              : 				bool is_code; </span>
<span class="lineNum">  232</span>              : 				Dwarf_Addr addr; </span>
<span class="lineNum">  233</span>              :  </span>
<span class="lineNum">  234</span><span class="lineNoCov">      0  /   1: 				if ( !(line = dwarf_onesrcline(line_buffer, i)) ) </span>
<span class="lineNum">  235</span><span class="lineNoCov">      0  /   1: 					goto out_err; </span>
<span class="lineNum">  236</span><span class="lineNoCov">      0  /   1: 				if (dwarf_lineno(line, &amp;line_nr) != 0) </span>
<span class="lineNum">  237</span><span class="lineNoCov">      0  /   1: 					goto out_err; </span>
<span class="lineNum">  238</span><span class="lineNoCov">      0  /   1: 				if (!(line_source = dwarf_linesrc(line, &amp;mtime, &amp;len)) ) </span>
<span class="lineNum">  239</span><span class="lineNoCov">      0  /   1: 					goto out_err; </span>
<span class="lineNum">  240</span><span class="lineNoCov">      0  /   1: 				if (dwarf_linebeginstatement(line, &amp;is_code) != 0) </span>
<span class="lineNum">  241</span><span class="lineNoCov">      0  /   1: 					goto out_err; </span>
<span class="lineNum">  242</span>              :  </span>
<span class="lineNum">  243</span><span class="lineNoCov">      0  /   1: 				if (dwarf_lineaddr(line, &amp;addr) != 0) </span>
<span class="lineNum">  244</span><span class="lineNoCov">      0  /   1: 					goto out_err; </span>
<span class="lineNum">  245</span>              :  </span>
<span class="lineNum">  246</span><span class="lineNoCov">      0  /   1: 				if (line_nr &amp;&amp; is_code) { </span>
<span class="lineNum">  247</span>              : 					const char *const *src_dirs; </span>
<span class="lineNum">  248</span>              : 					const char *full_file_path; </span>
<span class="lineNum">  249</span><span class="lineNoCov">      0  /   1: 					const char *file_path = line_source; </span>
<span class="lineNum">  250</span><span class="lineNoCov">      0  /   1: 					size_t ndirs = 0; </span>
<span class="lineNum">  251</span>              :  </span>
<span class="lineNum">  252</span>              : 					&#047;* Lookup the compilation path *&#047; </span>
<span class="lineNum">  253</span><span class="lineNoCov">      0  /   1: 					if (dwarf_getsrcdirs(file_buffer, &amp;src_dirs, &amp;ndirs) != 0) </span>
<span class="lineNum">  254</span><span class="lineNoCov">      0  /   1: 						continue; </span>
<span class="lineNum">  255</span>              :  </span>
<span class="lineNum">  256</span><span class="lineNoCov">      0  /   1: 					if (ndirs == 0) </span>
<span class="lineNum">  257</span><span class="lineNoCov">      0  /   1: 						continue; </span>
<span class="lineNum">  258</span>              :  </span>
<span class="lineNum">  259</span><span class="lineNoCov">      0  /   1: 					if (!addressIsValid(addr)) </span>
<span class="lineNum">  260</span><span class="lineNoCov">      0  /   1: 						continue; </span>
<span class="lineNum">  261</span>              :  </span>
<span class="lineNum">  262</span>              : 					&#047;* Use the full compilation path unless the source already </span>
<span class="lineNum">  263</span>              : 					 * has an absolute path *&#047; </span>
<span class="lineNum">  264</span><span class="lineNoCov">      0  /   1: 					full_file_path = dir_concat(src_dirs[0], line_source); </span>
<span class="lineNum">  265</span><span class="lineNoCov">      0  /   1: 					if (line_source[0] != &#039;&#047;&#039;) </span>
<span class="lineNum">  266</span><span class="lineNoCov">      0  /   1: 						file_path = full_file_path; </span>
<span class="lineNum">  267</span>              :  </span>
<span class="lineNum">  268</span>              : 					&#047;******** replace the path information found in the debug symbols with *********&#047; </span>
<span class="lineNum">  269</span>              : 					&#047;******** the value from in the newRoot variable.         *********&#047; </span>
<span class="lineNum">  270</span><span class="lineNoCov">      0  /   1: 					char *rp = 0; </span>
<span class="lineNum">  271</span><span class="lineNoCov">      0  /   1: 					if (origRoot.length() &gt; 0 &amp;&amp; newRoot.length() &gt; 0) { </span>
<span class="lineNum">  272</span><span class="lineNoCov">      0  /   1:  					  std::string dwarfPath = file_path; </span>
<span class="lineNum">  273</span><span class="lineNoCov">      0  /   1: 					  size_t dwIndex = dwarfPath.find(origRoot); </span>
<span class="lineNum">  274</span><span class="lineNoCov">      0  /   1: 					  if (dwIndex != std::string::npos) { </span>
<span class="lineNum">  275</span><span class="lineNoCov">      0  /   1: 					    dwarfPath.replace(dwIndex, origRoot.length(), newRoot); </span>
<span class="lineNum">  276</span><span class="lineNoCov">      0  /   1: 					    rp = ::realpath(dwarfPath.c_str(), nullptr); </span>
<span class="lineNum">  277</span>              :  </span>
<span class="lineNum">  278</span><span class="lineNoCov">      0  /   2: 					  } </span>
<span class="lineNum">  279</span>              : 					} </span>
<span class="lineNum">  280</span>              : 					else { </span>
<span class="lineNum">  281</span><span class="lineNoCov">      0  /   1: 					  rp = ::realpath(file_path, nullptr); </span>
<span class="lineNum">  282</span>              : 					} </span>
<span class="lineNum">  283</span><span class="lineNoCov">      0  /   1: 					if (rp) </span>
<span class="lineNum">  284</span>              : 					{ </span>
<span class="lineNum">  285</span><span class="lineNoCov">      0  /   1: 						free((void *)full_file_path); </span>
<span class="lineNum">  286</span><span class="lineNoCov">      0  /   1: 						file_path = full_file_path = rp; </span>
<span class="lineNum">  287</span>              :  </span>
<span class="lineNum">  288</span>              : 					} </span>
<span class="lineNum">  289</span>              :  </span>
<span class="lineNum">  290</span><span class="lineNoCov">      0  /   2: 					for (const auto &amp;it : m_lineListeners) </span>
<span class="lineNum">  291</span><span class="lineNoCov">      0  /   1: 						it-&gt;onLine(file_path, line_nr, adjustAddressBySegment(addr)); </span>
<span class="lineNum">  292</span>              :  </span>
<span class="lineNum">  293</span><span class="lineNoCov">      0  /   1: 					free((void *)full_file_path); </span>
<span class="lineNum">  294</span>              : 				} </span>
<span class="lineNum">  295</span>              : 			} </span>
<span class="lineNum">  296</span>              : 		} </span>
<span class="lineNum">  297</span>              :  </span>
<span class="lineNum">  298</span>              : out_err: </span>
<span class="lineNum">  299</span>              : 		&#047;* Shutdown libdwarf *&#047; </span>
<span class="lineNum">  300</span><span class="lineNoCov">      0  /   1: 		if (dwarf_end(dbg) != 0) </span>
<span class="lineNum">  301</span><span class="lineNoCov">      0  /   1: 			goto out_err; </span>
<span class="lineNum">  302</span>              :  </span>
<span class="lineNum">  303</span><span class="lineNoCov">      0  /   1: 		close(fd); </span>
<span class="lineNum">  304</span>              :  </span>
<span class="lineNum">  305</span><span class="lineNoCov">      0  /   1: 		return true; </span>
<span class="lineNum">  306</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">  307</span>              :  </span>
<span class="lineNum">  308</span><span class="lineNoCov">      0  /   1: 	bool parseOneElf() </span>
<span class="lineNum">  309</span>              : 	{ </span>
<span class="lineNum">  310</span><span class="lineNoCov">      0  /   1: 		Elf_Scn *scn = nullptr; </span>
<span class="lineNum">  311</span>              : 		size_t shstrndx; </span>
<span class="lineNum">  312</span><span class="lineNoCov">      0  /   1: 		bool ret = false; </span>
<span class="lineNum">  313</span><span class="lineNoCov">      0  /   1: 		bool setupSegments = false; </span>
<span class="lineNum">  314</span>              : 		int fd; </span>
<span class="lineNum">  315</span>              : 		unsigned int i; </span>
<span class="lineNum">  316</span>              :  </span>
<span class="lineNum">  317</span><span class="lineNoCov">      0  /   1: 		fd = ::open(m_filename.c_str(), O_RDONLY, 0); </span>
<span class="lineNum">  318</span><span class="lineNoCov">      0  /   1: 		if (fd &lt; 0) { </span>
<span class="lineNum">  319</span><span class="lineNoCov">      0  /   1: 				error(&quot;Cannot open %s&#092;n&quot;, m_filename.c_str()); </span>
<span class="lineNum">  320</span><span class="lineNoCov">      0  /   1: 				return false; </span>
<span class="lineNum">  321</span>              : 		} </span>
<span class="lineNum">  322</span>              :  </span>
<span class="lineNum">  323</span><span class="lineNoCov">      0  /   1: 		if (!(m_elf = elf_begin(fd, ELF_C_READ, nullptr)) ) { </span>
<span class="lineNum">  324</span><span class="lineNoCov">      0  /   1: 				error(&quot;elf_begin failed on %s&#092;n&quot;, m_filename.c_str()); </span>
<span class="lineNum">  325</span><span class="lineNoCov">      0  /   1: 				goto out_open; </span>
<span class="lineNum">  326</span>              : 		} </span>
<span class="lineNum">  327</span>              :  </span>
<span class="lineNum">  328</span><span class="lineNoCov">      0  /   1: 		if (elf_getshdrstrndx(m_elf, &amp;shstrndx) &lt; 0) { </span>
<span class="lineNum">  329</span><span class="lineNoCov">      0  /   1: 				error(&quot;elf_getshstrndx failed on %s&#092;n&quot;, m_filename.c_str()); </span>
<span class="lineNum">  330</span><span class="lineNoCov">      0  /   1: 				goto out_elf_begin; </span>
<span class="lineNum">  331</span>              : 		} </span>
<span class="lineNum">  332</span>              :  </span>
<span class="lineNum">  333</span><span class="lineNoCov">      0  /   1: 		setupSegments = m_curSegments.size() == 0; </span>
<span class="lineNum">  334</span><span class="lineNoCov">      0  /   2: 		while ( (scn = elf_nextscn(m_elf, scn)) != nullptr ) </span>
<span class="lineNum">  335</span>              : 		{ </span>
<span class="lineNum">  336</span>              : 			uint64_t sh_type; </span>
<span class="lineNum">  337</span>              : 			uint64_t sh_addr; </span>
<span class="lineNum">  338</span>              : 			uint64_t sh_size; </span>
<span class="lineNum">  339</span>              : 			uint64_t sh_flags; </span>
<span class="lineNum">  340</span>              : 			uint64_t sh_name; </span>
<span class="lineNum">  341</span>              : 			uint64_t n_namesz; </span>
<span class="lineNum">  342</span>              : 			uint64_t n_descsz; </span>
<span class="lineNum">  343</span>              : 			uint64_t n_type; </span>
<span class="lineNum">  344</span>              : 			char *n_data; </span>
<span class="lineNum">  345</span>              : 			char *name; </span>
<span class="lineNum">  346</span>              :  </span>
<span class="lineNum">  347</span><span class="lineNoCov">      0  /   1: 			if (m_elfIs32Bit) { </span>
<span class="lineNum">  348</span><span class="lineNoCov">      0  /   1: 				Elf32_Shdr *shdr32 = elf32_getshdr(scn); </span>
<span class="lineNum">  349</span>              :  </span>
<span class="lineNum">  350</span><span class="lineNoCov">      0  /   1: 				sh_type = shdr32-&gt;sh_type; </span>
<span class="lineNum">  351</span><span class="lineNoCov">      0  /   1: 				sh_addr = shdr32-&gt;sh_addr; </span>
<span class="lineNum">  352</span><span class="lineNoCov">      0  /   1: 				sh_size = shdr32-&gt;sh_size; </span>
<span class="lineNum">  353</span><span class="lineNoCov">      0  /   1: 				sh_flags = shdr32-&gt;sh_flags; </span>
<span class="lineNum">  354</span><span class="lineNoCov">      0  /   1: 				sh_name = shdr32-&gt;sh_name; </span>
<span class="lineNum">  355</span>              : 			} else { </span>
<span class="lineNum">  356</span><span class="lineNoCov">      0  /   1: 				Elf64_Shdr *shdr64 = elf64_getshdr(scn); </span>
<span class="lineNum">  357</span>              :  </span>
<span class="lineNum">  358</span><span class="lineNoCov">      0  /   1: 				sh_type = shdr64-&gt;sh_type; </span>
<span class="lineNum">  359</span><span class="lineNoCov">      0  /   1: 				sh_addr = shdr64-&gt;sh_addr; </span>
<span class="lineNum">  360</span><span class="lineNoCov">      0  /   1: 				sh_size = shdr64-&gt;sh_size; </span>
<span class="lineNum">  361</span><span class="lineNoCov">      0  /   1: 				sh_flags = shdr64-&gt;sh_flags; </span>
<span class="lineNum">  362</span><span class="lineNoCov">      0  /   1: 				sh_name = shdr64-&gt;sh_name; </span>
<span class="lineNum">  363</span>              : 			} </span>
<span class="lineNum">  364</span>              :  </span>
<span class="lineNum">  365</span><span class="lineNoCov">      0  /   1: 			Elf_Data *data = elf_getdata(scn, nullptr); </span>
<span class="lineNum">  366</span>              :  </span>
<span class="lineNum">  367</span><span class="lineNoCov">      0  /   1: 			name = elf_strptr(m_elf, shstrndx, sh_name); </span>
<span class="lineNum">  368</span><span class="lineNoCov">      0  /   1: 			if(!data) { </span>
<span class="lineNum">  369</span><span class="lineNoCov">      0  /   1: 					error(&quot;elf_getdata failed on section %s in %s&#092;n&quot;, </span>
<span class="lineNum">  370</span>              : 							name, m_filename.c_str()); </span>
<span class="lineNum">  371</span><span class="lineNoCov">      0  /   1: 					goto out_elf_begin; </span>
<span class="lineNum">  372</span>              : 			} </span>
<span class="lineNum">  373</span>              :  </span>
<span class="lineNum">  374</span><span class="lineNoCov">      0  /   1: 			if (sh_type == SHT_NOTE) { </span>
<span class="lineNum">  375</span><span class="lineNoCov">      0  /   1: 				if (m_elfIs32Bit) { </span>
<span class="lineNum">  376</span><span class="lineNoCov">      0  /   1: 					Elf32_Nhdr *nhdr32 = (Elf32_Nhdr *)data-&gt;d_buf; </span>
<span class="lineNum">  377</span>              :  </span>
<span class="lineNum">  378</span><span class="lineNoCov">      0  /   1: 					n_namesz = nhdr32-&gt;n_namesz; </span>
<span class="lineNum">  379</span><span class="lineNoCov">      0  /   1: 					n_descsz = nhdr32-&gt;n_descsz; </span>
<span class="lineNum">  380</span><span class="lineNoCov">      0  /   1: 					n_type = nhdr32-&gt;n_type; </span>
<span class="lineNum">  381</span><span class="lineNoCov">      0  /   1: 					n_data = (char *)data-&gt;d_buf + sizeof (Elf32_Nhdr); </span>
<span class="lineNum">  382</span>              : 				} else { </span>
<span class="lineNum">  383</span><span class="lineNoCov">      0  /   1: 					Elf64_Nhdr *nhdr64 = (Elf64_Nhdr *)data-&gt;d_buf; </span>
<span class="lineNum">  384</span>              :  </span>
<span class="lineNum">  385</span><span class="lineNoCov">      0  /   1: 					n_namesz = nhdr64-&gt;n_namesz; </span>
<span class="lineNum">  386</span><span class="lineNoCov">      0  /   1: 					n_descsz = nhdr64-&gt;n_descsz; </span>
<span class="lineNum">  387</span><span class="lineNoCov">      0  /   1: 					n_type = nhdr64-&gt;n_type; </span>
<span class="lineNum">  388</span><span class="lineNoCov">      0  /   1: 					n_data = (char *)data-&gt;d_buf + sizeof (Elf64_Nhdr); </span>
<span class="lineNum">  389</span>              : 				} </span>
<span class="lineNum">  390</span>              :  </span>
<span class="lineNum">  391</span><span class="lineNoCov">      0  /   1: 				if (::strcmp(n_data, ELF_NOTE_GNU) == 0 &amp;&amp; </span>
<span class="lineNum">  392</span>              : 				    n_type == NT_GNU_BUILD_ID) { </span>
<span class="lineNum">  393</span><span class="lineNoCov">      0  /   1: 					const char *hex_digits = &quot;0123456789abcdef&quot;; </span>
<span class="lineNum">  394</span>              : 					unsigned char *build_id; </span>
<span class="lineNum">  395</span>              :  </span>
<span class="lineNum">  396</span><span class="lineNoCov">      0  /   1: 					build_id = (unsigned char *)n_data + n_namesz; </span>
<span class="lineNum">  397</span><span class="lineNoCov">      0  /   2: 					for (i = 0; i &lt; n_descsz; i++) { </span>
<span class="lineNum">  398</span><span class="lineNoCov">      0  /   1: 						m_buildId.push_back(hex_digits[(build_id[i] &gt;&gt; 4) &amp; 0xf]); </span>
<span class="lineNum">  399</span><span class="lineNoCov">      0  /   1: 						m_buildId.push_back(hex_digits[(build_id[i] &gt;&gt; 0) &amp; 0xf]); </span>
<span class="lineNum">  400</span>              : 					} </span>
<span class="lineNum">  401</span>              : 				} </span>
<span class="lineNum">  402</span>              : 			} </span>
<span class="lineNum">  403</span>              :  </span>
<span class="lineNum">  404</span><span class="lineNoCov">      0  /   1: 			if ((sh_flags &amp; (SHF_EXECINSTR | SHF_ALLOC)) != (SHF_EXECINSTR | SHF_ALLOC)) </span>
<span class="lineNum">  405</span><span class="lineNoCov">      0  /   1: 				continue; </span>
<span class="lineNum">  406</span>              :  </span>
<span class="lineNum">  407</span>              : 			&#047;&#047; If we have segments already, we can safely skip this </span>
<span class="lineNum">  408</span><span class="lineNoCov">      0  /   1: 			if (setupSegments) </span>
<span class="lineNum">  409</span><span class="lineNoCov">      0  /   1: 				m_curSegments.push_back(Segment(sh_addr, sh_addr, sh_size)); </span>
<span class="lineNum">  410</span><span class="lineNoCov">      0  /   1: 			m_executableSegments.push_back(Segment(sh_addr, sh_addr, sh_size)); </span>
<span class="lineNum">  411</span>              : 		} </span>
<span class="lineNum">  412</span><span class="lineNoCov">      0  /   1: 		elf_end(m_elf); </span>
<span class="lineNum">  413</span><span class="lineNoCov">      0  /   1: 		if (!(m_elf = elf_begin(fd, ELF_C_READ, nullptr)) ) { </span>
<span class="lineNum">  414</span><span class="lineNoCov">      0  /   1: 			error(&quot;elf_begin failed on %s&#092;n&quot;, m_filename.c_str()); </span>
<span class="lineNum">  415</span><span class="lineNoCov">      0  /   1: 			goto out_open; </span>
<span class="lineNum">  416</span>              : 		} </span>
<span class="lineNum">  417</span>              :  </span>
<span class="lineNum">  418</span><span class="lineNoCov">      0  /   1: 		ret = true; </span>
<span class="lineNum">  419</span>              :  </span>
<span class="lineNum">  420</span>              : out_elf_begin: </span>
<span class="lineNum">  421</span><span class="lineNoCov">      0  /   1: 		elf_end(m_elf); </span>
<span class="lineNum">  422</span>              : out_open: </span>
<span class="lineNum">  423</span><span class="lineNoCov">      0  /   1: 		close(fd); </span>
<span class="lineNum">  424</span>              :  </span>
<span class="lineNum">  425</span><span class="lineNoCov">      0  /   1: 		return ret; </span>
<span class="lineNum">  426</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">  427</span>              :  </span>
<span class="lineNum">  428</span><span class="lineNoCov">      0  /   1: 	void registerLineListener(ILineListener &amp;listener) </span>
<span class="lineNum">  429</span>              : 	{ </span>
<span class="lineNum">  430</span><span class="lineNoCov">      0  /   1: 		m_lineListeners.push_back(&amp;listener); </span>
<span class="lineNum">  431</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">  432</span>              :  </span>
<span class="lineNum">  433</span><span class="lineNoCov">      0  /   1: 	void registerFileListener(IFileListener &amp;listener) </span>
<span class="lineNum">  434</span>              : 	{ </span>
<span class="lineNum">  435</span><span class="lineNoCov">      0  /   1: 		m_fileListeners.push_back(&amp;listener); </span>
<span class="lineNum">  436</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">  437</span>              :  </span>
<span class="lineNum">  438</span>              : private: </span>
<span class="lineNum">  439</span>              : 	class Segment </span>
<span class="lineNum">  440</span>              : 	{ </span>
<span class="lineNum">  441</span>              : 	public: </span>
<span class="lineNum">  442</span><span class="lineNoCov">      0  /   1: 		Segment(uint64_t paddr, uint64_t vaddr, uint64_t size) : </span>
<span class="lineNum">  443</span><span class="lineNoCov">      0  /   1: 			m_paddr(paddr), m_vaddr(vaddr), m_size(size) </span>
<span class="lineNum">  444</span>              : 		{ </span>
<span class="lineNum">  445</span><span class="lineNoCov">      0  /   2: 		} </span>
<span class="lineNum">  446</span>              :  </span>
<span class="lineNum">  447</span>              : 		uint64_t m_paddr; </span>
<span class="lineNum">  448</span>              : 		uint64_t m_vaddr; </span>
<span class="lineNum">  449</span>              : 		size_t m_size; </span>
<span class="lineNum">  450</span>              : 	}; </span>
<span class="lineNum">  451</span>              :  </span>
<span class="lineNum">  452</span>              : 	typedef std::list&lt;Segment&gt; SegmentList_t; </span>
<span class="lineNum">  453</span>              : 	typedef std::list&lt;ILineListener *&gt; LineListenerList_t; </span>
<span class="lineNum">  454</span>              : 	typedef std::list&lt;IFileListener *&gt; FileListenerList_t; </span>
<span class="lineNum">  455</span>              :  </span>
<span class="lineNum">  456</span><span class="lineNoCov">      0  /   1: 	bool addressIsValid(uint64_t addr) </span>
<span class="lineNum">  457</span>              : 	{ </span>
<span class="lineNum">  458</span><span class="lineNoCov">      0  /   2: 		for (const auto &amp;it : m_executableSegments) { </span>
<span class="lineNum">  459</span><span class="lineNoCov">      0  /   1: 			if (addr &gt;= it.m_paddr &amp;&amp; addr &lt; it.m_paddr + it.m_size) { </span>
<span class="lineNum">  460</span><span class="lineNoCov">      0  /   1: 				return true; </span>
<span class="lineNum">  461</span>              : 			} </span>
<span class="lineNum">  462</span>              : 		} </span>
<span class="lineNum">  463</span>              :  </span>
<span class="lineNum">  464</span><span class="lineNoCov">      0  /   1: 		return false; </span>
<span class="lineNum">  465</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">  466</span>              :  </span>
<span class="lineNum">  467</span><span class="lineNoCov">      0  /   1: 	uint64_t adjustAddressBySegment(uint64_t addr) </span>
<span class="lineNum">  468</span>              : 	{ </span>
<span class="lineNum">  469</span><span class="lineNoCov">      0  /   2: 		for (const auto &amp;it : m_curSegments) { </span>
<span class="lineNum">  470</span><span class="lineNoCov">      0  /   1: 			if (addr &gt;= it.m_paddr &amp;&amp; addr &lt; it.m_paddr + it.m_size) { </span>
<span class="lineNum">  471</span><span class="lineNoCov">      0  /   1: 				addr = (addr - it.m_paddr + it.m_vaddr); </span>
<span class="lineNum">  472</span><span class="lineNoCov">      0  /   1: 				break; </span>
<span class="lineNum">  473</span>              : 			} </span>
<span class="lineNum">  474</span>              : 		} </span>
<span class="lineNum">  475</span>              :  </span>
<span class="lineNum">  476</span><span class="lineNoCov">      0  /   1: 		return addr; </span>
<span class="lineNum">  477</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">  478</span>              :  </span>
<span class="lineNum">  479</span>              : 	SegmentList_t m_curSegments; </span>
<span class="lineNum">  480</span>              : 	SegmentList_t m_executableSegments; </span>
<span class="lineNum">  481</span>              :  </span>
<span class="lineNum">  482</span>              : 	struct Elf *m_elf; </span>
<span class="lineNum">  483</span>              : 	bool m_elfIs32Bit; </span>
<span class="lineNum">  484</span>              : 	LineListenerList_t m_lineListeners; </span>
<span class="lineNum">  485</span>              : 	FileListenerList_t m_fileListeners; </span>
<span class="lineNum">  486</span>              : 	std::string m_filename; </span>
<span class="lineNum">  487</span>              : 	std::string m_buildId; </span>
<span class="lineNum">  488</span>              : 	bool m_isMainFile; </span>
<span class="lineNum">  489</span>              : 	uint64_t m_checksum; </span>
<span class="lineNum">  490</span>              : 	bool m_initialized; </span>
<span class="lineNum">  491</span>              :  </span>
<span class="lineNum">  492</span>              : 	&#047;***** Add strings to update path information. *******&#047; </span>
<span class="lineNum">  493</span>              : 	std::string origRoot; </span>
<span class="lineNum">  494</span>              : 	std::string newRoot; </span>
<span class="lineNum">  495</span>              :  </span>
<span class="lineNum">  496</span>              : }; </span>
<span class="lineNum">  497</span>              :  </span>
<span class="lineNum">  498</span><span class="linePartCov">      4  /   5: static ElfInstance g_instance; </span>
</pre>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr><td class="versionInfo">Generated by: <a href="http://simonkagstrom.github.com/kcov/index.html">Kcov</a></td></tr>
</table>
<br/>
</body>
</html>
