<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Coverage - kcov</title>
  <link rel="stylesheet" type="text/css" href="bcov.css"/>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="title">Coverage Report</td></tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr>
    <td width="100%">
      <table cellpadding="1" border="0" width="100%">
        <tr>
          <td class="headerItem" width="20%">Command:</td>
          <td class="headerValue" width="80%" colspan=6>kcov</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Date:</td>
          <td class="headerValue" width="15%">2014-03-01 10:11:51</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Instrumented&nbsp;lines:</td>
          <td class="headerValue" width="10%">320</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Code&nbsp;covered:</td>
          <td class="coverPerLeftLo" width="15%">3.8%</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Executed&nbsp;lines:</td>
          <td class="headerValue" width="10%">12</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
</table>
<pre class="source">
<span class="lineNum">    1</span>              : #include &lt;engine.hh&gt; </span>
<span class="lineNum">    2</span>              : #include &lt;utils.hh&gt; </span>
<span class="lineNum">    3</span>              : #include &lt;configuration.hh&gt; </span>
<span class="lineNum">    4</span>              : #include &lt;output-handler.hh&gt; </span>
<span class="lineNum">    5</span>              : #include &lt;file-parser.hh&gt; </span>
<span class="lineNum">    6</span>              : #include &lt;phdr_data.h&gt; </span>
<span class="lineNum">    7</span>              :  </span>
<span class="lineNum">    8</span>              : #include &lt;unistd.h&gt; </span>
<span class="lineNum">    9</span>              : #include &lt;sys&#047;ptrace.h&gt; </span>
<span class="lineNum">   10</span>              : #include &lt;sys&#047;user.h&gt; </span>
<span class="lineNum">   11</span>              : #include &lt;sys&#047;types.h&gt; </span>
<span class="lineNum">   12</span>              : #include &lt;sys&#047;stat.h&gt; </span>
<span class="lineNum">   13</span>              : #include &lt;sys&#047;wait.h&gt; </span>
<span class="lineNum">   14</span>              : #include &lt;libelf.h&gt; </span>
<span class="lineNum">   15</span>              : #include &lt;signal.h&gt; </span>
<span class="lineNum">   16</span>              : #include &lt;fcntl.h&gt; </span>
<span class="lineNum">   17</span>              : #include &lt;sched.h&gt; </span>
<span class="lineNum">   18</span>              : #include &lt;pthread.h&gt; </span>
<span class="lineNum">   19</span>              : #include &lt;map&gt; </span>
<span class="lineNum">   20</span>              : #include &lt;unordered_map&gt; </span>
<span class="lineNum">   21</span>              : #include &lt;list&gt; </span>
<span class="lineNum">   22</span>              : #include &lt;mutex&gt; </span>
<span class="lineNum">   23</span>              :  </span>
<span class="lineNum">   24</span>              : #include &quot;..&#047;library-binary.h&quot; </span>
<span class="lineNum">   25</span>              :  </span>
<span class="lineNum">   26</span>              : using namespace kcov; </span>
<span class="lineNum">   27</span>              :  </span>
<span class="lineNum">   28</span>              : #define str(s) #s </span>
<span class="lineNum">   29</span>              : #define xstr(s) str(s) </span>
<span class="lineNum">   30</span>              :  </span>
<span class="lineNum">   31</span>              : enum </span>
<span class="lineNum">   32</span>              : { </span>
<span class="lineNum">   33</span>              : 	i386_EIP = 12, </span>
<span class="lineNum">   34</span>              : 	x86_64_RIP = 16, </span>
<span class="lineNum">   35</span>              : 	ppc_NIP = 32, </span>
<span class="lineNum">   36</span>              : 	arm_PC = 15, </span>
<span class="lineNum">   37</span>              : }; </span>
<span class="lineNum">   38</span>              :  </span>
<span class="lineNum">   39</span>              : static unsigned long getAligned(unsigned long addr) </span>
<span class="lineNum">   40</span><span class="lineNoCov">      0  /   1: { </span>
<span class="lineNum">   41</span><span class="lineNoCov">      0  /   1: 	return (addr &#047; sizeof(unsigned long)) * sizeof(unsigned long); </span>
<span class="lineNum">   42</span><span class="lineNoCov">      0  /   1: } </span>
<span class="lineNum">   43</span>              :  </span>
<span class="lineNum">   44</span>              : static unsigned long arch_getPcFromRegs(unsigned long *regs) </span>
<span class="lineNum">   45</span><span class="lineNoCov">      0  /   1: { </span>
<span class="lineNum">   46</span>              : 	unsigned long out; </span>
<span class="lineNum">   47</span>              :  </span>
<span class="lineNum">   48</span>              : #if defined(__i386__) </span>
<span class="lineNum">   49</span>              : 	out = regs[i386_EIP] - 1; </span>
<span class="lineNum">   50</span>              : #elif defined(__x86_64__) </span>
<span class="lineNum">   51</span><span class="lineNoCov">      0  /   1: 	out = regs[x86_64_RIP] - 1; </span>
<span class="lineNum">   52</span>              : #elif defined(__arm__) </span>
<span class="lineNum">   53</span>              : 	out = regs[arm_PC] - 4; </span>
<span class="lineNum">   54</span>              : #elif defined(__powerpc__) </span>
<span class="lineNum">   55</span>              : 	out = regs[ppc_NIP]; </span>
<span class="lineNum">   56</span>              : #else </span>
<span class="lineNum">   57</span>              : # error Unsupported architecture </span>
<span class="lineNum">   58</span>              : #endif </span>
<span class="lineNum">   59</span>              :  </span>
<span class="lineNum">   60</span><span class="lineNoCov">      0  /   1: 	return out; </span>
<span class="lineNum">   61</span><span class="lineNoCov">      0  /   1: } </span>
<span class="lineNum">   62</span>              :  </span>
<span class="lineNum">   63</span>              : static void arch_adjustPcAfterBreakpoint(unsigned long *regs) </span>
<span class="lineNum">   64</span><span class="lineNoCov">      0  /   1: { </span>
<span class="lineNum">   65</span>              : #if defined(__i386__) </span>
<span class="lineNum">   66</span>              : 	regs[i386_EIP]--; </span>
<span class="lineNum">   67</span>              : #elif defined(__x86_64__) </span>
<span class="lineNum">   68</span><span class="lineNoCov">      0  /   1: 	regs[x86_64_RIP]--; </span>
<span class="lineNum">   69</span>              : #elif defined(__arm__) </span>
<span class="lineNum">   70</span>              : 	regs[arm_PC] -= 4; </span>
<span class="lineNum">   71</span>              : #elif defined(__powerpc__) </span>
<span class="lineNum">   72</span>              : 	&#047;&#047; Do nothing </span>
<span class="lineNum">   73</span>              : #else </span>
<span class="lineNum">   74</span>              : # error Unsupported architecture </span>
<span class="lineNum">   75</span>              : #endif </span>
<span class="lineNum">   76</span><span class="lineNoCov">      0  /   1: } </span>
<span class="lineNum">   77</span>              :  </span>
<span class="lineNum">   78</span>              :  </span>
<span class="lineNum">   79</span>              : static unsigned long arch_setupBreakpoint(unsigned long addr, unsigned long old_data) </span>
<span class="lineNum">   80</span><span class="lineNoCov">      0  /   1: { </span>
<span class="lineNum">   81</span>              : 	unsigned long val; </span>
<span class="lineNum">   82</span>              :  </span>
<span class="lineNum">   83</span>              : #if defined(__i386__) || defined(__x86_64__) </span>
<span class="lineNum">   84</span><span class="lineNoCov">      0  /   1: 	unsigned long aligned_addr = getAligned(addr); </span>
<span class="lineNum">   85</span><span class="lineNoCov">      0  /   1: 	unsigned long offs = addr - aligned_addr; </span>
<span class="lineNum">   86</span><span class="lineNoCov">      0  /   1: 	unsigned long shift = 8 * offs; </span>
<span class="lineNum">   87</span>              :  </span>
<span class="lineNum">   88</span><span class="lineNoCov">      0  /   1: 	val = (old_data &amp; ~(0xffUL &lt;&lt; shift)) | </span>
<span class="lineNum">   89</span><span class="lineNoCov">      0  /   1: 			(0xccUL &lt;&lt; shift); </span>
<span class="lineNum">   90</span>              : #elif defined(__powerpc__) </span>
<span class="lineNum">   91</span>              : 	val =  0x7fe00008; &#047;* tw *&#047; </span>
<span class="lineNum">   92</span>              : #elif defined(__arm__) </span>
<span class="lineNum">   93</span>              : 	val = 0x123456; &#047;&#047;0xe1200070; &#047;* BKPT *&#047; </span>
<span class="lineNum">   94</span>              : #else </span>
<span class="lineNum">   95</span>              : # error Unsupported architecture </span>
<span class="lineNum">   96</span>              : #endif </span>
<span class="lineNum">   97</span>              :  </span>
<span class="lineNum">   98</span><span class="lineNoCov">      0  /   1: 	return val; </span>
<span class="lineNum">   99</span><span class="lineNoCov">      0  /   1: } </span>
<span class="lineNum">  100</span>              :  </span>
<span class="lineNum">  101</span>              : static unsigned long arch_clearBreakpoint(unsigned long addr, unsigned long old_data, unsigned long cur_data) </span>
<span class="lineNum">  102</span><span class="lineNoCov">      0  /   1: { </span>
<span class="lineNum">  103</span>              : 	unsigned long val; </span>
<span class="lineNum">  104</span>              : #if defined(__i386__) || defined(__x86_64__) </span>
<span class="lineNum">  105</span><span class="lineNoCov">      0  /   1: 	unsigned long aligned_addr = getAligned(addr); </span>
<span class="lineNum">  106</span><span class="lineNoCov">      0  /   1: 	unsigned long offs = addr - aligned_addr; </span>
<span class="lineNum">  107</span><span class="lineNoCov">      0  /   1: 	unsigned long shift = 8 * offs; </span>
<span class="lineNum">  108</span><span class="lineNoCov">      0  /   1: 	unsigned long old_byte = (old_data &gt;&gt; shift) &amp; 0xffUL; </span>
<span class="lineNum">  109</span>              :  </span>
<span class="lineNum">  110</span><span class="lineNoCov">      0  /   1: 	val = (cur_data &amp; ~(0xffUL &lt;&lt; shift)) | </span>
<span class="lineNum">  111</span><span class="lineNoCov">      0  /   1: 			(old_byte &lt;&lt; shift); </span>
<span class="lineNum">  112</span>              : #elif defined(__powerpc__) || defined(__arm__) </span>
<span class="lineNum">  113</span>              : 	val = old_data; </span>
<span class="lineNum">  114</span>              : #else </span>
<span class="lineNum">  115</span>              : # error Unsupported architecture </span>
<span class="lineNum">  116</span>              : #endif </span>
<span class="lineNum">  117</span>              :  </span>
<span class="lineNum">  118</span><span class="lineNoCov">      0  /   1: 	return val; </span>
<span class="lineNum">  119</span><span class="lineNoCov">      0  /   1: } </span>
<span class="lineNum">  120</span>              :  </span>
<span class="lineNum">  121</span>              :  </span>
<span class="lineNum">  122</span>              :  </span>
<span class="lineNum">  123</span><span class="linePartCov">      2  /   5: class Ptrace : public IEngine </span>
<span class="lineNum">  124</span>              : { </span>
<span class="lineNum">  125</span>              : public: </span>
<span class="lineNum">  126</span><span class="lineCov">      1  /   1: 	Ptrace() : </span>
<span class="lineNum">  127</span>              : 		m_breakpointId(0), </span>
<span class="lineNum">  128</span>              : 		m_firstBreakpoint(true), </span>
<span class="lineNum">  129</span>              : 		m_activeChild(0), </span>
<span class="lineNum">  130</span>              : 		m_child(0), </span>
<span class="lineNum">  131</span>              : 		m_firstChild(0), </span>
<span class="lineNum">  132</span>              : 		m_ldPreloadString(nullptr), </span>
<span class="lineNum">  133</span>              : 		m_envString(nullptr), </span>
<span class="lineNum">  134</span>              : 		m_parentCpu(0), </span>
<span class="lineNum">  135</span>              : 		m_solibFileOpen(false), </span>
<span class="lineNum">  136</span>              : 		m_elf(NULL), </span>
<span class="lineNum">  137</span>              : 		m_listener(NULL), </span>
<span class="lineNum">  138</span><span class="linePartCov">      1  /   2: 		m_signal(0) </span>
<span class="lineNum">  139</span>              : 	{ </span>
<span class="lineNum">  140</span><span class="lineCov">      1  /   1: 		memset(&amp;m_solibThread, 0, sizeof(m_solibThread)); </span>
<span class="lineNum">  141</span>              :  </span>
<span class="lineNum">  142</span><span class="lineCov">      1  /   1: 		IEngineFactory::getInstance().registerEngine(*this); </span>
<span class="lineNum">  143</span><span class="linePartCov">      2  /   3: 	} </span>
<span class="lineNum">  144</span>              :  </span>
<span class="lineNum">  145</span><span class="lineNoCov">      0  /   1: 	bool readMemory(unsigned long *dst, unsigned long addr) </span>
<span class="lineNum">  146</span>              : 	{ </span>
<span class="lineNum">  147</span><span class="lineNoCov">      0  /   1: 		*dst = peekWord(addr); </span>
<span class="lineNum">  148</span>              :  </span>
<span class="lineNum">  149</span><span class="lineNoCov">      0  /   1: 		return true; </span>
<span class="lineNum">  150</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">  151</span>              :  </span>
<span class="lineNum">  152</span>              :  </span>
<span class="lineNum">  153</span>              :  </span>
<span class="lineNum">  154</span><span class="lineNoCov">      0  /   1: 	bool start(IEventListener &amp;listener, const std::string &amp;executable) </span>
<span class="lineNum">  155</span>              : 	{ </span>
<span class="lineNum">  156</span><span class="lineNoCov">      0  /   1: 		m_listener = &amp;listener; </span>
<span class="lineNum">  157</span>              :  </span>
<span class="lineNum">  158</span><span class="lineNoCov">      0  /   1: 		m_parentCpu = kcov_get_current_cpu(); </span>
<span class="lineNum">  159</span><span class="lineNoCov">      0  /   1: 		kcov_tie_process_to_cpu(getpid(), m_parentCpu); </span>
<span class="lineNum">  160</span>              :  </span>
<span class="lineNum">  161</span><span class="lineNoCov">      0  /   1: 		m_breakpointToAddrMap.clear(); </span>
<span class="lineNum">  162</span><span class="lineNoCov">      0  /   1: 		m_addrToBreakpointMap.clear(); </span>
<span class="lineNum">  163</span><span class="lineNoCov">      0  /   1: 		m_instructionMap.clear(); </span>
<span class="lineNum">  164</span>              :  </span>
<span class="lineNum">  165</span>              : 		&#047;* Basic check first *&#047; </span>
<span class="lineNum">  166</span><span class="lineNoCov">      0  /   1: 		if (access(executable.c_str(), X_OK) != 0) </span>
<span class="lineNum">  167</span><span class="lineNoCov">      0  /   1: 			return false; </span>
<span class="lineNum">  168</span>              :  </span>
<span class="lineNum">  169</span>              : 		std::string kcov_solib_pipe_path = </span>
<span class="lineNum">  170</span><span class="lineNoCov">      0  /   1: 				IOutputHandler::getInstance().getOutDirectory() + </span>
<span class="lineNum">  171</span><span class="lineNoCov">      0  /   1: 				&quot;kcov-solib.pipe&quot;; </span>
<span class="lineNum">  172</span>              : 		std::string kcov_solib_path = </span>
<span class="lineNum">  173</span><span class="lineNoCov">      0  /   1: 				IOutputHandler::getInstance().getBaseDirectory() + </span>
<span class="lineNum">  174</span><span class="lineNoCov">      0  /   3: 				&quot;libkcov_sowrapper.so&quot;; </span>
<span class="lineNum">  175</span>              :  </span>
<span class="lineNum">  176</span><span class="lineNoCov">      0  /   1: 		write_file(__library_data, __library_data_size, kcov_solib_path.c_str()); </span>
<span class="lineNum">  177</span>              :  </span>
<span class="lineNum">  178</span>              : 		std::string kcov_solib_env = &quot;KCOV_SOLIB_PATH=&quot; + </span>
<span class="lineNum">  179</span><span class="lineNoCov">      0  /   3: 				kcov_solib_pipe_path; </span>
<span class="lineNum">  180</span><span class="lineNoCov">      0  /   1: 		unlink(kcov_solib_pipe_path.c_str()); </span>
<span class="lineNum">  181</span><span class="lineNoCov">      0  /   1: 		mkfifo(kcov_solib_pipe_path.c_str(), 0644); </span>
<span class="lineNum">  182</span>              :  </span>
<span class="lineNum">  183</span><span class="lineNoCov">      0  /   1: 		free(m_envString); </span>
<span class="lineNum">  184</span><span class="lineNoCov">      0  /   1: 		m_envString = (char *)xmalloc(kcov_solib_env.size() + 1); </span>
<span class="lineNum">  185</span><span class="lineNoCov">      0  /   1: 		strcpy(m_envString, kcov_solib_env.c_str()); </span>
<span class="lineNum">  186</span>              :  </span>
<span class="lineNum">  187</span><span class="lineNoCov">      0  /   3: 		std::string preloadEnv = std::string(&quot;LD_PRELOAD=&quot; + kcov_solib_path).c_str(); </span>
<span class="lineNum">  188</span><span class="lineNoCov">      0  /   1: 		free(m_ldPreloadString); </span>
<span class="lineNum">  189</span><span class="lineNoCov">      0  /   1: 		m_ldPreloadString = (char *)xmalloc(preloadEnv.size() + 1); </span>
<span class="lineNum">  190</span><span class="lineNoCov">      0  /   1: 		strcpy(m_ldPreloadString, preloadEnv.c_str()); </span>
<span class="lineNum">  191</span>              :  </span>
<span class="lineNum">  192</span><span class="lineNoCov">      0  /   1: 		if (IConfiguration::getInstance().getParseSolibs()) { </span>
<span class="lineNum">  193</span><span class="lineNoCov">      0  /   1: 			if (file_exists(kcov_solib_path.c_str())) </span>
<span class="lineNum">  194</span><span class="lineNoCov">      0  /   1: 				putenv(m_ldPreloadString); </span>
<span class="lineNum">  195</span>              : 		} </span>
<span class="lineNum">  196</span><span class="lineNoCov">      0  /   1: 		putenv(m_envString); </span>
<span class="lineNum">  197</span>              :  </span>
<span class="lineNum">  198</span><span class="lineNoCov">      0  /   1: 		m_solibPath = kcov_solib_pipe_path; </span>
<span class="lineNum">  199</span>              : 		pthread_create(&amp;m_solibThread, nullptr, </span>
<span class="lineNum">  200</span><span class="lineNoCov">      0  /   1: 				Ptrace::threadStatic, (void *)this); </span>
<span class="lineNum">  201</span>              :  </span>
<span class="lineNum">  202</span><span class="lineNoCov">      0  /   1: 		unsigned int pid = IConfiguration::getInstance().getAttachPid(); </span>
<span class="lineNum">  203</span><span class="lineNoCov">      0  /   1: 		bool res = false; </span>
<span class="lineNum">  204</span>              :  </span>
<span class="lineNum">  205</span><span class="lineNoCov">      0  /   1: 		if (pid != 0) </span>
<span class="lineNum">  206</span><span class="lineNoCov">      0  /   1: 			res = attachPid(pid); </span>
<span class="lineNum">  207</span>              : 		else </span>
<span class="lineNum">  208</span><span class="lineNoCov">      0  /   1: 			res = forkChild(executable.c_str()); </span>
<span class="lineNum">  209</span>              :  </span>
<span class="lineNum">  210</span><span class="lineNoCov">      0  /   3: 		return res; </span>
<span class="lineNum">  211</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">  212</span>              :  </span>
<span class="lineNum">  213</span><span class="lineNoCov">      0  /   1: 	int registerBreakpoint(unsigned long addr) </span>
<span class="lineNum">  214</span>              : 	{ </span>
<span class="lineNum">  215</span>              : 		unsigned long data; </span>
<span class="lineNum">  216</span>              : 		int id; </span>
<span class="lineNum">  217</span>              :  </span>
<span class="lineNum">  218</span>              : 		&#047;&#047; There already? </span>
<span class="lineNum">  219</span><span class="lineNoCov">      0  /   1: 		if (m_addrToBreakpointMap.find(addr) != m_addrToBreakpointMap.end()) </span>
<span class="lineNum">  220</span><span class="lineNoCov">      0  /   1: 			return m_addrToBreakpointMap[addr]; </span>
<span class="lineNum">  221</span>              :  </span>
<span class="lineNum">  222</span><span class="lineNoCov">      0  /   1: 		if (readMemory(&amp;data, addr) == false) </span>
<span class="lineNum">  223</span><span class="lineNoCov">      0  /   1: 			return -1; </span>
<span class="lineNum">  224</span>              :  </span>
<span class="lineNum">  225</span><span class="lineNoCov">      0  /   1: 		id = m_breakpointId++; </span>
<span class="lineNum">  226</span>              :  </span>
<span class="lineNum">  227</span><span class="lineNoCov">      0  /   1: 		m_breakpointToAddrMap[id] = addr; </span>
<span class="lineNum">  228</span><span class="lineNoCov">      0  /   1: 		m_addrToBreakpointMap[addr] = id; </span>
<span class="lineNum">  229</span><span class="lineNoCov">      0  /   1: 		m_instructionMap[addr] = data; </span>
<span class="lineNum">  230</span><span class="lineNoCov">      0  /   1: 		m_pendingBreakpoints.push_back(addr); </span>
<span class="lineNum">  231</span>              :  </span>
<span class="lineNum">  232</span><span class="lineNoCov">      0  /   1: 		kcov_debug(BP_MSG, &quot;BP registered at 0x%lx&#092;n&quot;, addr); </span>
<span class="lineNum">  233</span>              :  </span>
<span class="lineNum">  234</span><span class="lineNoCov">      0  /   1: 		return id; </span>
<span class="lineNum">  235</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">  236</span>              :  </span>
<span class="lineNum">  237</span><span class="lineNoCov">      0  /   1: 	void setupAllBreakpoints() </span>
<span class="lineNum">  238</span>              : 	{ </span>
<span class="lineNum">  239</span><span class="lineNoCov">      0  /   2: 		for (const auto addr : m_pendingBreakpoints) { </span>
<span class="lineNum">  240</span><span class="lineNoCov">      0  /   1: 			unsigned long cur_data = peekWord(addr); </span>
<span class="lineNum">  241</span>              :  </span>
<span class="lineNum">  242</span>              : 			&#047;&#047; Set the breakpoint </span>
<span class="lineNum">  243</span><span class="lineNoCov">      0  /   1: 			pokeWord(addr,	arch_setupBreakpoint(addr, cur_data)); </span>
<span class="lineNum">  244</span>              : 		} </span>
<span class="lineNum">  245</span>              :  </span>
<span class="lineNum">  246</span><span class="lineNoCov">      0  /   1: 		m_pendingBreakpoints.clear(); </span>
<span class="lineNum">  247</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">  248</span>              :  </span>
<span class="lineNum">  249</span><span class="lineNoCov">      0  /   1: 	void solibThreadMain() </span>
<span class="lineNum">  250</span>              : 	{ </span>
<span class="lineNum">  251</span>              : 		uint8_t buf[1024 * 1024]; </span>
<span class="lineNum">  252</span>              : 		int fd; </span>
<span class="lineNum">  253</span>              :  </span>
<span class="lineNum">  254</span><span class="lineNoCov">      0  /   1: 		fd = open(m_solibPath.c_str(), O_RDONLY); </span>
<span class="lineNum">  255</span>              :  </span>
<span class="lineNum">  256</span><span class="lineNoCov">      0  /   1: 		if (fd &lt; 0) </span>
<span class="lineNum">  257</span><span class="lineNoCov">      0  /   1: 			return; </span>
<span class="lineNum">  258</span>              :  </span>
<span class="lineNum">  259</span><span class="lineNoCov">      0  /   1: 		m_solibFileOpen = true; </span>
<span class="lineNum">  260</span>              :  </span>
<span class="lineNum">  261</span>              : 		while (1) { </span>
<span class="lineNum">  262</span><span class="lineNoCov">      0  /   1: 			int r = read(fd, buf, sizeof(buf)); </span>
<span class="lineNum">  263</span>              :  </span>
<span class="lineNum">  264</span><span class="lineNoCov">      0  /   1: 			if (r &lt;= 0) </span>
<span class="lineNum">  265</span><span class="lineNoCov">      0  /   1: 				break; </span>
<span class="lineNum">  266</span><span class="lineNoCov">      0  /   1: 			panic_if ((unsigned)r &gt;= sizeof(buf), </span>
<span class="lineNum">  267</span>              : 					&quot;Too much solib data read&quot;); </span>
<span class="lineNum">  268</span>              :  </span>
<span class="lineNum">  269</span><span class="lineNoCov">      0  /   1: 			struct phdr_data *p = phdr_data_unmarshal(buf); </span>
<span class="lineNum">  270</span>              :  </span>
<span class="lineNum">  271</span><span class="lineNoCov">      0  /   1: 			if (p) { </span>
<span class="lineNum">  272</span><span class="lineNoCov">      0  /   1: 				size_t sz = sizeof(struct phdr_data) + p-&gt;n_entries * sizeof(struct phdr_data_entry); </span>
<span class="lineNum">  273</span><span class="lineNoCov">      0  /   1: 				struct phdr_data *cpy = (struct phdr_data*)xmalloc(sz); </span>
<span class="lineNum">  274</span>              :  </span>
<span class="lineNum">  275</span><span class="lineNoCov">      0  /   1: 				memcpy(cpy, p, sz); </span>
<span class="lineNum">  276</span>              :  </span>
<span class="lineNum">  277</span><span class="lineNoCov">      0  /   1: 				m_phdrListMutex.lock(); </span>
<span class="lineNum">  278</span><span class="lineNoCov">      0  /   1: 				m_phdrs.push_back(cpy); </span>
<span class="lineNum">  279</span><span class="lineNoCov">      0  /   1: 				m_phdrListMutex.unlock(); </span>
<span class="lineNum">  280</span>              : 			} </span>
<span class="lineNum">  281</span><span class="lineNoCov">      0  /   1: 			m_solibDataReadSemaphore.notify(); </span>
<span class="lineNum">  282</span>              : 		} </span>
<span class="lineNum">  283</span>              :  </span>
<span class="lineNum">  284</span><span class="lineNoCov">      0  /   1: 		m_solibDataReadSemaphore.notify(); </span>
<span class="lineNum">  285</span><span class="lineNoCov">      0  /   2: 		close(fd); </span>
<span class="lineNum">  286</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">  287</span>              :  </span>
<span class="lineNum">  288</span><span class="lineNoCov">      0  /   1: 	static void *threadStatic(void *pThis) </span>
<span class="lineNum">  289</span>              : 	{ </span>
<span class="lineNum">  290</span><span class="lineNoCov">      0  /   1: 		Ptrace *p = (Ptrace *)pThis; </span>
<span class="lineNum">  291</span>              :  </span>
<span class="lineNum">  292</span><span class="lineNoCov">      0  /   1: 		p-&gt;solibThreadMain(); </span>
<span class="lineNum">  293</span>              :  </span>
<span class="lineNum">  294</span>              : 		&#047;&#047; Never reached </span>
<span class="lineNum">  295</span><span class="lineNoCov">      0  /   1: 		return nullptr; </span>
<span class="lineNum">  296</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">  297</span>              :  </span>
<span class="lineNum">  298</span>              : 	void clearAllBreakpoints() </span>
<span class="lineNum">  299</span>              : 	{ </span>
<span class="lineNum">  300</span>              : 		for (const auto &amp;it : m_breakpointToAddrMap) </span>
<span class="lineNum">  301</span>              : 			clearBreakpoint(it.first); </span>
<span class="lineNum">  302</span>              :  </span>
<span class="lineNum">  303</span>              : 		m_addrToBreakpointMap.clear(); </span>
<span class="lineNum">  304</span>              : 		m_addrToBreakpointMap.clear(); </span>
<span class="lineNum">  305</span>              : 		m_instructionMap.clear(); </span>
<span class="lineNum">  306</span>              : 	} </span>
<span class="lineNum">  307</span>              :  </span>
<span class="lineNum">  308</span><span class="lineNoCov">      0  /   1: 	bool clearBreakpoint(int id) </span>
<span class="lineNum">  309</span>              : 	{ </span>
<span class="lineNum">  310</span><span class="lineNoCov">      0  /   1: 		if (m_breakpointToAddrMap.find(id) == m_breakpointToAddrMap.end()) { </span>
<span class="lineNum">  311</span><span class="lineNoCov">      0  /   1: 			kcov_debug(BP_MSG, &quot;Can&#039;t find breakpoint %d&#092;n&quot;, id); </span>
<span class="lineNum">  312</span><span class="lineNoCov">      0  /   1: 			return false; </span>
<span class="lineNum">  313</span>              : 		} </span>
<span class="lineNum">  314</span>              :  </span>
<span class="lineNum">  315</span><span class="lineNoCov">      0  /   1: 		unsigned long addr = m_breakpointToAddrMap[id]; </span>
<span class="lineNum">  316</span>              :  </span>
<span class="lineNum">  317</span><span class="lineNoCov">      0  /   1: 		panic_if(m_addrToBreakpointMap.find(addr) == m_addrToBreakpointMap.end(), </span>
<span class="lineNum">  318</span>              : 				&quot;Breakpoint id, but no addr-to-id map!&quot;); </span>
<span class="lineNum">  319</span>              :  </span>
<span class="lineNum">  320</span><span class="lineNoCov">      0  /   1: 		panic_if(m_instructionMap.find(addr) == m_instructionMap.end(), </span>
<span class="lineNum">  321</span>              : 				&quot;Breakpoint found, but no instruction data at that point!&quot;); </span>
<span class="lineNum">  322</span>              :  </span>
<span class="lineNum">  323</span>              :  </span>
<span class="lineNum">  324</span>              : 		&#047;&#047; Clear the actual breakpoint instruction </span>
<span class="lineNum">  325</span><span class="lineNoCov">      0  /   1: 		unsigned long val = m_instructionMap[addr]; </span>
<span class="lineNum">  326</span><span class="lineNoCov">      0  /   1: 		val = arch_clearBreakpoint(addr, val, peekWord(addr)); </span>
<span class="lineNum">  327</span>              :  </span>
<span class="lineNum">  328</span><span class="lineNoCov">      0  /   1: 		pokeWord(addr, val); </span>
<span class="lineNum">  329</span>              :  </span>
<span class="lineNum">  330</span><span class="lineNoCov">      0  /   1: 		return true; </span>
<span class="lineNum">  331</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">  332</span>              :  </span>
<span class="lineNum">  333</span><span class="lineNoCov">      0  /   1: 	void singleStep() </span>
<span class="lineNum">  334</span>              : 	{ </span>
<span class="lineNum">  335</span>              : 		unsigned long regs[1024]; </span>
<span class="lineNum">  336</span>              :  </span>
<span class="lineNum">  337</span><span class="lineNoCov">      0  /   1: 		ptrace((__ptrace_request)PTRACE_GETREGS, m_activeChild, 0, &amp;regs); </span>
<span class="lineNum">  338</span>              :  </span>
<span class="lineNum">  339</span>              : 		&#047;&#047; Step back one instruction </span>
<span class="lineNum">  340</span><span class="lineNoCov">      0  /   1: 		arch_adjustPcAfterBreakpoint(regs); </span>
<span class="lineNum">  341</span><span class="lineNoCov">      0  /   1: 		ptrace((__ptrace_request)PTRACE_SETREGS, m_activeChild, 0, &amp;regs); </span>
<span class="lineNum">  342</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">  343</span>              :  </span>
<span class="lineNum">  344</span><span class="lineNoCov">      0  /   1: 	void checkSolibData() </span>
<span class="lineNum">  345</span>              : 	{ </span>
<span class="lineNum">  346</span><span class="lineNoCov">      0  /   1: 		struct phdr_data *p = nullptr; </span>
<span class="lineNum">  347</span>              :  </span>
<span class="lineNum">  348</span><span class="lineNoCov">      0  /   1: 		if (!m_elf) </span>
<span class="lineNum">  349</span><span class="lineNoCov">      0  /   1: 			return; </span>
<span class="lineNum">  350</span>              :  </span>
<span class="lineNum">  351</span><span class="lineNoCov">      0  /   1: 		m_phdrListMutex.lock(); </span>
<span class="lineNum">  352</span><span class="lineNoCov">      0  /   1: 		if (!m_phdrs.empty()) { </span>
<span class="lineNum">  353</span><span class="lineNoCov">      0  /   1: 			p = m_phdrs.front(); </span>
<span class="lineNum">  354</span><span class="lineNoCov">      0  /   1: 			m_phdrs.pop_front(); </span>
<span class="lineNum">  355</span>              : 		} </span>
<span class="lineNum">  356</span><span class="lineNoCov">      0  /   1: 		m_phdrListMutex.unlock(); </span>
<span class="lineNum">  357</span>              :  </span>
<span class="lineNum">  358</span><span class="lineNoCov">      0  /   1: 		if (!p) </span>
<span class="lineNum">  359</span><span class="lineNoCov">      0  /   1: 			return; </span>
<span class="lineNum">  360</span>              :  </span>
<span class="lineNum">  361</span><span class="lineNoCov">      0  /   2: 		for (unsigned int i = 0; i &lt; p-&gt;n_entries; i++) </span>
<span class="lineNum">  362</span>              : 		{ </span>
<span class="lineNum">  363</span><span class="lineNoCov">      0  /   1: 			struct phdr_data_entry *cur = &amp;p-&gt;entries[i]; </span>
<span class="lineNum">  364</span>              :  </span>
<span class="lineNum">  365</span><span class="lineNoCov">      0  /   1: 			if (strlen(cur-&gt;name) == 0) </span>
<span class="lineNum">  366</span><span class="lineNoCov">      0  /   1: 				continue; </span>
<span class="lineNum">  367</span>              :  </span>
<span class="lineNum">  368</span>              : 			&#047;&#047; Skip this very special library </span>
<span class="lineNum">  369</span><span class="lineNoCov">      0  /   1: 			if (strstr(cur-&gt;name, &quot;libkcov_sowrapper.so&quot;)) </span>
<span class="lineNum">  370</span><span class="lineNoCov">      0  /   1: 				continue; </span>
<span class="lineNum">  371</span>              :  </span>
<span class="lineNum">  372</span><span class="lineNoCov">      0  /   2: 			m_elf-&gt;addFile(cur-&gt;name, cur); </span>
<span class="lineNum">  373</span><span class="lineNoCov">      0  /   1: 			m_elf-&gt;parse(); </span>
<span class="lineNum">  374</span>              :  </span>
<span class="lineNum">  375</span><span class="lineNoCov">      0  /   1: 			setupAllBreakpoints(); </span>
<span class="lineNum">  376</span>              : 		} </span>
<span class="lineNum">  377</span>              :  </span>
<span class="lineNum">  378</span><span class="lineNoCov">      0  /   1: 		free(p); </span>
<span class="lineNum">  379</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">  380</span>              :  </span>
<span class="lineNum">  381</span><span class="lineNoCov">      0  /   1: 	const Event waitEvent() </span>
<span class="lineNum">  382</span>              : 	{ </span>
<span class="lineNum">  383</span><span class="lineNoCov">      0  /   1: 		Event out; </span>
<span class="lineNum">  384</span>              : 		int status; </span>
<span class="lineNum">  385</span>              : 		int who; </span>
<span class="lineNum">  386</span>              :  </span>
<span class="lineNum">  387</span>              : 		&#047;&#047; Assume error </span>
<span class="lineNum">  388</span><span class="lineNoCov">      0  /   1: 		out.type = ev_error; </span>
<span class="lineNum">  389</span><span class="lineNoCov">      0  /   1: 		out.data = -1; </span>
<span class="lineNum">  390</span>              :  </span>
<span class="lineNum">  391</span><span class="lineNoCov">      0  /   1: 		who = waitpid(-1, &amp;status, __WALL); </span>
<span class="lineNum">  392</span><span class="lineNoCov">      0  /   1: 		if (who == -1) { </span>
<span class="lineNum">  393</span><span class="lineNoCov">      0  /   1: 			kcov_debug(PTRACE_MSG, &quot;Returning error&#092;n&quot;); </span>
<span class="lineNum">  394</span><span class="lineNoCov">      0  /   1: 			return out; </span>
<span class="lineNum">  395</span>              : 		} </span>
<span class="lineNum">  396</span>              :  </span>
<span class="lineNum">  397</span><span class="lineNoCov">      0  /   1: 		m_children[who] = 1; </span>
<span class="lineNum">  398</span>              :  </span>
<span class="lineNum">  399</span><span class="lineNoCov">      0  /   1: 		m_activeChild = who; </span>
<span class="lineNum">  400</span><span class="lineNoCov">      0  /   1: 		out.addr = getPc(m_activeChild); </span>
<span class="lineNum">  401</span>              :  </span>
<span class="lineNum">  402</span><span class="lineNoCov">      0  /   1: 		kcov_debug(PTRACE_MSG, &quot;PT stopped PID %d 0x%08x&#092;n&quot;, m_activeChild, status); </span>
<span class="lineNum">  403</span>              :  </span>
<span class="lineNum">  404</span>              : 		&#047;&#047; A signal? </span>
<span class="lineNum">  405</span><span class="lineNoCov">      0  /   1: 		if (WIFSTOPPED(status)) { </span>
<span class="lineNum">  406</span>              : 			siginfo_t siginfo; </span>
<span class="lineNum">  407</span><span class="lineNoCov">      0  /   1: 			int sig = WSTOPSIG(status); </span>
<span class="lineNum">  408</span>              :  </span>
<span class="lineNum">  409</span><span class="lineNoCov">      0  /   1: 			out.type = ev_signal; </span>
<span class="lineNum">  410</span><span class="lineNoCov">      0  /   1: 			out.data = sig; </span>
<span class="lineNum">  411</span>              :  </span>
<span class="lineNum">  412</span><span class="lineNoCov">      0  /   1: 			ptrace(PTRACE_GETSIGINFO, m_activeChild, nullptr, (void *)&amp;siginfo); </span>
<span class="lineNum">  413</span>              :  </span>
<span class="lineNum">  414</span>              : 			&#047;&#047; A trap? </span>
<span class="lineNum">  415</span><span class="lineNoCov">      0  /   1: 			if (sig == SIGTRAP || sig == SIGSTOP) { </span>
<span class="lineNum">  416</span><span class="lineNoCov">      0  /   1: 				out.type = ev_breakpoint; </span>
<span class="lineNum">  417</span><span class="lineNoCov">      0  /   1: 				out.data = -1; </span>
<span class="lineNum">  418</span>              :  </span>
<span class="lineNum">  419</span>              : 				&#047;&#047; Breakpoint id </span>
<span class="lineNum">  420</span><span class="lineNoCov">      0  /   1: 				addrToBreakpointMap_t::iterator it = m_addrToBreakpointMap.find(out.addr); </span>
<span class="lineNum">  421</span><span class="lineNoCov">      0  /   1: 				if (it != m_addrToBreakpointMap.end()) </span>
<span class="lineNum">  422</span><span class="lineNoCov">      0  /   1: 					out.data = it-&gt;second; </span>
<span class="lineNum">  423</span>              :  </span>
<span class="lineNum">  424</span>              : 				kcov_debug(PTRACE_MSG, &quot;PT BP at 0x%llx:%d for %d&#092;n&quot;, </span>
<span class="lineNum">  425</span><span class="lineNoCov">      0  /   1: 						(unsigned long long)out.addr, out.data, m_activeChild); </span>
<span class="lineNum">  426</span><span class="lineNoCov">      0  /   1: 				if (out.data != -1) </span>
<span class="lineNum">  427</span><span class="lineNoCov">      0  /   1: 					singleStep(); </span>
<span class="lineNum">  428</span>              :  </span>
<span class="lineNum">  429</span><span class="lineNoCov">      0  /   1: 				if (m_solibFileOpen &amp;&amp; m_firstBreakpoint) { </span>
<span class="lineNum">  430</span><span class="lineNoCov">      0  /   1: 					m_solibDataReadSemaphore.wait(); </span>
<span class="lineNum">  431</span><span class="lineNoCov">      0  /   1: 					m_firstBreakpoint = false; </span>
<span class="lineNum">  432</span>              : 				} </span>
<span class="lineNum">  433</span>              :  </span>
<span class="lineNum">  434</span><span class="lineNoCov">      0  /   1: 				return out; </span>
<span class="lineNum">  435</span><span class="lineNoCov">      0  /   1: 			} else if ((status &gt;&gt; 16) == PTRACE_EVENT_CLONE || (status &gt;&gt; 16) == PTRACE_EVENT_FORK) { </span>
<span class="lineNum">  436</span>              : 				kcov_debug(PTRACE_MSG, &quot;PT clone at 0x%llx for %d&#092;n&quot;, </span>
<span class="lineNum">  437</span><span class="lineNoCov">      0  /   1: 						(unsigned long long)out.addr, m_activeChild); </span>
<span class="lineNum">  438</span><span class="lineNoCov">      0  /   1: 				out.data = 0; </span>
<span class="lineNum">  439</span>              : 			} </span>
<span class="lineNum">  440</span>              :  </span>
<span class="lineNum">  441</span>              : 			kcov_debug(PTRACE_MSG, &quot;PT signal %d at 0x%llx for %d&#092;n&quot;, </span>
<span class="lineNum">  442</span><span class="lineNoCov">      0  /   1: 					WSTOPSIG(status), (unsigned long long)out.addr, m_activeChild); </span>
<span class="lineNum">  443</span><span class="lineNoCov">      0  /   1: 		} else if (WIFSIGNALED(status)) { </span>
<span class="lineNum">  444</span>              : 			&#047;&#047; Crashed&#047;killed </span>
<span class="lineNum">  445</span><span class="lineNoCov">      0  /   1: 			int sig = WTERMSIG(status); </span>
<span class="lineNum">  446</span>              :  </span>
<span class="lineNum">  447</span><span class="lineNoCov">      0  /   1: 			out.type = ev_signal; </span>
<span class="lineNum">  448</span><span class="lineNoCov">      0  /   1: 			out.data = sig; </span>
<span class="lineNum">  449</span>              :  </span>
<span class="lineNum">  450</span>              : 			kcov_debug(PTRACE_MSG, &quot;PT terminating signal %d at 0x%llx for %d&#092;n&quot;, </span>
<span class="lineNum">  451</span><span class="lineNoCov">      0  /   1: 					sig, (unsigned long long)out.addr, m_activeChild); </span>
<span class="lineNum">  452</span><span class="lineNoCov">      0  /   1: 			m_children.erase(who); </span>
<span class="lineNum">  453</span><span class="lineNoCov">      0  /   1: 		} else if (WIFEXITED(status)) { </span>
<span class="lineNum">  454</span><span class="lineNoCov">      0  /   1: 			int exitStatus = WEXITSTATUS(status); </span>
<span class="lineNum">  455</span>              :  </span>
<span class="lineNum">  456</span>              : 			kcov_debug(PTRACE_MSG, &quot;PT exit %d at 0x%llx for %d%s&#092;n&quot;, </span>
<span class="lineNum">  457</span><span class="lineNoCov">      0  /   1: 					exitStatus, (unsigned long long)out.addr, m_activeChild, m_activeChild == m_firstChild ? &quot; (first child)&quot; : &quot;&quot;); </span>
<span class="lineNum">  458</span>              :  </span>
<span class="lineNum">  459</span><span class="lineNoCov">      0  /   1: 			m_children.erase(who); </span>
<span class="lineNum">  460</span>              :  </span>
<span class="lineNum">  461</span><span class="lineNoCov">      0  /   1: 			if (who == m_firstChild) </span>
<span class="lineNum">  462</span><span class="lineNoCov">      0  /   1: 				out.type = ev_exit_first_process; </span>
<span class="lineNum">  463</span>              : 			else </span>
<span class="lineNum">  464</span><span class="lineNoCov">      0  /   1: 				out.type = ev_exit; </span>
<span class="lineNum">  465</span>              :  </span>
<span class="lineNum">  466</span><span class="lineNoCov">      0  /   1: 			out.data = exitStatus; </span>
<span class="lineNum">  467</span>              : 		} </span>
<span class="lineNum">  468</span>              :  </span>
<span class="lineNum">  469</span><span class="lineNoCov">      0  /   1: 		return out; </span>
<span class="lineNum">  470</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">  471</span>              :  </span>
<span class="lineNum">  472</span><span class="lineNoCov">      0  /   1: 	bool childrenLeft() </span>
<span class="lineNum">  473</span>              : 	{ </span>
<span class="lineNum">  474</span><span class="lineNoCov">      0  /   4: 		return m_children.size() &gt; 0 &amp;&amp; </span>
<span class="lineNum">  475</span><span class="lineNoCov">      0  /   4: 				 m_children.find(m_firstChild) != m_children.end(); </span>
<span class="lineNum">  476</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">  477</span>              :  </span>
<span class="lineNum">  478</span>              :  </span>
<span class="lineNum">  479</span>              : 		&#047;** </span>
<span class="lineNum">  480</span>              : 		 * Continue execution with an event </span>
<span class="lineNum">  481</span>              : 		 *&#047; </span>
<span class="lineNum">  482</span><span class="lineNoCov">      0  /   1: 	bool continueExecution() </span>
<span class="lineNum">  483</span>              : 	{ </span>
<span class="lineNum">  484</span>              : 		int res; </span>
<span class="lineNum">  485</span>              :  </span>
<span class="lineNum">  486</span><span class="lineNoCov">      0  /   1: 		checkSolibData(); </span>
<span class="lineNum">  487</span>              :  </span>
<span class="lineNum">  488</span><span class="lineNoCov">      0  /   1: 		kcov_debug(PTRACE_MSG, &quot;PT continuing %d with signal %lu&#092;n&quot;, m_activeChild, m_signal); </span>
<span class="lineNum">  489</span><span class="lineNoCov">      0  /   1: 		res = ptrace(PTRACE_CONT, m_activeChild, 0, m_signal); </span>
<span class="lineNum">  490</span><span class="lineNoCov">      0  /   1: 		if (res &lt; 0) { </span>
<span class="lineNum">  491</span><span class="lineNoCov">      0  /   1: 			kcov_debug(PTRACE_MSG, &quot;PT error for %d: %d&#092;n&quot;, m_activeChild, res); </span>
<span class="lineNum">  492</span><span class="lineNoCov">      0  /   1: 			m_children.erase(m_activeChild); </span>
<span class="lineNum">  493</span>              : 		} </span>
<span class="lineNum">  494</span>              :  </span>
<span class="lineNum">  495</span>              :  </span>
<span class="lineNum">  496</span><span class="lineNoCov">      0  /   1: 		Event ev = waitEvent(); </span>
<span class="lineNum">  497</span><span class="lineNoCov">      0  /   1: 		m_signal = ev.type == ev_signal ? ev.data : 0; </span>
<span class="lineNum">  498</span>              :  </span>
<span class="lineNum">  499</span><span class="lineNoCov">      0  /   1: 		if (m_listener) </span>
<span class="lineNum">  500</span><span class="lineNoCov">      0  /   1: 			m_listener-&gt;onEvent(ev); </span>
<span class="lineNum">  501</span>              :  </span>
<span class="lineNum">  502</span><span class="lineNoCov">      0  /   1: 		if (ev.type == ev_error) </span>
<span class="lineNum">  503</span><span class="lineNoCov">      0  /   1: 			return false; </span>
<span class="lineNum">  504</span>              :  </span>
<span class="lineNum">  505</span><span class="lineNoCov">      0  /   1: 		return true; </span>
<span class="lineNum">  506</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">  507</span>              :  </span>
<span class="lineNum">  508</span><span class="lineNoCov">      0  /   1: 	std::string eventToName(Event ev) </span>
<span class="lineNum">  509</span>              : 	{ </span>
<span class="lineNum">  510</span><span class="lineNoCov">      0  /   2: 		switch (ev.type) </span>
<span class="lineNum">  511</span>              : 		{ </span>
<span class="lineNum">  512</span>              : 		case ev_breakpoint: </span>
<span class="lineNum">  513</span><span class="lineNoCov">      0  /   1: 			return fmt(&quot;breakpoint at 0x%llx&quot;, (unsigned long long)ev.addr); </span>
<span class="lineNum">  514</span>              : 		case ev_exit: </span>
<span class="lineNum">  515</span><span class="lineNoCov">      0  /   1: 			return fmt(&quot;exit code %d&quot;, ev.data); </span>
<span class="lineNum">  516</span>              : 		case ev_signal: </span>
<span class="lineNum">  517</span>              : 		{ </span>
<span class="lineNum">  518</span><span class="lineNoCov">      0  /   1: 			if (ev.data == SIGABRT) </span>
<span class="lineNum">  519</span><span class="lineNoCov">      0  /   2: 				return std::string(&quot;SIGABRT&quot;); </span>
<span class="lineNum">  520</span><span class="lineNoCov">      0  /   1: 			if (ev.data == SIGSEGV) </span>
<span class="lineNum">  521</span><span class="lineNoCov">      0  /   2: 				return std::string(&quot;SIGSEGV&quot;); </span>
<span class="lineNum">  522</span><span class="lineNoCov">      0  /   1: 			if (ev.data == SIGILL) </span>
<span class="lineNum">  523</span><span class="lineNoCov">      0  /   2: 				return std::string(&quot;SIGILL&quot;); </span>
<span class="lineNum">  524</span><span class="lineNoCov">      0  /   1: 			if (ev.data == SIGTERM) </span>
<span class="lineNum">  525</span><span class="lineNoCov">      0  /   2: 				return std::string(&quot;SIGTERM&quot;); </span>
<span class="lineNum">  526</span><span class="lineNoCov">      0  /   1: 			if (ev.data == SIGBUS) </span>
<span class="lineNum">  527</span><span class="lineNoCov">      0  /   2: 				return std::string(&quot;SIGBUS&quot;); </span>
<span class="lineNum">  528</span><span class="lineNoCov">      0  /   1: 			if (ev.data == SIGFPE) </span>
<span class="lineNum">  529</span><span class="lineNoCov">      0  /   2: 				return std::string(&quot;SIGFPE&quot;); </span>
<span class="lineNum">  530</span>              :  </span>
<span class="lineNum">  531</span><span class="lineNoCov">      0  /   1: 			return fmt(&quot;unknown signal %d&quot;, ev.data); </span>
<span class="lineNum">  532</span>              : 		} </span>
<span class="lineNum">  533</span>              : 		case ev_error: </span>
<span class="lineNum">  534</span><span class="lineNoCov">      0  /   2: 			return std::string(&quot;error&quot;); </span>
<span class="lineNum">  535</span>              : 		default: </span>
<span class="lineNum">  536</span><span class="lineNoCov">      0  /   2: 			break; </span>
<span class="lineNum">  537</span>              : 		} </span>
<span class="lineNum">  538</span>              :  </span>
<span class="lineNum">  539</span><span class="lineNoCov">      0  /   2: 		return std::string(&quot;unknown&quot;); </span>
<span class="lineNum">  540</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">  541</span>              :  </span>
<span class="lineNum">  542</span><span class="lineNoCov">      0  /   1: 	void kill() </span>
<span class="lineNum">  543</span>              : 	{ </span>
<span class="lineNum">  544</span><span class="lineNoCov">      0  /   1: 		ptrace(PTRACE_KILL, m_activeChild, 0, 0); </span>
<span class="lineNum">  545</span><span class="lineNoCov">      0  /   1: 		ptrace(PTRACE_DETACH, m_activeChild, 0, 0); </span>
<span class="lineNum">  546</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">  547</span>              :  </span>
<span class="lineNum">  548</span><span class="lineCov">      1  /   1: 	unsigned int matchFile(const std::string &amp;filename, uint8_t *data, size_t dataSize) </span>
<span class="lineNum">  549</span>              : 	{ </span>
<span class="lineNum">  550</span><span class="lineCov">      1  /   1: 		m_elf = IParserManager::getInstance().matchParser(filename); </span>
<span class="lineNum">  551</span>              :  </span>
<span class="lineNum">  552</span>              : 		&#047;&#047; We need a parser for this to work </span>
<span class="lineNum">  553</span><span class="lineCov">      1  /   1: 		if (!m_elf) </span>
<span class="lineNum">  554</span><span class="lineNoCov">      0  /   1: 			return match_none; </span>
<span class="lineNum">  555</span>              :  </span>
<span class="lineNum">  556</span>              : 		&#047;&#047; Unless #!&#047;bin&#047;sh etc, this should win </span>
<span class="lineNum">  557</span><span class="lineCov">      1  /   1: 		return 1; </span>
<span class="lineNum">  558</span><span class="linePartCov">      1  /   2: 	} </span>
<span class="lineNum">  559</span>              :  </span>
<span class="lineNum">  560</span>              :  </span>
<span class="lineNum">  561</span>              : private: </span>
<span class="lineNum">  562</span><span class="lineNoCov">      0  /   1: 	bool forkChild(const char *executable) </span>
<span class="lineNum">  563</span>              : 	{ </span>
<span class="lineNum">  564</span><span class="lineNoCov">      0  /   1: 		char *const *argv = (char *const *)IConfiguration::getInstance().getArgv(); </span>
<span class="lineNum">  565</span>              : 		pid_t child, who; </span>
<span class="lineNum">  566</span>              : 		int status; </span>
<span class="lineNum">  567</span>              :  </span>
<span class="lineNum">  568</span>              : 		&#047;* Executable exists, try to launch it *&#047; </span>
<span class="lineNum">  569</span><span class="lineNoCov">      0  /   1: 		if ((child = fork()) == 0) { </span>
<span class="lineNum">  570</span>              : 			int res; </span>
<span class="lineNum">  571</span>              :  </span>
<span class="lineNum">  572</span>              : 			&#047;* And launch the process *&#047; </span>
<span class="lineNum">  573</span><span class="lineNoCov">      0  /   1: 			res = ptrace(PTRACE_TRACEME, 0, 0, 0); </span>
<span class="lineNum">  574</span><span class="lineNoCov">      0  /   1: 			if (res &lt; 0) { </span>
<span class="lineNum">  575</span><span class="lineNoCov">      0  /   1: 				perror(&quot;Can&#039;t set me as ptraced&quot;); </span>
<span class="lineNum">  576</span><span class="lineNoCov">      0  /   1: 				return false; </span>
<span class="lineNum">  577</span>              : 			} </span>
<span class="lineNum">  578</span><span class="lineNoCov">      0  /   1: 			kcov_tie_process_to_cpu(getpid(), m_parentCpu); </span>
<span class="lineNum">  579</span><span class="lineNoCov">      0  /   1: 			execv(executable, argv); </span>
<span class="lineNum">  580</span>              :  </span>
<span class="lineNum">  581</span>              : 			&#047;* Exec failed *&#047; </span>
<span class="lineNum">  582</span><span class="lineNoCov">      0  /   1: 			return false; </span>
<span class="lineNum">  583</span>              : 		} </span>
<span class="lineNum">  584</span>              :  </span>
<span class="lineNum">  585</span>              : 		&#047;* Fork error? *&#047; </span>
<span class="lineNum">  586</span><span class="lineNoCov">      0  /   1: 		if (child &lt; 0) { </span>
<span class="lineNum">  587</span><span class="lineNoCov">      0  /   1: 			perror(&quot;fork&quot;); </span>
<span class="lineNum">  588</span><span class="lineNoCov">      0  /   1: 			return false; </span>
<span class="lineNum">  589</span>              : 		} </span>
<span class="lineNum">  590</span><span class="lineNoCov">      0  /   1: 		m_child = m_activeChild = m_firstChild = child; </span>
<span class="lineNum">  591</span>              : 		&#047;&#047; Might not be completely necessary (the child should inherit this </span>
<span class="lineNum">  592</span>              : 		&#047;&#047; from the parent), but better safe than sorry </span>
<span class="lineNum">  593</span><span class="lineNoCov">      0  /   1: 		kcov_tie_process_to_cpu(m_child, m_parentCpu); </span>
<span class="lineNum">  594</span>              :  </span>
<span class="lineNum">  595</span><span class="lineNoCov">      0  /   1: 		kcov_debug(PTRACE_MSG, &quot;PT forked %d&#092;n&quot;, child); </span>
<span class="lineNum">  596</span>              :  </span>
<span class="lineNum">  597</span>              : 		&#047;* Wait for the initial stop *&#047; </span>
<span class="lineNum">  598</span><span class="lineNoCov">      0  /   1: 		who = waitpid(child, &amp;status, 0); </span>
<span class="lineNum">  599</span><span class="lineNoCov">      0  /   1: 		if (who &lt; 0) { </span>
<span class="lineNum">  600</span><span class="lineNoCov">      0  /   1: 			perror(&quot;waitpid&quot;); </span>
<span class="lineNum">  601</span><span class="lineNoCov">      0  /   1: 			return false; </span>
<span class="lineNum">  602</span>              : 		} </span>
<span class="lineNum">  603</span><span class="lineNoCov">      0  /   1: 		if (!WIFSTOPPED(status)) { </span>
<span class="lineNum">  604</span><span class="lineNoCov">      0  /   1: 			fprintf(stderr, &quot;Child hasn&#039;t stopped: %x&#092;n&quot;, status); </span>
<span class="lineNum">  605</span><span class="lineNoCov">      0  /   1: 			return false; </span>
<span class="lineNum">  606</span>              : 		} </span>
<span class="lineNum">  607</span>              :  </span>
<span class="lineNum">  608</span><span class="lineNoCov">      0  /   1: 		ptrace(PTRACE_SETOPTIONS, m_activeChild, 0, PTRACE_O_TRACECLONE | PTRACE_O_TRACEFORK); </span>
<span class="lineNum">  609</span>              :  </span>
<span class="lineNum">  610</span><span class="lineNoCov">      0  /   1: 		return true; </span>
<span class="lineNum">  611</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">  612</span>              :  </span>
<span class="lineNum">  613</span><span class="lineNoCov">      0  /   1: 	bool attachPid(pid_t pid) </span>
<span class="lineNum">  614</span>              : 	{ </span>
<span class="lineNum">  615</span><span class="lineNoCov">      0  /   1: 		m_child = m_activeChild = m_firstChild = pid; </span>
<span class="lineNum">  616</span>              :  </span>
<span class="lineNum">  617</span><span class="lineNoCov">      0  /   1: 		errno = 0; </span>
<span class="lineNum">  618</span><span class="lineNoCov">      0  /   1: 		ptrace(PTRACE_ATTACH, m_activeChild, 0, 0); </span>
<span class="lineNum">  619</span><span class="lineNoCov">      0  /   1: 		if (errno) { </span>
<span class="lineNum">  620</span><span class="lineNoCov">      0  /   1: 			const char *err = strerror(errno); </span>
<span class="lineNum">  621</span>              :  </span>
<span class="lineNum">  622</span><span class="lineNoCov">      0  /   1: 			fprintf(stderr, &quot;Can&#039;t attach to %d. Error %s&#092;n&quot;, pid, err); </span>
<span class="lineNum">  623</span><span class="lineNoCov">      0  /   1: 			return false; </span>
<span class="lineNum">  624</span>              : 		} </span>
<span class="lineNum">  625</span>              :  </span>
<span class="lineNum">  626</span>              : 		&#047;* Wait for the initial stop *&#047; </span>
<span class="lineNum">  627</span>              : 		int status; </span>
<span class="lineNum">  628</span><span class="lineNoCov">      0  /   1: 		int who = waitpid(m_activeChild, &amp;status, 0); </span>
<span class="lineNum">  629</span><span class="lineNoCov">      0  /   1: 		if (who &lt; 0) { </span>
<span class="lineNum">  630</span><span class="lineNoCov">      0  /   1: 			perror(&quot;waitpid&quot;); </span>
<span class="lineNum">  631</span><span class="lineNoCov">      0  /   1: 			return false; </span>
<span class="lineNum">  632</span>              : 		} </span>
<span class="lineNum">  633</span><span class="lineNoCov">      0  /   1: 		if (!WIFSTOPPED(status)) { </span>
<span class="lineNum">  634</span><span class="lineNoCov">      0  /   1: 			fprintf(stderr, &quot;Child hasn&#039;t stopped: %x&#092;n&quot;, status); </span>
<span class="lineNum">  635</span><span class="lineNoCov">      0  /   1: 			return false; </span>
<span class="lineNum">  636</span>              : 		} </span>
<span class="lineNum">  637</span><span class="lineNoCov">      0  /   1: 		kcov_tie_process_to_cpu(m_activeChild, m_parentCpu); </span>
<span class="lineNum">  638</span>              :  </span>
<span class="lineNum">  639</span><span class="lineNoCov">      0  /   1: 		::kill(m_activeChild, SIGSTOP); </span>
<span class="lineNum">  640</span><span class="lineNoCov">      0  /   1: 		ptrace(PTRACE_SETOPTIONS, m_activeChild, 0, PTRACE_O_TRACECLONE | PTRACE_O_TRACEFORK); </span>
<span class="lineNum">  641</span>              :  </span>
<span class="lineNum">  642</span><span class="lineNoCov">      0  /   1: 		return true; </span>
<span class="lineNum">  643</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">  644</span>              :  </span>
<span class="lineNum">  645</span><span class="lineNoCov">      0  /   1: 	unsigned long getPcFromRegs(unsigned long *regs) </span>
<span class="lineNum">  646</span>              : 	{ </span>
<span class="lineNum">  647</span><span class="lineNoCov">      0  /   1: 		return arch_getPcFromRegs(regs); </span>
<span class="lineNum">  648</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">  649</span>              :  </span>
<span class="lineNum">  650</span><span class="lineNoCov">      0  /   1: 	unsigned long getPc(int pid) </span>
<span class="lineNum">  651</span>              : 	{ </span>
<span class="lineNum">  652</span>              : 		unsigned long regs[1024]; </span>
<span class="lineNum">  653</span>              :  </span>
<span class="lineNum">  654</span><span class="lineNoCov">      0  /   1: 		memset(&amp;regs, 0, sizeof(regs)); </span>
<span class="lineNum">  655</span><span class="lineNoCov">      0  /   1: 		ptrace((__ptrace_request)PTRACE_GETREGS, pid, 0, &amp;regs); </span>
<span class="lineNum">  656</span>              :  </span>
<span class="lineNum">  657</span><span class="lineNoCov">      0  /   1: 		return getPcFromRegs(regs); </span>
<span class="lineNum">  658</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">  659</span>              :  </span>
<span class="lineNum">  660</span><span class="lineNoCov">      0  /   1: 	unsigned long peekWord(unsigned long addr) </span>
<span class="lineNum">  661</span>              : 	{ </span>
<span class="lineNum">  662</span><span class="lineNoCov">      0  /   1: 		unsigned long aligned = getAligned(addr); </span>
<span class="lineNum">  663</span>              :  </span>
<span class="lineNum">  664</span><span class="lineNoCov">      0  /   1: 		return ptrace((__ptrace_request)PTRACE_PEEKTEXT, m_activeChild, aligned, 0); </span>
<span class="lineNum">  665</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">  666</span>              :  </span>
<span class="lineNum">  667</span><span class="lineNoCov">      0  /   1: 	void pokeWord(unsigned long addr, unsigned long val) </span>
<span class="lineNum">  668</span>              : 	{ </span>
<span class="lineNum">  669</span><span class="lineNoCov">      0  /   1: 		ptrace((__ptrace_request)PTRACE_POKETEXT, m_activeChild, getAligned(addr), val); </span>
<span class="lineNum">  670</span><span class="lineNoCov">      0  /   2: 	} </span>
<span class="lineNum">  671</span>              :  </span>
<span class="lineNum">  672</span>              : 	typedef std::unordered_map&lt;int, unsigned long&gt; breakpointToAddrMap_t; </span>
<span class="lineNum">  673</span>              : 	typedef std::unordered_map&lt;unsigned long, int&gt; addrToBreakpointMap_t; </span>
<span class="lineNum">  674</span>              : 	typedef std::unordered_map&lt;unsigned long, unsigned long &gt; instructionMap_t; </span>
<span class="lineNum">  675</span>              : 	typedef std::list&lt;unsigned long&gt; PendingBreakpointList_t; </span>
<span class="lineNum">  676</span>              : 	typedef std::unordered_map&lt;pid_t, int&gt; ChildMap_t; </span>
<span class="lineNum">  677</span>              : 	typedef std::list&lt;struct phdr_data *&gt; PhdrList_t; </span>
<span class="lineNum">  678</span>              :  </span>
<span class="lineNum">  679</span>              : 	int m_breakpointId; </span>
<span class="lineNum">  680</span>              :  </span>
<span class="lineNum">  681</span>              : 	instructionMap_t m_instructionMap; </span>
<span class="lineNum">  682</span>              : 	breakpointToAddrMap_t m_breakpointToAddrMap; </span>
<span class="lineNum">  683</span>              : 	addrToBreakpointMap_t m_addrToBreakpointMap; </span>
<span class="lineNum">  684</span>              : 	PendingBreakpointList_t m_pendingBreakpoints; </span>
<span class="lineNum">  685</span>              : 	PhdrList_t m_phdrs; </span>
<span class="lineNum">  686</span>              : 	std::mutex m_phdrListMutex; </span>
<span class="lineNum">  687</span>              : 	pthread_t m_solibThread; </span>
<span class="lineNum">  688</span>              : 	Semaphore m_solibDataReadSemaphore; </span>
<span class="lineNum">  689</span>              : 	bool m_firstBreakpoint; </span>
<span class="lineNum">  690</span>              :  </span>
<span class="lineNum">  691</span>              : 	pid_t m_activeChild; </span>
<span class="lineNum">  692</span>              : 	pid_t m_child; </span>
<span class="lineNum">  693</span>              : 	pid_t m_firstChild; </span>
<span class="lineNum">  694</span>              : 	ChildMap_t m_children; </span>
<span class="lineNum">  695</span>              :  </span>
<span class="lineNum">  696</span>              : 	std::string m_solibPath; </span>
<span class="lineNum">  697</span>              : 	char *m_ldPreloadString; </span>
<span class="lineNum">  698</span>              : 	char *m_envString; </span>
<span class="lineNum">  699</span>              :  </span>
<span class="lineNum">  700</span>              : 	int m_parentCpu; </span>
<span class="lineNum">  701</span>              :  </span>
<span class="lineNum">  702</span>              : 	bool m_solibFileOpen; </span>
<span class="lineNum">  703</span>              :  </span>
<span class="lineNum">  704</span>              : 	IFileParser *m_elf; </span>
<span class="lineNum">  705</span>              : 	IEventListener *m_listener; </span>
<span class="lineNum">  706</span>              : 	unsigned long m_signal; </span>
<span class="lineNum">  707</span>              : }; </span>
<span class="lineNum">  708</span>              :  </span>
<span class="lineNum">  709</span><span class="linePartCov">      4  /   5: static Ptrace g_ptrace; </span>
</pre>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr><td class="versionInfo">Generated by: <a href="http://simonkagstrom.github.com/kcov/index.html">Kcov</a></td></tr>
</table>
<br/>
</body>
</html>
