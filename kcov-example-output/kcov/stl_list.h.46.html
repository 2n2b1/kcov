<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Coverage - kcov</title>
  <link rel="stylesheet" type="text/css" href="bcov.css"/>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="title">Coverage Report</td></tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr>
    <td width="100%">
      <table cellpadding="1" border="0" width="100%">
        <tr>
          <td class="headerItem" width="20%">Command:</td>
          <td class="headerValue" width="80%" colspan=6>kcov</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Date:</td>
          <td class="headerValue" width="15%">2014-03-01 10:11:51</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Instrumented&nbsp;lines:</td>
          <td class="headerValue" width="10%">89</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Code&nbsp;covered:</td>
          <td class="coverPerLeftMed" width="15%">74.2%</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Executed&nbsp;lines:</td>
          <td class="headerValue" width="10%">66</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
</table>
<pre class="source">
<span class="lineNum">    1</span>              : &#047;&#047; List implementation -*- C++ -*- </span>
<span class="lineNum">    2</span>              :  </span>
<span class="lineNum">    3</span>              : &#047;&#047; Copyright (C) 2001-2013 Free Software Foundation, Inc. </span>
<span class="lineNum">    4</span>              : &#047;&#047; </span>
<span class="lineNum">    5</span>              : &#047;&#047; This file is part of the GNU ISO C++ Library.  This library is free </span>
<span class="lineNum">    6</span>              : &#047;&#047; software; you can redistribute it and&#047;or modify it under the </span>
<span class="lineNum">    7</span>              : &#047;&#047; terms of the GNU General Public License as published by the </span>
<span class="lineNum">    8</span>              : &#047;&#047; Free Software Foundation; either version 3, or (at your option) </span>
<span class="lineNum">    9</span>              : &#047;&#047; any later version. </span>
<span class="lineNum">   10</span>              :  </span>
<span class="lineNum">   11</span>              : &#047;&#047; This library is distributed in the hope that it will be useful, </span>
<span class="lineNum">   12</span>              : &#047;&#047; but WITHOUT ANY WARRANTY; without even the implied warranty of </span>
<span class="lineNum">   13</span>              : &#047;&#047; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the </span>
<span class="lineNum">   14</span>              : &#047;&#047; GNU General Public License for more details. </span>
<span class="lineNum">   15</span>              :  </span>
<span class="lineNum">   16</span>              : &#047;&#047; Under Section 7 of GPL version 3, you are granted additional </span>
<span class="lineNum">   17</span>              : &#047;&#047; permissions described in the GCC Runtime Library Exception, version </span>
<span class="lineNum">   18</span>              : &#047;&#047; 3.1, as published by the Free Software Foundation. </span>
<span class="lineNum">   19</span>              :  </span>
<span class="lineNum">   20</span>              : &#047;&#047; You should have received a copy of the GNU General Public License and </span>
<span class="lineNum">   21</span>              : &#047;&#047; a copy of the GCC Runtime Library Exception along with this program; </span>
<span class="lineNum">   22</span>              : &#047;&#047; see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see </span>
<span class="lineNum">   23</span>              : &#047;&#047; &lt;http:&#047;&#047;www.gnu.org&#047;licenses&#047;&gt;. </span>
<span class="lineNum">   24</span>              :  </span>
<span class="lineNum">   25</span>              : &#047;* </span>
<span class="lineNum">   26</span>              :  * </span>
<span class="lineNum">   27</span>              :  * Copyright (c) 1994 </span>
<span class="lineNum">   28</span>              :  * Hewlett-Packard Company </span>
<span class="lineNum">   29</span>              :  * </span>
<span class="lineNum">   30</span>              :  * Permission to use, copy, modify, distribute and sell this software </span>
<span class="lineNum">   31</span>              :  * and its documentation for any purpose is hereby granted without fee, </span>
<span class="lineNum">   32</span>              :  * provided that the above copyright notice appear in all copies and </span>
<span class="lineNum">   33</span>              :  * that both that copyright notice and this permission notice appear </span>
<span class="lineNum">   34</span>              :  * in supporting documentation.  Hewlett-Packard Company makes no </span>
<span class="lineNum">   35</span>              :  * representations about the suitability of this software for any </span>
<span class="lineNum">   36</span>              :  * purpose.  It is provided &quot;as is&quot; without express or implied warranty. </span>
<span class="lineNum">   37</span>              :  * </span>
<span class="lineNum">   38</span>              :  * </span>
<span class="lineNum">   39</span>              :  * Copyright (c) 1996,1997 </span>
<span class="lineNum">   40</span>              :  * Silicon Graphics Computer Systems, Inc. </span>
<span class="lineNum">   41</span>              :  * </span>
<span class="lineNum">   42</span>              :  * Permission to use, copy, modify, distribute and sell this software </span>
<span class="lineNum">   43</span>              :  * and its documentation for any purpose is hereby granted without fee, </span>
<span class="lineNum">   44</span>              :  * provided that the above copyright notice appear in all copies and </span>
<span class="lineNum">   45</span>              :  * that both that copyright notice and this permission notice appear </span>
<span class="lineNum">   46</span>              :  * in supporting documentation.  Silicon Graphics makes no </span>
<span class="lineNum">   47</span>              :  * representations about the suitability of this software for any </span>
<span class="lineNum">   48</span>              :  * purpose.  It is provided &quot;as is&quot; without express or implied warranty. </span>
<span class="lineNum">   49</span>              :  *&#047; </span>
<span class="lineNum">   50</span>              :  </span>
<span class="lineNum">   51</span>              : &#047;** @file bits&#047;stl_list.h </span>
<span class="lineNum">   52</span>              :  *  This is an internal header file, included by other library headers. </span>
<span class="lineNum">   53</span>              :  *  Do not attempt to use it directly. @headername{list} </span>
<span class="lineNum">   54</span>              :  *&#047; </span>
<span class="lineNum">   55</span>              :  </span>
<span class="lineNum">   56</span>              : #ifndef _STL_LIST_H </span>
<span class="lineNum">   57</span>              : #define _STL_LIST_H 1 </span>
<span class="lineNum">   58</span>              :  </span>
<span class="lineNum">   59</span>              : #include &lt;bits&#047;concept_check.h&gt; </span>
<span class="lineNum">   60</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">   61</span>              : #include &lt;initializer_list&gt; </span>
<span class="lineNum">   62</span>              : #endif </span>
<span class="lineNum">   63</span>              :  </span>
<span class="lineNum">   64</span>              : namespace std _GLIBCXX_VISIBILITY(default) </span>
<span class="lineNum">   65</span>              : { </span>
<span class="lineNum">   66</span>              :   namespace __detail </span>
<span class="lineNum">   67</span>              :   { </span>
<span class="lineNum">   68</span>              :   _GLIBCXX_BEGIN_NAMESPACE_VERSION </span>
<span class="lineNum">   69</span>              :  </span>
<span class="lineNum">   70</span>              :     &#047;&#047; Supporting structures are split into common and templated </span>
<span class="lineNum">   71</span>              :     &#047;&#047; types; the latter publicly inherits from the former in an </span>
<span class="lineNum">   72</span>              :     &#047;&#047; effort to reduce code duplication.  This results in some </span>
<span class="lineNum">   73</span>              :     &#047;&#047; &quot;needless&quot; static_cast&#039;ing later on, but it&#039;s all safe </span>
<span class="lineNum">   74</span>              :     &#047;&#047; downcasting. </span>
<span class="lineNum">   75</span>              :  </span>
<span class="lineNum">   76</span>              :     &#047;&#047;&#047; Common part of a node in the %list.  </span>
<span class="lineNum">   77</span>              :     struct _List_node_base </span>
<span class="lineNum">   78</span>              :     { </span>
<span class="lineNum">   79</span>              :       _List_node_base* _M_next; </span>
<span class="lineNum">   80</span>              :       _List_node_base* _M_prev; </span>
<span class="lineNum">   81</span>              :  </span>
<span class="lineNum">   82</span>              :       static void </span>
<span class="lineNum">   83</span>              :       swap(_List_node_base&amp; __x, _List_node_base&amp; __y) _GLIBCXX_USE_NOEXCEPT; </span>
<span class="lineNum">   84</span>              :  </span>
<span class="lineNum">   85</span>              :       void </span>
<span class="lineNum">   86</span>              :       _M_transfer(_List_node_base* const __first, </span>
<span class="lineNum">   87</span>              : 		  _List_node_base* const __last) _GLIBCXX_USE_NOEXCEPT; </span>
<span class="lineNum">   88</span>              :  </span>
<span class="lineNum">   89</span>              :       void </span>
<span class="lineNum">   90</span>              :       _M_reverse() _GLIBCXX_USE_NOEXCEPT; </span>
<span class="lineNum">   91</span>              :  </span>
<span class="lineNum">   92</span>              :       void </span>
<span class="lineNum">   93</span>              :       _M_hook(_List_node_base* const __position) _GLIBCXX_USE_NOEXCEPT; </span>
<span class="lineNum">   94</span>              :  </span>
<span class="lineNum">   95</span>              :       void </span>
<span class="lineNum">   96</span>              :       _M_unhook() _GLIBCXX_USE_NOEXCEPT; </span>
<span class="lineNum">   97</span>              :     }; </span>
<span class="lineNum">   98</span>              :  </span>
<span class="lineNum">   99</span>              :   _GLIBCXX_END_NAMESPACE_VERSION </span>
<span class="lineNum">  100</span>              :   } &#047;&#047; namespace detail </span>
<span class="lineNum">  101</span>              :  </span>
<span class="lineNum">  102</span>              : _GLIBCXX_BEGIN_NAMESPACE_CONTAINER </span>
<span class="lineNum">  103</span>              :  </span>
<span class="lineNum">  104</span>              :   &#047;&#047;&#047; An actual node in the %list. </span>
<span class="lineNum">  105</span>              :   template&lt;typename _Tp&gt; </span>
<span class="lineNum">  106</span><span class="linePartCov">      2  /   3:     struct _List_node : public __detail::_List_node_base </span>
<span class="lineNum">  107</span>              :     { </span>
<span class="lineNum">  108</span>              :       &#047;&#047;&#047;&lt; User&#039;s data. </span>
<span class="lineNum">  109</span>              :       _Tp _M_data; </span>
<span class="lineNum">  110</span>              :  </span>
<span class="lineNum">  111</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  112</span>              :       template&lt;typename... _Args&gt; </span>
<span class="lineNum">  113</span><span class="linePartCov">      7  /  10:         _List_node(_Args&amp;&amp;... __args) </span>
<span class="lineNum">  114</span><span class="linePartCov">      7  /  10: 	: __detail::_List_node_base(), _M_data(std::forward&lt;_Args&gt;(__args)...)  </span>
<span class="lineNum">  115</span><span class="linePartCov">      7  /  20:         { } </span>
<span class="lineNum">  116</span>              : #endif </span>
<span class="lineNum">  117</span>              :     }; </span>
<span class="lineNum">  118</span>              :  </span>
<span class="lineNum">  119</span>              :   &#047;** </span>
<span class="lineNum">  120</span>              :    *  @brief A list::iterator. </span>
<span class="lineNum">  121</span>              :    * </span>
<span class="lineNum">  122</span>              :    *  All the functions are op overloads. </span>
<span class="lineNum">  123</span>              :   *&#047; </span>
<span class="lineNum">  124</span>              :   template&lt;typename _Tp&gt; </span>
<span class="lineNum">  125</span>              :     struct _List_iterator </span>
<span class="lineNum">  126</span>              :     { </span>
<span class="lineNum">  127</span>              :       typedef _List_iterator&lt;_Tp&gt;                _Self; </span>
<span class="lineNum">  128</span>              :       typedef _List_node&lt;_Tp&gt;                    _Node; </span>
<span class="lineNum">  129</span>              :  </span>
<span class="lineNum">  130</span>              :       typedef ptrdiff_t                          difference_type; </span>
<span class="lineNum">  131</span>              :       typedef std::bidirectional_iterator_tag    iterator_category; </span>
<span class="lineNum">  132</span>              :       typedef _Tp                                value_type; </span>
<span class="lineNum">  133</span>              :       typedef _Tp*                               pointer; </span>
<span class="lineNum">  134</span>              :       typedef _Tp&amp;                               reference; </span>
<span class="lineNum">  135</span>              :  </span>
<span class="lineNum">  136</span>              :       _List_iterator() </span>
<span class="lineNum">  137</span>              :       : _M_node() { } </span>
<span class="lineNum">  138</span>              :  </span>
<span class="lineNum">  139</span>              :       explicit </span>
<span class="lineNum">  140</span><span class="linePartCov">      7  /  10:       _List_iterator(__detail::_List_node_base* __x) </span>
<span class="lineNum">  141</span><span class="linePartCov">      7  /  20:       : _M_node(__x) { } </span>
<span class="lineNum">  142</span>              :  </span>
<span class="lineNum">  143</span>              :       &#047;&#047; Must downcast from _List_node_base to _List_node to get to _M_data. </span>
<span class="lineNum">  144</span>              :       reference </span>
<span class="lineNum">  145</span><span class="linePartCov">      6  /   9:       operator*() const </span>
<span class="lineNum">  146</span><span class="linePartCov">      6  /  18:       { return static_cast&lt;_Node*&gt;(_M_node)-&gt;_M_data; } </span>
<span class="lineNum">  147</span>              :  </span>
<span class="lineNum">  148</span>              :       pointer </span>
<span class="lineNum">  149</span>              :       operator-&gt;() const </span>
<span class="lineNum">  150</span>              :       { return std::__addressof(static_cast&lt;_Node*&gt;(_M_node)-&gt;_M_data); } </span>
<span class="lineNum">  151</span>              :  </span>
<span class="lineNum">  152</span>              :       _Self&amp; </span>
<span class="lineNum">  153</span><span class="linePartCov">      6  /   8:       operator++() </span>
<span class="lineNum">  154</span>              :       { </span>
<span class="lineNum">  155</span><span class="linePartCov">      6  /   8: 	_M_node = _M_node-&gt;_M_next; </span>
<span class="lineNum">  156</span><span class="linePartCov">      6  /   8: 	return *this; </span>
<span class="lineNum">  157</span><span class="linePartCov">      6  /  16:       } </span>
<span class="lineNum">  158</span>              :  </span>
<span class="lineNum">  159</span>              :       _Self </span>
<span class="lineNum">  160</span>              :       operator++(int) </span>
<span class="lineNum">  161</span>              :       { </span>
<span class="lineNum">  162</span>              : 	_Self __tmp = *this; </span>
<span class="lineNum">  163</span>              : 	_M_node = _M_node-&gt;_M_next; </span>
<span class="lineNum">  164</span>              : 	return __tmp; </span>
<span class="lineNum">  165</span>              :       } </span>
<span class="lineNum">  166</span>              :  </span>
<span class="lineNum">  167</span>              :       _Self&amp; </span>
<span class="lineNum">  168</span>              :       operator--() </span>
<span class="lineNum">  169</span>              :       { </span>
<span class="lineNum">  170</span>              : 	_M_node = _M_node-&gt;_M_prev; </span>
<span class="lineNum">  171</span>              : 	return *this; </span>
<span class="lineNum">  172</span>              :       } </span>
<span class="lineNum">  173</span>              :  </span>
<span class="lineNum">  174</span>              :       _Self </span>
<span class="lineNum">  175</span>              :       operator--(int) </span>
<span class="lineNum">  176</span>              :       { </span>
<span class="lineNum">  177</span>              : 	_Self __tmp = *this; </span>
<span class="lineNum">  178</span>              : 	_M_node = _M_node-&gt;_M_prev; </span>
<span class="lineNum">  179</span>              : 	return __tmp; </span>
<span class="lineNum">  180</span>              :       } </span>
<span class="lineNum">  181</span>              :  </span>
<span class="lineNum">  182</span>              :       bool </span>
<span class="lineNum">  183</span>              :       operator==(const _Self&amp; __x) const </span>
<span class="lineNum">  184</span>              :       { return _M_node == __x._M_node; } </span>
<span class="lineNum">  185</span>              :  </span>
<span class="lineNum">  186</span>              :       bool </span>
<span class="lineNum">  187</span><span class="linePartCov">      6  /   8:       operator!=(const _Self&amp; __x) const </span>
<span class="lineNum">  188</span><span class="linePartCov">      6  /  16:       { return _M_node != __x._M_node; } </span>
<span class="lineNum">  189</span>              :  </span>
<span class="lineNum">  190</span>              :       &#047;&#047; The only member points to the %list element. </span>
<span class="lineNum">  191</span>              :       __detail::_List_node_base* _M_node; </span>
<span class="lineNum">  192</span>              :     }; </span>
<span class="lineNum">  193</span>              :  </span>
<span class="lineNum">  194</span>              :   &#047;** </span>
<span class="lineNum">  195</span>              :    *  @brief A list::const_iterator. </span>
<span class="lineNum">  196</span>              :    * </span>
<span class="lineNum">  197</span>              :    *  All the functions are op overloads. </span>
<span class="lineNum">  198</span>              :   *&#047; </span>
<span class="lineNum">  199</span>              :   template&lt;typename _Tp&gt; </span>
<span class="lineNum">  200</span>              :     struct _List_const_iterator </span>
<span class="lineNum">  201</span>              :     { </span>
<span class="lineNum">  202</span>              :       typedef _List_const_iterator&lt;_Tp&gt;          _Self; </span>
<span class="lineNum">  203</span>              :       typedef const _List_node&lt;_Tp&gt;              _Node; </span>
<span class="lineNum">  204</span>              :       typedef _List_iterator&lt;_Tp&gt;                iterator; </span>
<span class="lineNum">  205</span>              :  </span>
<span class="lineNum">  206</span>              :       typedef ptrdiff_t                          difference_type; </span>
<span class="lineNum">  207</span>              :       typedef std::bidirectional_iterator_tag    iterator_category; </span>
<span class="lineNum">  208</span>              :       typedef _Tp                                value_type; </span>
<span class="lineNum">  209</span>              :       typedef const _Tp*                         pointer; </span>
<span class="lineNum">  210</span>              :       typedef const _Tp&amp;                         reference; </span>
<span class="lineNum">  211</span>              :  </span>
<span class="lineNum">  212</span>              :       _List_const_iterator() </span>
<span class="lineNum">  213</span>              :       : _M_node() { } </span>
<span class="lineNum">  214</span>              :  </span>
<span class="lineNum">  215</span>              :       explicit </span>
<span class="lineNum">  216</span><span class="lineNoCov">      0  /   2:       _List_const_iterator(const __detail::_List_node_base* __x) </span>
<span class="lineNum">  217</span><span class="linePartCov">      1  /   4:       : _M_node(__x) { } </span>
<span class="lineNum">  218</span>              :  </span>
<span class="lineNum">  219</span>              :       _List_const_iterator(const iterator&amp; __x) </span>
<span class="lineNum">  220</span>              :       : _M_node(__x._M_node) { } </span>
<span class="lineNum">  221</span>              :  </span>
<span class="lineNum">  222</span>              :       &#047;&#047; Must downcast from List_node_base to _List_node to get to </span>
<span class="lineNum">  223</span>              :       &#047;&#047; _M_data. </span>
<span class="lineNum">  224</span>              :       reference </span>
<span class="lineNum">  225</span><span class="lineCov">      1  /   1:       operator*() const </span>
<span class="lineNum">  226</span><span class="linePartCov">      1  /   2:       { return static_cast&lt;_Node*&gt;(_M_node)-&gt;_M_data; } </span>
<span class="lineNum">  227</span>              :  </span>
<span class="lineNum">  228</span>              :       pointer </span>
<span class="lineNum">  229</span>              :       operator-&gt;() const </span>
<span class="lineNum">  230</span>              :       { return std::__addressof(static_cast&lt;_Node*&gt;(_M_node)-&gt;_M_data); } </span>
<span class="lineNum">  231</span>              :  </span>
<span class="lineNum">  232</span>              :       _Self&amp; </span>
<span class="lineNum">  233</span><span class="linePartCov">      1  /   2:       operator++() </span>
<span class="lineNum">  234</span>              :       { </span>
<span class="lineNum">  235</span><span class="linePartCov">      1  /   2: 	_M_node = _M_node-&gt;_M_next; </span>
<span class="lineNum">  236</span><span class="linePartCov">      1  /   2: 	return *this; </span>
<span class="lineNum">  237</span><span class="linePartCov">      1  /   4:       } </span>
<span class="lineNum">  238</span>              :  </span>
<span class="lineNum">  239</span>              :       _Self </span>
<span class="lineNum">  240</span>              :       operator++(int) </span>
<span class="lineNum">  241</span>              :       { </span>
<span class="lineNum">  242</span>              : 	_Self __tmp = *this; </span>
<span class="lineNum">  243</span>              : 	_M_node = _M_node-&gt;_M_next; </span>
<span class="lineNum">  244</span>              : 	return __tmp; </span>
<span class="lineNum">  245</span>              :       } </span>
<span class="lineNum">  246</span>              :  </span>
<span class="lineNum">  247</span>              :       _Self&amp; </span>
<span class="lineNum">  248</span>              :       operator--() </span>
<span class="lineNum">  249</span>              :       { </span>
<span class="lineNum">  250</span>              : 	_M_node = _M_node-&gt;_M_prev; </span>
<span class="lineNum">  251</span>              : 	return *this; </span>
<span class="lineNum">  252</span>              :       } </span>
<span class="lineNum">  253</span>              :  </span>
<span class="lineNum">  254</span>              :       _Self </span>
<span class="lineNum">  255</span>              :       operator--(int) </span>
<span class="lineNum">  256</span>              :       { </span>
<span class="lineNum">  257</span>              : 	_Self __tmp = *this; </span>
<span class="lineNum">  258</span>              : 	_M_node = _M_node-&gt;_M_prev; </span>
<span class="lineNum">  259</span>              : 	return __tmp; </span>
<span class="lineNum">  260</span>              :       } </span>
<span class="lineNum">  261</span>              :  </span>
<span class="lineNum">  262</span>              :       bool </span>
<span class="lineNum">  263</span>              :       operator==(const _Self&amp; __x) const </span>
<span class="lineNum">  264</span>              :       { return _M_node == __x._M_node; } </span>
<span class="lineNum">  265</span>              :  </span>
<span class="lineNum">  266</span>              :       bool </span>
<span class="lineNum">  267</span><span class="linePartCov">      1  /   2:       operator!=(const _Self&amp; __x) const </span>
<span class="lineNum">  268</span><span class="linePartCov">      1  /   4:       { return _M_node != __x._M_node; } </span>
<span class="lineNum">  269</span>              :  </span>
<span class="lineNum">  270</span>              :       &#047;&#047; The only member points to the %list element. </span>
<span class="lineNum">  271</span>              :       const __detail::_List_node_base* _M_node; </span>
<span class="lineNum">  272</span>              :     }; </span>
<span class="lineNum">  273</span>              :  </span>
<span class="lineNum">  274</span>              :   template&lt;typename _Val&gt; </span>
<span class="lineNum">  275</span>              :     inline bool </span>
<span class="lineNum">  276</span>              :     operator==(const _List_iterator&lt;_Val&gt;&amp; __x, </span>
<span class="lineNum">  277</span>              : 	       const _List_const_iterator&lt;_Val&gt;&amp; __y) </span>
<span class="lineNum">  278</span>              :     { return __x._M_node == __y._M_node; } </span>
<span class="lineNum">  279</span>              :  </span>
<span class="lineNum">  280</span>              :   template&lt;typename _Val&gt; </span>
<span class="lineNum">  281</span>              :     inline bool </span>
<span class="lineNum">  282</span>              :     operator!=(const _List_iterator&lt;_Val&gt;&amp; __x, </span>
<span class="lineNum">  283</span>              :                const _List_const_iterator&lt;_Val&gt;&amp; __y) </span>
<span class="lineNum">  284</span>              :     { return __x._M_node != __y._M_node; } </span>
<span class="lineNum">  285</span>              :  </span>
<span class="lineNum">  286</span>              :  </span>
<span class="lineNum">  287</span>              :   &#047;&#047;&#047; See bits&#047;stl_deque.h&#039;s _Deque_base for an explanation. </span>
<span class="lineNum">  288</span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum">  289</span>              :     class _List_base </span>
<span class="lineNum">  290</span>              :     { </span>
<span class="lineNum">  291</span>              :     protected: </span>
<span class="lineNum">  292</span>              :       &#047;&#047; NOTA BENE </span>
<span class="lineNum">  293</span>              :       &#047;&#047; The stored instance is not actually of &quot;allocator_type&quot;&#039;s </span>
<span class="lineNum">  294</span>              :       &#047;&#047; type.  Instead we rebind the type to </span>
<span class="lineNum">  295</span>              :       &#047;&#047; Allocator&lt;List_node&lt;Tp&gt;&gt;, which according to [20.1.5]&#047;4 </span>
<span class="lineNum">  296</span>              :       &#047;&#047; should probably be the same.  List_node&lt;Tp&gt; is not the same </span>
<span class="lineNum">  297</span>              :       &#047;&#047; size as Tp (it&#039;s two pointers larger), and specializations on </span>
<span class="lineNum">  298</span>              :       &#047;&#047; Tp may go unused because List_node&lt;Tp&gt; is being bound </span>
<span class="lineNum">  299</span>              :       &#047;&#047; instead. </span>
<span class="lineNum">  300</span>              :       &#047;&#047; </span>
<span class="lineNum">  301</span>              :       &#047;&#047; We put this to the test in the constructors and in </span>
<span class="lineNum">  302</span>              :       &#047;&#047; get_allocator, where we use conversions between </span>
<span class="lineNum">  303</span>              :       &#047;&#047; allocator_type and _Node_alloc_type. The conversion is </span>
<span class="lineNum">  304</span>              :       &#047;&#047; required by table 32 in [20.1.5]. </span>
<span class="lineNum">  305</span>              :       typedef typename _Alloc::template rebind&lt;_List_node&lt;_Tp&gt; &gt;::other </span>
<span class="lineNum">  306</span>              :         _Node_alloc_type; </span>
<span class="lineNum">  307</span>              :  </span>
<span class="lineNum">  308</span>              :       typedef typename _Alloc::template rebind&lt;_Tp&gt;::other _Tp_alloc_type; </span>
<span class="lineNum">  309</span>              :  </span>
<span class="lineNum">  310</span><span class="linePartCov">     12  /  30:       struct _List_impl </span>
<span class="lineNum">  311</span>              :       : public _Node_alloc_type </span>
<span class="lineNum">  312</span>              :       { </span>
<span class="lineNum">  313</span>              : 	__detail::_List_node_base _M_node; </span>
<span class="lineNum">  314</span>              :  </span>
<span class="lineNum">  315</span><span class="linePartCov">      9  /  10: 	_List_impl() </span>
<span class="lineNum">  316</span><span class="lineCov">     10  /  10: 	: _Node_alloc_type(), _M_node() </span>
<span class="lineNum">  317</span><span class="linePartCov">     10  /  20: 	{ } </span>
<span class="lineNum">  318</span>              :  </span>
<span class="lineNum">  319</span>              : 	_List_impl(const _Node_alloc_type&amp; __a) </span>
<span class="lineNum">  320</span>              : 	: _Node_alloc_type(__a), _M_node() </span>
<span class="lineNum">  321</span>              : 	{ } </span>
<span class="lineNum">  322</span>              :  </span>
<span class="lineNum">  323</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  324</span>              : 	_List_impl(_Node_alloc_type&amp;&amp; __a) </span>
<span class="lineNum">  325</span>              : 	: _Node_alloc_type(std::move(__a)), _M_node() </span>
<span class="lineNum">  326</span>              : 	{ } </span>
<span class="lineNum">  327</span>              : #endif </span>
<span class="lineNum">  328</span>              :       }; </span>
<span class="lineNum">  329</span>              :  </span>
<span class="lineNum">  330</span>              :       _List_impl _M_impl; </span>
<span class="lineNum">  331</span>              :  </span>
<span class="lineNum">  332</span>              :       _List_node&lt;_Tp&gt;* </span>
<span class="lineNum">  333</span><span class="linePartCov">      7  /  10:       _M_get_node() </span>
<span class="lineNum">  334</span><span class="linePartCov">      7  /  20:       { return _M_impl._Node_alloc_type::allocate(1); } </span>
<span class="lineNum">  335</span>              :  </span>
<span class="lineNum">  336</span>              :       void </span>
<span class="lineNum">  337</span><span class="linePartCov">      3  /  10:       _M_put_node(_List_node&lt;_Tp&gt;* __p) </span>
<span class="lineNum">  338</span><span class="linePartCov">      4  /  20:       { _M_impl._Node_alloc_type::deallocate(__p, 1); } </span>
<span class="lineNum">  339</span>              :  </span>
<span class="lineNum">  340</span>              :   public: </span>
<span class="lineNum">  341</span>              :       typedef _Alloc allocator_type; </span>
<span class="lineNum">  342</span>              :  </span>
<span class="lineNum">  343</span>              :       _Node_alloc_type&amp; </span>
<span class="lineNum">  344</span><span class="linePartCov">      7  /  10:       _M_get_Node_allocator() _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  345</span><span class="linePartCov">      7  /  20:       { return *static_cast&lt;_Node_alloc_type*&gt;(&amp;_M_impl); } </span>
<span class="lineNum">  346</span>              :  </span>
<span class="lineNum">  347</span>              :       const _Node_alloc_type&amp; </span>
<span class="lineNum">  348</span>              :       _M_get_Node_allocator() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  349</span>              :       { return *static_cast&lt;const _Node_alloc_type*&gt;(&amp;_M_impl); } </span>
<span class="lineNum">  350</span>              :  </span>
<span class="lineNum">  351</span>              :       _Tp_alloc_type </span>
<span class="lineNum">  352</span>              :       _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  353</span>              :       { return _Tp_alloc_type(_M_get_Node_allocator()); } </span>
<span class="lineNum">  354</span>              :  </span>
<span class="lineNum">  355</span>              :       allocator_type </span>
<span class="lineNum">  356</span>              :       get_allocator() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  357</span>              :       { return allocator_type(_M_get_Node_allocator()); } </span>
<span class="lineNum">  358</span>              :  </span>
<span class="lineNum">  359</span><span class="lineCov">     10  /  10:       _List_base() </span>
<span class="lineNum">  360</span><span class="lineCov">     10  /  10:       : _M_impl() </span>
<span class="lineNum">  361</span><span class="linePartCov">     10  /  20:       { _M_init(); } </span>
<span class="lineNum">  362</span>              :  </span>
<span class="lineNum">  363</span>              :       _List_base(const _Node_alloc_type&amp; __a) </span>
<span class="lineNum">  364</span>              :       : _M_impl(__a) </span>
<span class="lineNum">  365</span>              :       { _M_init(); } </span>
<span class="lineNum">  366</span>              :  </span>
<span class="lineNum">  367</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  368</span>              :       _List_base(_List_base&amp;&amp; __x) </span>
<span class="lineNum">  369</span>              :       : _M_impl(std::move(__x._M_get_Node_allocator())) </span>
<span class="lineNum">  370</span>              :       { </span>
<span class="lineNum">  371</span>              : 	_M_init(); </span>
<span class="lineNum">  372</span>              : 	__detail::_List_node_base::swap(_M_impl._M_node, __x._M_impl._M_node); </span>
<span class="lineNum">  373</span>              :       } </span>
<span class="lineNum">  374</span>              : #endif </span>
<span class="lineNum">  375</span>              :  </span>
<span class="lineNum">  376</span>              :       &#047;&#047; This is what actually destroys the list. </span>
<span class="lineNum">  377</span><span class="linePartCov">      6  /  10:       ~_List_base() _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  378</span><span class="linePartCov">      7  /  20:       { _M_clear(); } </span>
<span class="lineNum">  379</span>              :  </span>
<span class="lineNum">  380</span>              :       void </span>
<span class="lineNum">  381</span>              :       _M_clear(); </span>
<span class="lineNum">  382</span>              :  </span>
<span class="lineNum">  383</span>              :       void </span>
<span class="lineNum">  384</span><span class="linePartCov">      9  /  10:       _M_init() </span>
<span class="lineNum">  385</span>              :       { </span>
<span class="lineNum">  386</span><span class="lineCov">     10  /  10:         this-&gt;_M_impl._M_node._M_next = &amp;this-&gt;_M_impl._M_node; </span>
<span class="lineNum">  387</span><span class="lineCov">     10  /  10:         this-&gt;_M_impl._M_node._M_prev = &amp;this-&gt;_M_impl._M_node; </span>
<span class="lineNum">  388</span><span class="linePartCov">     10  /  20:       } </span>
<span class="lineNum">  389</span>              :     }; </span>
<span class="lineNum">  390</span>              :  </span>
<span class="lineNum">  391</span>              :   &#047;** </span>
<span class="lineNum">  392</span>              :    *  @brief A standard container with linear time access to elements, </span>
<span class="lineNum">  393</span>              :    *  and fixed time insertion&#047;deletion at any point in the sequence. </span>
<span class="lineNum">  394</span>              :    * </span>
<span class="lineNum">  395</span>              :    *  @ingroup sequences </span>
<span class="lineNum">  396</span>              :    * </span>
<span class="lineNum">  397</span>              :    *  @tparam _Tp  Type of element. </span>
<span class="lineNum">  398</span>              :    *  @tparam _Alloc  Allocator type, defaults to allocator&lt;_Tp&gt;. </span>
<span class="lineNum">  399</span>              :    * </span>
<span class="lineNum">  400</span>              :    *  Meets the requirements of a &lt;a href=&quot;tables.html#65&quot;&gt;container&lt;&#047;a&gt;, a </span>
<span class="lineNum">  401</span>              :    *  &lt;a href=&quot;tables.html#66&quot;&gt;reversible container&lt;&#047;a&gt;, and a </span>
<span class="lineNum">  402</span>              :    *  &lt;a href=&quot;tables.html#67&quot;&gt;sequence&lt;&#047;a&gt;, including the </span>
<span class="lineNum">  403</span>              :    *  &lt;a href=&quot;tables.html#68&quot;&gt;optional sequence requirements&lt;&#047;a&gt; with the </span>
<span class="lineNum">  404</span>              :    *  %exception of @c at and @c operator[]. </span>
<span class="lineNum">  405</span>              :    * </span>
<span class="lineNum">  406</span>              :    *  This is a @e doubly @e linked %list.  Traversal up and down the </span>
<span class="lineNum">  407</span>              :    *  %list requires linear time, but adding and removing elements (or </span>
<span class="lineNum">  408</span>              :    *  @e nodes) is done in constant time, regardless of where the </span>
<span class="lineNum">  409</span>              :    *  change takes place.  Unlike std::vector and std::deque, </span>
<span class="lineNum">  410</span>              :    *  random-access iterators are not provided, so subscripting ( @c </span>
<span class="lineNum">  411</span>              :    *  [] ) access is not allowed.  For algorithms which only need </span>
<span class="lineNum">  412</span>              :    *  sequential access, this lack makes no difference. </span>
<span class="lineNum">  413</span>              :    * </span>
<span class="lineNum">  414</span>              :    *  Also unlike the other standard containers, std::list provides </span>
<span class="lineNum">  415</span>              :    *  specialized algorithms %unique to linked lists, such as </span>
<span class="lineNum">  416</span>              :    *  splicing, sorting, and in-place reversal. </span>
<span class="lineNum">  417</span>              :    * </span>
<span class="lineNum">  418</span>              :    *  A couple points on memory allocation for list&lt;Tp&gt;: </span>
<span class="lineNum">  419</span>              :    * </span>
<span class="lineNum">  420</span>              :    *  First, we never actually allocate a Tp, we allocate </span>
<span class="lineNum">  421</span>              :    *  List_node&lt;Tp&gt;&#039;s and trust [20.1.5]&#047;4 to DTRT.  This is to ensure </span>
<span class="lineNum">  422</span>              :    *  that after elements from %list&lt;X,Alloc1&gt; are spliced into </span>
<span class="lineNum">  423</span>              :    *  %list&lt;X,Alloc2&gt;, destroying the memory of the second %list is a </span>
<span class="lineNum">  424</span>              :    *  valid operation, i.e., Alloc1 giveth and Alloc2 taketh away. </span>
<span class="lineNum">  425</span>              :    * </span>
<span class="lineNum">  426</span>              :    *  Second, a %list conceptually represented as </span>
<span class="lineNum">  427</span>              :    *  @code </span>
<span class="lineNum">  428</span>              :    *    A &lt;---&gt; B &lt;---&gt; C &lt;---&gt; D </span>
<span class="lineNum">  429</span>              :    *  @endcode </span>
<span class="lineNum">  430</span>              :    *  is actually circular; a link exists between A and D.  The %list </span>
<span class="lineNum">  431</span>              :    *  class holds (as its only data member) a private list::iterator </span>
<span class="lineNum">  432</span>              :    *  pointing to @e D, not to @e A!  To get to the head of the %list, </span>
<span class="lineNum">  433</span>              :    *  we start at the tail and move forward by one.  When this member </span>
<span class="lineNum">  434</span>              :    *  iterator&#039;s next&#047;previous pointers refer to itself, the %list is </span>
<span class="lineNum">  435</span>              :    *  %empty.  </span>
<span class="lineNum">  436</span>              :   *&#047; </span>
<span class="lineNum">  437</span>              :   template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt; &gt; </span>
<span class="lineNum">  438</span><span class="linePartCov">     14  /  27:     class list : protected _List_base&lt;_Tp, _Alloc&gt; </span>
<span class="lineNum">  439</span>              :     { </span>
<span class="lineNum">  440</span>              :       &#047;&#047; concept requirements </span>
<span class="lineNum">  441</span>              :       typedef typename _Alloc::value_type                _Alloc_value_type; </span>
<span class="lineNum">  442</span>              :       __glibcxx_class_requires(_Tp, _SGIAssignableConcept) </span>
<span class="lineNum">  443</span>              :       __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept) </span>
<span class="lineNum">  444</span>              :  </span>
<span class="lineNum">  445</span>              :       typedef _List_base&lt;_Tp, _Alloc&gt;                    _Base; </span>
<span class="lineNum">  446</span>              :       typedef typename _Base::_Tp_alloc_type		 _Tp_alloc_type; </span>
<span class="lineNum">  447</span>              :       typedef typename _Base::_Node_alloc_type		 _Node_alloc_type; </span>
<span class="lineNum">  448</span>              :  </span>
<span class="lineNum">  449</span>              :     public: </span>
<span class="lineNum">  450</span>              :       typedef _Tp                                        value_type; </span>
<span class="lineNum">  451</span>              :       typedef typename _Tp_alloc_type::pointer           pointer; </span>
<span class="lineNum">  452</span>              :       typedef typename _Tp_alloc_type::const_pointer     const_pointer; </span>
<span class="lineNum">  453</span>              :       typedef typename _Tp_alloc_type::reference         reference; </span>
<span class="lineNum">  454</span>              :       typedef typename _Tp_alloc_type::const_reference   const_reference; </span>
<span class="lineNum">  455</span>              :       typedef _List_iterator&lt;_Tp&gt;                        iterator; </span>
<span class="lineNum">  456</span>              :       typedef _List_const_iterator&lt;_Tp&gt;                  const_iterator; </span>
<span class="lineNum">  457</span>              :       typedef std::reverse_iterator&lt;const_iterator&gt;      const_reverse_iterator; </span>
<span class="lineNum">  458</span>              :       typedef std::reverse_iterator&lt;iterator&gt;            reverse_iterator; </span>
<span class="lineNum">  459</span>              :       typedef size_t                                     size_type; </span>
<span class="lineNum">  460</span>              :       typedef ptrdiff_t                                  difference_type; </span>
<span class="lineNum">  461</span>              :       typedef _Alloc                                     allocator_type; </span>
<span class="lineNum">  462</span>              :  </span>
<span class="lineNum">  463</span>              :     protected: </span>
<span class="lineNum">  464</span>              :       &#047;&#047; Note that pointers-to-_Node&#039;s can be ctor-converted to </span>
<span class="lineNum">  465</span>              :       &#047;&#047; iterator types. </span>
<span class="lineNum">  466</span>              :       typedef _List_node&lt;_Tp&gt;				 _Node; </span>
<span class="lineNum">  467</span>              :  </span>
<span class="lineNum">  468</span>              :       using _Base::_M_impl; </span>
<span class="lineNum">  469</span>              :       using _Base::_M_put_node; </span>
<span class="lineNum">  470</span>              :       using _Base::_M_get_node; </span>
<span class="lineNum">  471</span>              :       using _Base::_M_get_Tp_allocator; </span>
<span class="lineNum">  472</span>              :       using _Base::_M_get_Node_allocator; </span>
<span class="lineNum">  473</span>              :  </span>
<span class="lineNum">  474</span>              :       &#047;** </span>
<span class="lineNum">  475</span>              :        *  @param  __args  An instance of user data. </span>
<span class="lineNum">  476</span>              :        * </span>
<span class="lineNum">  477</span>              :        *  Allocates space for a new node and constructs a copy of </span>
<span class="lineNum">  478</span>              :        *  @a __args in it. </span>
<span class="lineNum">  479</span>              :        *&#047; </span>
<span class="lineNum">  480</span>              : #if __cplusplus &lt; 201103L </span>
<span class="lineNum">  481</span>              :       _Node* </span>
<span class="lineNum">  482</span>              :       _M_create_node(const value_type&amp; __x) </span>
<span class="lineNum">  483</span>              :       { </span>
<span class="lineNum">  484</span>              : 	_Node* __p = this-&gt;_M_get_node(); </span>
<span class="lineNum">  485</span>              : 	__try </span>
<span class="lineNum">  486</span>              : 	  { </span>
<span class="lineNum">  487</span>              : 	    _M_get_Tp_allocator().construct </span>
<span class="lineNum">  488</span>              : 	      (std::__addressof(__p-&gt;_M_data), __x); </span>
<span class="lineNum">  489</span>              : 	  } </span>
<span class="lineNum">  490</span>              : 	__catch(...) </span>
<span class="lineNum">  491</span>              : 	  { </span>
<span class="lineNum">  492</span>              : 	    _M_put_node(__p); </span>
<span class="lineNum">  493</span>              : 	    __throw_exception_again; </span>
<span class="lineNum">  494</span>              : 	  } </span>
<span class="lineNum">  495</span>              : 	return __p; </span>
<span class="lineNum">  496</span>              :       } </span>
<span class="lineNum">  497</span>              : #else </span>
<span class="lineNum">  498</span>              :       template&lt;typename... _Args&gt; </span>
<span class="lineNum">  499</span>              :         _Node* </span>
<span class="lineNum">  500</span><span class="linePartCov">      7  /  10:         _M_create_node(_Args&amp;&amp;... __args) </span>
<span class="lineNum">  501</span>              : 	{ </span>
<span class="lineNum">  502</span><span class="linePartCov">      7  /  10: 	  _Node* __p = this-&gt;_M_get_node(); </span>
<span class="lineNum">  503</span>              : 	  __try </span>
<span class="lineNum">  504</span>              : 	    { </span>
<span class="lineNum">  505</span><span class="linePartCov">      7  /  10: 	      _M_get_Node_allocator().construct(__p, </span>
<span class="lineNum">  506</span><span class="linePartCov">      7  /  10: 						std::forward&lt;_Args&gt;(__args)...); </span>
<span class="lineNum">  507</span>              : 	    } </span>
<span class="lineNum">  508</span><span class="lineNoCov">      0  /  10: 	  __catch(...) </span>
<span class="lineNum">  509</span>              : 	    { </span>
<span class="lineNum">  510</span><span class="lineNoCov">      0  /  10: 	      _M_put_node(__p); </span>
<span class="lineNum">  511</span><span class="lineNoCov">      0  /  10: 	      __throw_exception_again; </span>
<span class="lineNum">  512</span>              : 	    } </span>
<span class="lineNum">  513</span><span class="linePartCov">      7  /  10: 	  return __p; </span>
<span class="lineNum">  514</span><span class="linePartCov">      8  /  20: 	} </span>
<span class="lineNum">  515</span>              : #endif </span>
<span class="lineNum">  516</span>              :  </span>
<span class="lineNum">  517</span>              :     public: </span>
<span class="lineNum">  518</span>              :       &#047;&#047; [23.2.2.1] construct&#047;copy&#047;destroy </span>
<span class="lineNum">  519</span>              :       &#047;&#047; (assign() and get_allocator() are also listed in this section) </span>
<span class="lineNum">  520</span>              :       &#047;** </span>
<span class="lineNum">  521</span>              :        *  @brief  Default constructor creates no elements. </span>
<span class="lineNum">  522</span>              :        *&#047; </span>
<span class="lineNum">  523</span><span class="linePartCov">      9  /  10:       list() </span>
<span class="lineNum">  524</span><span class="linePartCov">     10  /  20:       : _Base() { } </span>
<span class="lineNum">  525</span>              :  </span>
<span class="lineNum">  526</span>              :       &#047;** </span>
<span class="lineNum">  527</span>              :        *  @brief  Creates a %list with no elements. </span>
<span class="lineNum">  528</span>              :        *  @param  __a  An allocator object. </span>
<span class="lineNum">  529</span>              :        *&#047; </span>
<span class="lineNum">  530</span>              :       explicit </span>
<span class="lineNum">  531</span>              :       list(const allocator_type&amp; __a) </span>
<span class="lineNum">  532</span>              :       : _Base(_Node_alloc_type(__a)) { } </span>
<span class="lineNum">  533</span>              :  </span>
<span class="lineNum">  534</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  535</span>              :       &#047;** </span>
<span class="lineNum">  536</span>              :        *  @brief  Creates a %list with default constructed elements. </span>
<span class="lineNum">  537</span>              :        *  @param  __n  The number of elements to initially create. </span>
<span class="lineNum">  538</span>              :        * </span>
<span class="lineNum">  539</span>              :        *  This constructor fills the %list with @a __n default </span>
<span class="lineNum">  540</span>              :        *  constructed elements. </span>
<span class="lineNum">  541</span>              :        *&#047; </span>
<span class="lineNum">  542</span>              :       explicit </span>
<span class="lineNum">  543</span>              :       list(size_type __n) </span>
<span class="lineNum">  544</span>              :       : _Base() </span>
<span class="lineNum">  545</span>              :       { _M_default_initialize(__n); } </span>
<span class="lineNum">  546</span>              :  </span>
<span class="lineNum">  547</span>              :       &#047;** </span>
<span class="lineNum">  548</span>              :        *  @brief  Creates a %list with copies of an exemplar element. </span>
<span class="lineNum">  549</span>              :        *  @param  __n  The number of elements to initially create. </span>
<span class="lineNum">  550</span>              :        *  @param  __value  An element to copy. </span>
<span class="lineNum">  551</span>              :        *  @param  __a  An allocator object. </span>
<span class="lineNum">  552</span>              :        * </span>
<span class="lineNum">  553</span>              :        *  This constructor fills the %list with @a __n copies of @a __value. </span>
<span class="lineNum">  554</span>              :        *&#047; </span>
<span class="lineNum">  555</span>              :       list(size_type __n, const value_type&amp; __value, </span>
<span class="lineNum">  556</span>              : 	   const allocator_type&amp; __a = allocator_type()) </span>
<span class="lineNum">  557</span>              :       : _Base(_Node_alloc_type(__a)) </span>
<span class="lineNum">  558</span>              :       { _M_fill_initialize(__n, __value); } </span>
<span class="lineNum">  559</span>              : #else </span>
<span class="lineNum">  560</span>              :       &#047;** </span>
<span class="lineNum">  561</span>              :        *  @brief  Creates a %list with copies of an exemplar element. </span>
<span class="lineNum">  562</span>              :        *  @param  __n  The number of elements to initially create. </span>
<span class="lineNum">  563</span>              :        *  @param  __value  An element to copy. </span>
<span class="lineNum">  564</span>              :        *  @param  __a  An allocator object. </span>
<span class="lineNum">  565</span>              :        * </span>
<span class="lineNum">  566</span>              :        *  This constructor fills the %list with @a __n copies of @a __value. </span>
<span class="lineNum">  567</span>              :        *&#047; </span>
<span class="lineNum">  568</span>              :       explicit </span>
<span class="lineNum">  569</span>              :       list(size_type __n, const value_type&amp; __value = value_type(), </span>
<span class="lineNum">  570</span>              : 	   const allocator_type&amp; __a = allocator_type()) </span>
<span class="lineNum">  571</span>              :       : _Base(_Node_alloc_type(__a)) </span>
<span class="lineNum">  572</span>              :       { _M_fill_initialize(__n, __value); } </span>
<span class="lineNum">  573</span>              : #endif </span>
<span class="lineNum">  574</span>              :  </span>
<span class="lineNum">  575</span>              :       &#047;** </span>
<span class="lineNum">  576</span>              :        *  @brief  %List copy constructor. </span>
<span class="lineNum">  577</span>              :        *  @param  __x  A %list of identical element and allocator types. </span>
<span class="lineNum">  578</span>              :        * </span>
<span class="lineNum">  579</span>              :        *  The newly-created %list uses a copy of the allocation object used </span>
<span class="lineNum">  580</span>              :        *  by @a __x. </span>
<span class="lineNum">  581</span>              :        *&#047; </span>
<span class="lineNum">  582</span>              :       list(const list&amp; __x) </span>
<span class="lineNum">  583</span>              :       : _Base(__x._M_get_Node_allocator()) </span>
<span class="lineNum">  584</span>              :       { _M_initialize_dispatch(__x.begin(), __x.end(), __false_type()); } </span>
<span class="lineNum">  585</span>              :  </span>
<span class="lineNum">  586</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  587</span>              :       &#047;** </span>
<span class="lineNum">  588</span>              :        *  @brief  %List move constructor. </span>
<span class="lineNum">  589</span>              :        *  @param  __x  A %list of identical element and allocator types. </span>
<span class="lineNum">  590</span>              :        * </span>
<span class="lineNum">  591</span>              :        *  The newly-created %list contains the exact contents of @a __x. </span>
<span class="lineNum">  592</span>              :        *  The contents of @a __x are a valid, but unspecified %list. </span>
<span class="lineNum">  593</span>              :        *&#047; </span>
<span class="lineNum">  594</span>              :       list(list&amp;&amp; __x) noexcept </span>
<span class="lineNum">  595</span>              :       : _Base(std::move(__x)) { } </span>
<span class="lineNum">  596</span>              :  </span>
<span class="lineNum">  597</span>              :       &#047;** </span>
<span class="lineNum">  598</span>              :        *  @brief  Builds a %list from an initializer_list </span>
<span class="lineNum">  599</span>              :        *  @param  __l  An initializer_list of value_type. </span>
<span class="lineNum">  600</span>              :        *  @param  __a  An allocator object. </span>
<span class="lineNum">  601</span>              :        * </span>
<span class="lineNum">  602</span>              :        *  Create a %list consisting of copies of the elements in the </span>
<span class="lineNum">  603</span>              :        *  initializer_list @a __l.  This is linear in __l.size(). </span>
<span class="lineNum">  604</span>              :        *&#047; </span>
<span class="lineNum">  605</span>              :       list(initializer_list&lt;value_type&gt; __l, </span>
<span class="lineNum">  606</span>              :            const allocator_type&amp; __a = allocator_type()) </span>
<span class="lineNum">  607</span>              :       : _Base(_Node_alloc_type(__a)) </span>
<span class="lineNum">  608</span>              :       { _M_initialize_dispatch(__l.begin(), __l.end(), __false_type()); } </span>
<span class="lineNum">  609</span>              : #endif </span>
<span class="lineNum">  610</span>              :  </span>
<span class="lineNum">  611</span>              :       &#047;** </span>
<span class="lineNum">  612</span>              :        *  @brief  Builds a %list from a range. </span>
<span class="lineNum">  613</span>              :        *  @param  __first  An input iterator. </span>
<span class="lineNum">  614</span>              :        *  @param  __last  An input iterator. </span>
<span class="lineNum">  615</span>              :        *  @param  __a  An allocator object. </span>
<span class="lineNum">  616</span>              :        * </span>
<span class="lineNum">  617</span>              :        *  Create a %list consisting of copies of the elements from </span>
<span class="lineNum">  618</span>              :        *  [@a __first,@a __last).  This is linear in N (where N is </span>
<span class="lineNum">  619</span>              :        *  distance(@a __first,@a __last)). </span>
<span class="lineNum">  620</span>              :        *&#047; </span>
<span class="lineNum">  621</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  622</span>              :       template&lt;typename _InputIterator, </span>
<span class="lineNum">  623</span>              : 	       typename = std::_RequireInputIter&lt;_InputIterator&gt;&gt; </span>
<span class="lineNum">  624</span>              :         list(_InputIterator __first, _InputIterator __last, </span>
<span class="lineNum">  625</span>              : 	     const allocator_type&amp; __a = allocator_type()) </span>
<span class="lineNum">  626</span>              : 	: _Base(_Node_alloc_type(__a)) </span>
<span class="lineNum">  627</span>              :         { _M_initialize_dispatch(__first, __last, __false_type()); } </span>
<span class="lineNum">  628</span>              : #else </span>
<span class="lineNum">  629</span>              :       template&lt;typename _InputIterator&gt; </span>
<span class="lineNum">  630</span>              :         list(_InputIterator __first, _InputIterator __last, </span>
<span class="lineNum">  631</span>              : 	     const allocator_type&amp; __a = allocator_type()) </span>
<span class="lineNum">  632</span>              : 	: _Base(_Node_alloc_type(__a)) </span>
<span class="lineNum">  633</span>              :         {  </span>
<span class="lineNum">  634</span>              : 	  &#047;&#047; Check whether it&#039;s an integral type.  If so, it&#039;s not an iterator. </span>
<span class="lineNum">  635</span>              : 	  typedef typename std::__is_integer&lt;_InputIterator&gt;::__type _Integral; </span>
<span class="lineNum">  636</span>              : 	  _M_initialize_dispatch(__first, __last, _Integral()); </span>
<span class="lineNum">  637</span>              : 	} </span>
<span class="lineNum">  638</span>              : #endif </span>
<span class="lineNum">  639</span>              :  </span>
<span class="lineNum">  640</span>              :       &#047;** </span>
<span class="lineNum">  641</span>              :        *  No explicit dtor needed as the _Base dtor takes care of </span>
<span class="lineNum">  642</span>              :        *  things.  The _Base dtor only erases the elements, and note </span>
<span class="lineNum">  643</span>              :        *  that if the elements themselves are pointers, the pointed-to </span>
<span class="lineNum">  644</span>              :        *  memory is not touched in any way.  Managing the pointer is </span>
<span class="lineNum">  645</span>              :        *  the user&#039;s responsibility. </span>
<span class="lineNum">  646</span>              :        *&#047; </span>
<span class="lineNum">  647</span>              :  </span>
<span class="lineNum">  648</span>              :       &#047;** </span>
<span class="lineNum">  649</span>              :        *  @brief  %List assignment operator. </span>
<span class="lineNum">  650</span>              :        *  @param  __x  A %list of identical element and allocator types. </span>
<span class="lineNum">  651</span>              :        * </span>
<span class="lineNum">  652</span>              :        *  All the elements of @a __x are copied, but unlike the copy </span>
<span class="lineNum">  653</span>              :        *  constructor, the allocator object is not copied. </span>
<span class="lineNum">  654</span>              :        *&#047; </span>
<span class="lineNum">  655</span>              :       list&amp; </span>
<span class="lineNum">  656</span>              :       operator=(const list&amp; __x); </span>
<span class="lineNum">  657</span>              :  </span>
<span class="lineNum">  658</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  659</span>              :       &#047;** </span>
<span class="lineNum">  660</span>              :        *  @brief  %List move assignment operator. </span>
<span class="lineNum">  661</span>              :        *  @param  __x  A %list of identical element and allocator types. </span>
<span class="lineNum">  662</span>              :        * </span>
<span class="lineNum">  663</span>              :        *  The contents of @a __x are moved into this %list (without copying). </span>
<span class="lineNum">  664</span>              :        *  @a __x is a valid, but unspecified %list </span>
<span class="lineNum">  665</span>              :        *&#047; </span>
<span class="lineNum">  666</span>              :       list&amp; </span>
<span class="lineNum">  667</span>              :       operator=(list&amp;&amp; __x) </span>
<span class="lineNum">  668</span>              :       { </span>
<span class="lineNum">  669</span>              : 	&#047;&#047; NB: DR 1204. </span>
<span class="lineNum">  670</span>              : 	&#047;&#047; NB: DR 675. </span>
<span class="lineNum">  671</span>              : 	this-&gt;clear(); </span>
<span class="lineNum">  672</span>              : 	this-&gt;swap(__x); </span>
<span class="lineNum">  673</span>              : 	return *this; </span>
<span class="lineNum">  674</span>              :       } </span>
<span class="lineNum">  675</span>              :  </span>
<span class="lineNum">  676</span>              :       &#047;** </span>
<span class="lineNum">  677</span>              :        *  @brief  %List initializer list assignment operator. </span>
<span class="lineNum">  678</span>              :        *  @param  __l  An initializer_list of value_type. </span>
<span class="lineNum">  679</span>              :        * </span>
<span class="lineNum">  680</span>              :        *  Replace the contents of the %list with copies of the elements </span>
<span class="lineNum">  681</span>              :        *  in the initializer_list @a __l.  This is linear in l.size(). </span>
<span class="lineNum">  682</span>              :        *&#047; </span>
<span class="lineNum">  683</span>              :       list&amp; </span>
<span class="lineNum">  684</span>              :       operator=(initializer_list&lt;value_type&gt; __l) </span>
<span class="lineNum">  685</span>              :       { </span>
<span class="lineNum">  686</span>              : 	this-&gt;assign(__l.begin(), __l.end()); </span>
<span class="lineNum">  687</span>              : 	return *this; </span>
<span class="lineNum">  688</span>              :       } </span>
<span class="lineNum">  689</span>              : #endif </span>
<span class="lineNum">  690</span>              :  </span>
<span class="lineNum">  691</span>              :       &#047;** </span>
<span class="lineNum">  692</span>              :        *  @brief  Assigns a given value to a %list. </span>
<span class="lineNum">  693</span>              :        *  @param  __n  Number of elements to be assigned. </span>
<span class="lineNum">  694</span>              :        *  @param  __val  Value to be assigned. </span>
<span class="lineNum">  695</span>              :        * </span>
<span class="lineNum">  696</span>              :        *  This function fills a %list with @a __n copies of the given </span>
<span class="lineNum">  697</span>              :        *  value.  Note that the assignment completely changes the %list </span>
<span class="lineNum">  698</span>              :        *  and that the resulting %list&#039;s size is the same as the number </span>
<span class="lineNum">  699</span>              :        *  of elements assigned.  Old data may be lost. </span>
<span class="lineNum">  700</span>              :        *&#047; </span>
<span class="lineNum">  701</span>              :       void </span>
<span class="lineNum">  702</span>              :       assign(size_type __n, const value_type&amp; __val) </span>
<span class="lineNum">  703</span>              :       { _M_fill_assign(__n, __val); } </span>
<span class="lineNum">  704</span>              :  </span>
<span class="lineNum">  705</span>              :       &#047;** </span>
<span class="lineNum">  706</span>              :        *  @brief  Assigns a range to a %list. </span>
<span class="lineNum">  707</span>              :        *  @param  __first  An input iterator. </span>
<span class="lineNum">  708</span>              :        *  @param  __last   An input iterator. </span>
<span class="lineNum">  709</span>              :        * </span>
<span class="lineNum">  710</span>              :        *  This function fills a %list with copies of the elements in the </span>
<span class="lineNum">  711</span>              :        *  range [@a __first,@a __last). </span>
<span class="lineNum">  712</span>              :        * </span>
<span class="lineNum">  713</span>              :        *  Note that the assignment completely changes the %list and </span>
<span class="lineNum">  714</span>              :        *  that the resulting %list&#039;s size is the same as the number of </span>
<span class="lineNum">  715</span>              :        *  elements assigned.  Old data may be lost. </span>
<span class="lineNum">  716</span>              :        *&#047; </span>
<span class="lineNum">  717</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  718</span>              :       template&lt;typename _InputIterator, </span>
<span class="lineNum">  719</span>              : 	       typename = std::_RequireInputIter&lt;_InputIterator&gt;&gt; </span>
<span class="lineNum">  720</span>              :         void </span>
<span class="lineNum">  721</span>              :         assign(_InputIterator __first, _InputIterator __last) </span>
<span class="lineNum">  722</span>              :         { _M_assign_dispatch(__first, __last, __false_type()); } </span>
<span class="lineNum">  723</span>              : #else </span>
<span class="lineNum">  724</span>              :       template&lt;typename _InputIterator&gt; </span>
<span class="lineNum">  725</span>              :         void </span>
<span class="lineNum">  726</span>              :         assign(_InputIterator __first, _InputIterator __last) </span>
<span class="lineNum">  727</span>              :         { </span>
<span class="lineNum">  728</span>              : 	  &#047;&#047; Check whether it&#039;s an integral type.  If so, it&#039;s not an iterator. </span>
<span class="lineNum">  729</span>              : 	  typedef typename std::__is_integer&lt;_InputIterator&gt;::__type _Integral; </span>
<span class="lineNum">  730</span>              : 	  _M_assign_dispatch(__first, __last, _Integral()); </span>
<span class="lineNum">  731</span>              : 	} </span>
<span class="lineNum">  732</span>              : #endif </span>
<span class="lineNum">  733</span>              :  </span>
<span class="lineNum">  734</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  735</span>              :       &#047;** </span>
<span class="lineNum">  736</span>              :        *  @brief  Assigns an initializer_list to a %list. </span>
<span class="lineNum">  737</span>              :        *  @param  __l  An initializer_list of value_type. </span>
<span class="lineNum">  738</span>              :        * </span>
<span class="lineNum">  739</span>              :        *  Replace the contents of the %list with copies of the elements </span>
<span class="lineNum">  740</span>              :        *  in the initializer_list @a __l.  This is linear in __l.size(). </span>
<span class="lineNum">  741</span>              :        *&#047; </span>
<span class="lineNum">  742</span>              :       void </span>
<span class="lineNum">  743</span>              :       assign(initializer_list&lt;value_type&gt; __l) </span>
<span class="lineNum">  744</span>              :       { this-&gt;assign(__l.begin(), __l.end()); } </span>
<span class="lineNum">  745</span>              : #endif </span>
<span class="lineNum">  746</span>              :  </span>
<span class="lineNum">  747</span>              :       &#047;&#047;&#047; Get a copy of the memory allocation object. </span>
<span class="lineNum">  748</span>              :       allocator_type </span>
<span class="lineNum">  749</span>              :       get_allocator() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  750</span>              :       { return _Base::get_allocator(); } </span>
<span class="lineNum">  751</span>              :  </span>
<span class="lineNum">  752</span>              :       &#047;&#047; iterators </span>
<span class="lineNum">  753</span>              :       &#047;** </span>
<span class="lineNum">  754</span>              :        *  Returns a read&#047;write iterator that points to the first element in the </span>
<span class="lineNum">  755</span>              :        *  %list.  Iteration is done in ordinary element order. </span>
<span class="lineNum">  756</span>              :        *&#047; </span>
<span class="lineNum">  757</span>              :       iterator </span>
<span class="lineNum">  758</span><span class="linePartCov">      5  /   9:       begin() _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  759</span><span class="linePartCov">      6  /  18:       { return iterator(this-&gt;_M_impl._M_node._M_next); } </span>
<span class="lineNum">  760</span>              :  </span>
<span class="lineNum">  761</span>              :       &#047;** </span>
<span class="lineNum">  762</span>              :        *  Returns a read-only (constant) iterator that points to the </span>
<span class="lineNum">  763</span>              :        *  first element in the %list.  Iteration is done in ordinary </span>
<span class="lineNum">  764</span>              :        *  element order. </span>
<span class="lineNum">  765</span>              :        *&#047; </span>
<span class="lineNum">  766</span>              :       const_iterator </span>
<span class="lineNum">  767</span><span class="lineNoCov">      0  /   2:       begin() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  768</span><span class="linePartCov">      1  /   4:       { return const_iterator(this-&gt;_M_impl._M_node._M_next); } </span>
<span class="lineNum">  769</span>              :  </span>
<span class="lineNum">  770</span>              :       &#047;** </span>
<span class="lineNum">  771</span>              :        *  Returns a read&#047;write iterator that points one past the last </span>
<span class="lineNum">  772</span>              :        *  element in the %list.  Iteration is done in ordinary element </span>
<span class="lineNum">  773</span>              :        *  order. </span>
<span class="lineNum">  774</span>              :        *&#047; </span>
<span class="lineNum">  775</span>              :       iterator </span>
<span class="lineNum">  776</span><span class="linePartCov">      7  /  10:       end() _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  777</span><span class="linePartCov">      7  /  20:       { return iterator(&amp;this-&gt;_M_impl._M_node); } </span>
<span class="lineNum">  778</span>              :  </span>
<span class="lineNum">  779</span>              :       &#047;** </span>
<span class="lineNum">  780</span>              :        *  Returns a read-only (constant) iterator that points one past </span>
<span class="lineNum">  781</span>              :        *  the last element in the %list.  Iteration is done in ordinary </span>
<span class="lineNum">  782</span>              :        *  element order. </span>
<span class="lineNum">  783</span>              :        *&#047; </span>
<span class="lineNum">  784</span>              :       const_iterator </span>
<span class="lineNum">  785</span><span class="linePartCov">      1  /   2:       end() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  786</span><span class="linePartCov">      1  /   4:       { return const_iterator(&amp;this-&gt;_M_impl._M_node); } </span>
<span class="lineNum">  787</span>              :  </span>
<span class="lineNum">  788</span>              :       &#047;** </span>
<span class="lineNum">  789</span>              :        *  Returns a read&#047;write reverse iterator that points to the last </span>
<span class="lineNum">  790</span>              :        *  element in the %list.  Iteration is done in reverse element </span>
<span class="lineNum">  791</span>              :        *  order. </span>
<span class="lineNum">  792</span>              :        *&#047; </span>
<span class="lineNum">  793</span>              :       reverse_iterator </span>
<span class="lineNum">  794</span>              :       rbegin() _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  795</span>              :       { return reverse_iterator(end()); } </span>
<span class="lineNum">  796</span>              :  </span>
<span class="lineNum">  797</span>              :       &#047;** </span>
<span class="lineNum">  798</span>              :        *  Returns a read-only (constant) reverse iterator that points to </span>
<span class="lineNum">  799</span>              :        *  the last element in the %list.  Iteration is done in reverse </span>
<span class="lineNum">  800</span>              :        *  element order. </span>
<span class="lineNum">  801</span>              :        *&#047; </span>
<span class="lineNum">  802</span>              :       const_reverse_iterator </span>
<span class="lineNum">  803</span>              :       rbegin() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  804</span>              :       { return const_reverse_iterator(end()); } </span>
<span class="lineNum">  805</span>              :  </span>
<span class="lineNum">  806</span>              :       &#047;** </span>
<span class="lineNum">  807</span>              :        *  Returns a read&#047;write reverse iterator that points to one </span>
<span class="lineNum">  808</span>              :        *  before the first element in the %list.  Iteration is done in </span>
<span class="lineNum">  809</span>              :        *  reverse element order. </span>
<span class="lineNum">  810</span>              :        *&#047; </span>
<span class="lineNum">  811</span>              :       reverse_iterator </span>
<span class="lineNum">  812</span>              :       rend() _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  813</span>              :       { return reverse_iterator(begin()); } </span>
<span class="lineNum">  814</span>              :  </span>
<span class="lineNum">  815</span>              :       &#047;** </span>
<span class="lineNum">  816</span>              :        *  Returns a read-only (constant) reverse iterator that points to one </span>
<span class="lineNum">  817</span>              :        *  before the first element in the %list.  Iteration is done in reverse </span>
<span class="lineNum">  818</span>              :        *  element order. </span>
<span class="lineNum">  819</span>              :        *&#047; </span>
<span class="lineNum">  820</span>              :       const_reverse_iterator </span>
<span class="lineNum">  821</span>              :       rend() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  822</span>              :       { return const_reverse_iterator(begin()); } </span>
<span class="lineNum">  823</span>              :  </span>
<span class="lineNum">  824</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  825</span>              :       &#047;** </span>
<span class="lineNum">  826</span>              :        *  Returns a read-only (constant) iterator that points to the </span>
<span class="lineNum">  827</span>              :        *  first element in the %list.  Iteration is done in ordinary </span>
<span class="lineNum">  828</span>              :        *  element order. </span>
<span class="lineNum">  829</span>              :        *&#047; </span>
<span class="lineNum">  830</span>              :       const_iterator </span>
<span class="lineNum">  831</span>              :       cbegin() const noexcept </span>
<span class="lineNum">  832</span>              :       { return const_iterator(this-&gt;_M_impl._M_node._M_next); } </span>
<span class="lineNum">  833</span>              :  </span>
<span class="lineNum">  834</span>              :       &#047;** </span>
<span class="lineNum">  835</span>              :        *  Returns a read-only (constant) iterator that points one past </span>
<span class="lineNum">  836</span>              :        *  the last element in the %list.  Iteration is done in ordinary </span>
<span class="lineNum">  837</span>              :        *  element order. </span>
<span class="lineNum">  838</span>              :        *&#047; </span>
<span class="lineNum">  839</span>              :       const_iterator </span>
<span class="lineNum">  840</span>              :       cend() const noexcept </span>
<span class="lineNum">  841</span>              :       { return const_iterator(&amp;this-&gt;_M_impl._M_node); } </span>
<span class="lineNum">  842</span>              :  </span>
<span class="lineNum">  843</span>              :       &#047;** </span>
<span class="lineNum">  844</span>              :        *  Returns a read-only (constant) reverse iterator that points to </span>
<span class="lineNum">  845</span>              :        *  the last element in the %list.  Iteration is done in reverse </span>
<span class="lineNum">  846</span>              :        *  element order. </span>
<span class="lineNum">  847</span>              :        *&#047; </span>
<span class="lineNum">  848</span>              :       const_reverse_iterator </span>
<span class="lineNum">  849</span>              :       crbegin() const noexcept </span>
<span class="lineNum">  850</span>              :       { return const_reverse_iterator(end()); } </span>
<span class="lineNum">  851</span>              :  </span>
<span class="lineNum">  852</span>              :       &#047;** </span>
<span class="lineNum">  853</span>              :        *  Returns a read-only (constant) reverse iterator that points to one </span>
<span class="lineNum">  854</span>              :        *  before the first element in the %list.  Iteration is done in reverse </span>
<span class="lineNum">  855</span>              :        *  element order. </span>
<span class="lineNum">  856</span>              :        *&#047; </span>
<span class="lineNum">  857</span>              :       const_reverse_iterator </span>
<span class="lineNum">  858</span>              :       crend() const noexcept </span>
<span class="lineNum">  859</span>              :       { return const_reverse_iterator(begin()); } </span>
<span class="lineNum">  860</span>              : #endif </span>
<span class="lineNum">  861</span>              :  </span>
<span class="lineNum">  862</span>              :       &#047;&#047; [23.2.2.2] capacity </span>
<span class="lineNum">  863</span>              :       &#047;** </span>
<span class="lineNum">  864</span>              :        *  Returns true if the %list is empty.  (Thus begin() would equal </span>
<span class="lineNum">  865</span>              :        *  end().) </span>
<span class="lineNum">  866</span>              :        *&#047; </span>
<span class="lineNum">  867</span>              :       bool </span>
<span class="lineNum">  868</span><span class="lineNoCov">      0  /   1:       empty() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  869</span><span class="lineNoCov">      0  /   2:       { return this-&gt;_M_impl._M_node._M_next == &amp;this-&gt;_M_impl._M_node; } </span>
<span class="lineNum">  870</span>              :  </span>
<span class="lineNum">  871</span>              :       &#047;**  Returns the number of elements in the %list.  *&#047; </span>
<span class="lineNum">  872</span>              :       size_type </span>
<span class="lineNum">  873</span><span class="lineNoCov">      0  /   1:       size() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  874</span><span class="lineNoCov">      0  /   2:       { return std::distance(begin(), end()); } </span>
<span class="lineNum">  875</span>              :  </span>
<span class="lineNum">  876</span>              :       &#047;**  Returns the size() of the largest possible %list.  *&#047; </span>
<span class="lineNum">  877</span>              :       size_type </span>
<span class="lineNum">  878</span>              :       max_size() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  879</span>              :       { return _M_get_Node_allocator().max_size(); } </span>
<span class="lineNum">  880</span>              :  </span>
<span class="lineNum">  881</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  882</span>              :       &#047;** </span>
<span class="lineNum">  883</span>              :        *  @brief Resizes the %list to the specified number of elements. </span>
<span class="lineNum">  884</span>              :        *  @param __new_size Number of elements the %list should contain. </span>
<span class="lineNum">  885</span>              :        * </span>
<span class="lineNum">  886</span>              :        *  This function will %resize the %list to the specified number </span>
<span class="lineNum">  887</span>              :        *  of elements.  If the number is smaller than the %list&#039;s </span>
<span class="lineNum">  888</span>              :        *  current size the %list is truncated, otherwise default </span>
<span class="lineNum">  889</span>              :        *  constructed elements are appended. </span>
<span class="lineNum">  890</span>              :        *&#047; </span>
<span class="lineNum">  891</span>              :       void </span>
<span class="lineNum">  892</span>              :       resize(size_type __new_size); </span>
<span class="lineNum">  893</span>              :  </span>
<span class="lineNum">  894</span>              :       &#047;** </span>
<span class="lineNum">  895</span>              :        *  @brief Resizes the %list to the specified number of elements. </span>
<span class="lineNum">  896</span>              :        *  @param __new_size Number of elements the %list should contain. </span>
<span class="lineNum">  897</span>              :        *  @param __x Data with which new elements should be populated. </span>
<span class="lineNum">  898</span>              :        * </span>
<span class="lineNum">  899</span>              :        *  This function will %resize the %list to the specified number </span>
<span class="lineNum">  900</span>              :        *  of elements.  If the number is smaller than the %list&#039;s </span>
<span class="lineNum">  901</span>              :        *  current size the %list is truncated, otherwise the %list is </span>
<span class="lineNum">  902</span>              :        *  extended and new elements are populated with given data. </span>
<span class="lineNum">  903</span>              :        *&#047; </span>
<span class="lineNum">  904</span>              :       void </span>
<span class="lineNum">  905</span>              :       resize(size_type __new_size, const value_type&amp; __x); </span>
<span class="lineNum">  906</span>              : #else </span>
<span class="lineNum">  907</span>              :       &#047;** </span>
<span class="lineNum">  908</span>              :        *  @brief Resizes the %list to the specified number of elements. </span>
<span class="lineNum">  909</span>              :        *  @param __new_size Number of elements the %list should contain. </span>
<span class="lineNum">  910</span>              :        *  @param __x Data with which new elements should be populated. </span>
<span class="lineNum">  911</span>              :        * </span>
<span class="lineNum">  912</span>              :        *  This function will %resize the %list to the specified number </span>
<span class="lineNum">  913</span>              :        *  of elements.  If the number is smaller than the %list&#039;s </span>
<span class="lineNum">  914</span>              :        *  current size the %list is truncated, otherwise the %list is </span>
<span class="lineNum">  915</span>              :        *  extended and new elements are populated with given data. </span>
<span class="lineNum">  916</span>              :        *&#047; </span>
<span class="lineNum">  917</span>              :       void </span>
<span class="lineNum">  918</span>              :       resize(size_type __new_size, value_type __x = value_type()); </span>
<span class="lineNum">  919</span>              : #endif </span>
<span class="lineNum">  920</span>              :  </span>
<span class="lineNum">  921</span>              :       &#047;&#047; element access </span>
<span class="lineNum">  922</span>              :       &#047;** </span>
<span class="lineNum">  923</span>              :        *  Returns a read&#047;write reference to the data at the first </span>
<span class="lineNum">  924</span>              :        *  element of the %list. </span>
<span class="lineNum">  925</span>              :        *&#047; </span>
<span class="lineNum">  926</span>              :       reference </span>
<span class="lineNum">  927</span><span class="lineNoCov">      0  /   1:       front() </span>
<span class="lineNum">  928</span><span class="lineNoCov">      0  /   2:       { return *begin(); } </span>
<span class="lineNum">  929</span>              :  </span>
<span class="lineNum">  930</span>              :       &#047;** </span>
<span class="lineNum">  931</span>              :        *  Returns a read-only (constant) reference to the data at the first </span>
<span class="lineNum">  932</span>              :        *  element of the %list. </span>
<span class="lineNum">  933</span>              :        *&#047; </span>
<span class="lineNum">  934</span>              :       const_reference </span>
<span class="lineNum">  935</span>              :       front() const </span>
<span class="lineNum">  936</span>              :       { return *begin(); } </span>
<span class="lineNum">  937</span>              :  </span>
<span class="lineNum">  938</span>              :       &#047;** </span>
<span class="lineNum">  939</span>              :        *  Returns a read&#047;write reference to the data at the last element </span>
<span class="lineNum">  940</span>              :        *  of the %list. </span>
<span class="lineNum">  941</span>              :        *&#047; </span>
<span class="lineNum">  942</span>              :       reference </span>
<span class="lineNum">  943</span>              :       back() </span>
<span class="lineNum">  944</span>              :       {  </span>
<span class="lineNum">  945</span>              : 	iterator __tmp = end(); </span>
<span class="lineNum">  946</span>              : 	--__tmp; </span>
<span class="lineNum">  947</span>              : 	return *__tmp; </span>
<span class="lineNum">  948</span>              :       } </span>
<span class="lineNum">  949</span>              :  </span>
<span class="lineNum">  950</span>              :       &#047;** </span>
<span class="lineNum">  951</span>              :        *  Returns a read-only (constant) reference to the data at the last </span>
<span class="lineNum">  952</span>              :        *  element of the %list. </span>
<span class="lineNum">  953</span>              :        *&#047; </span>
<span class="lineNum">  954</span>              :       const_reference </span>
<span class="lineNum">  955</span>              :       back() const </span>
<span class="lineNum">  956</span>              :       {  </span>
<span class="lineNum">  957</span>              : 	const_iterator __tmp = end(); </span>
<span class="lineNum">  958</span>              : 	--__tmp; </span>
<span class="lineNum">  959</span>              : 	return *__tmp; </span>
<span class="lineNum">  960</span>              :       } </span>
<span class="lineNum">  961</span>              :  </span>
<span class="lineNum">  962</span>              :       &#047;&#047; [23.2.2.3] modifiers </span>
<span class="lineNum">  963</span>              :       &#047;** </span>
<span class="lineNum">  964</span>              :        *  @brief  Add data to the front of the %list. </span>
<span class="lineNum">  965</span>              :        *  @param  __x  Data to be added. </span>
<span class="lineNum">  966</span>              :        * </span>
<span class="lineNum">  967</span>              :        *  This is a typical stack operation.  The function creates an </span>
<span class="lineNum">  968</span>              :        *  element at the front of the %list and assigns the given data </span>
<span class="lineNum">  969</span>              :        *  to it.  Due to the nature of a %list this operation can be </span>
<span class="lineNum">  970</span>              :        *  done in constant time, and does not invalidate iterators and </span>
<span class="lineNum">  971</span>              :        *  references. </span>
<span class="lineNum">  972</span>              :        *&#047; </span>
<span class="lineNum">  973</span>              :       void </span>
<span class="lineNum">  974</span>              :       push_front(const value_type&amp; __x) </span>
<span class="lineNum">  975</span>              :       { this-&gt;_M_insert(begin(), __x); } </span>
<span class="lineNum">  976</span>              :  </span>
<span class="lineNum">  977</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  978</span>              :       void </span>
<span class="lineNum">  979</span>              :       push_front(value_type&amp;&amp; __x) </span>
<span class="lineNum">  980</span>              :       { this-&gt;_M_insert(begin(), std::move(__x)); } </span>
<span class="lineNum">  981</span>              :  </span>
<span class="lineNum">  982</span>              :       template&lt;typename... _Args&gt; </span>
<span class="lineNum">  983</span>              :         void </span>
<span class="lineNum">  984</span>              :         emplace_front(_Args&amp;&amp;... __args) </span>
<span class="lineNum">  985</span>              :         { this-&gt;_M_insert(begin(), std::forward&lt;_Args&gt;(__args)...); } </span>
<span class="lineNum">  986</span>              : #endif </span>
<span class="lineNum">  987</span>              :  </span>
<span class="lineNum">  988</span>              :       &#047;** </span>
<span class="lineNum">  989</span>              :        *  @brief  Removes first element. </span>
<span class="lineNum">  990</span>              :        * </span>
<span class="lineNum">  991</span>              :        *  This is a typical stack operation.  It shrinks the %list by </span>
<span class="lineNum">  992</span>              :        *  one.  Due to the nature of a %list this operation can be done </span>
<span class="lineNum">  993</span>              :        *  in constant time, and only invalidates iterators&#047;references to </span>
<span class="lineNum">  994</span>              :        *  the element being removed. </span>
<span class="lineNum">  995</span>              :        * </span>
<span class="lineNum">  996</span>              :        *  Note that no data is returned, and if the first element&#039;s data </span>
<span class="lineNum">  997</span>              :        *  is needed, it should be retrieved before pop_front() is </span>
<span class="lineNum">  998</span>              :        *  called. </span>
<span class="lineNum">  999</span>              :        *&#047; </span>
<span class="lineNum"> 1000</span>              :       void </span>
<span class="lineNum"> 1001</span><span class="lineNoCov">      0  /   1:       pop_front() </span>
<span class="lineNum"> 1002</span><span class="lineNoCov">      0  /   2:       { this-&gt;_M_erase(begin()); } </span>
<span class="lineNum"> 1003</span>              :  </span>
<span class="lineNum"> 1004</span>              :       &#047;** </span>
<span class="lineNum"> 1005</span>              :        *  @brief  Add data to the end of the %list. </span>
<span class="lineNum"> 1006</span>              :        *  @param  __x  Data to be added. </span>
<span class="lineNum"> 1007</span>              :        * </span>
<span class="lineNum"> 1008</span>              :        *  This is a typical stack operation.  The function creates an </span>
<span class="lineNum"> 1009</span>              :        *  element at the end of the %list and assigns the given data to </span>
<span class="lineNum"> 1010</span>              :        *  it.  Due to the nature of a %list this operation can be done </span>
<span class="lineNum"> 1011</span>              :        *  in constant time, and does not invalidate iterators and </span>
<span class="lineNum"> 1012</span>              :        *  references. </span>
<span class="lineNum"> 1013</span>              :        *&#047; </span>
<span class="lineNum"> 1014</span>              :       void </span>
<span class="lineNum"> 1015</span><span class="linePartCov">      1  /   3:       push_back(const value_type&amp; __x) </span>
<span class="lineNum"> 1016</span><span class="linePartCov">      1  /   6:       { this-&gt;_M_insert(end(), __x); } </span>
<span class="lineNum"> 1017</span>              :  </span>
<span class="lineNum"> 1018</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum"> 1019</span>              :       void </span>
<span class="lineNum"> 1020</span><span class="linePartCov">      6  /   7:       push_back(value_type&amp;&amp; __x) </span>
<span class="lineNum"> 1021</span><span class="linePartCov">      6  /  14:       { this-&gt;_M_insert(end(), std::move(__x)); } </span>
<span class="lineNum"> 1022</span>              :  </span>
<span class="lineNum"> 1023</span>              :       template&lt;typename... _Args&gt; </span>
<span class="lineNum"> 1024</span>              :         void </span>
<span class="lineNum"> 1025</span>              :         emplace_back(_Args&amp;&amp;... __args) </span>
<span class="lineNum"> 1026</span>              :         { this-&gt;_M_insert(end(), std::forward&lt;_Args&gt;(__args)...); } </span>
<span class="lineNum"> 1027</span>              : #endif </span>
<span class="lineNum"> 1028</span>              :  </span>
<span class="lineNum"> 1029</span>              :       &#047;** </span>
<span class="lineNum"> 1030</span>              :        *  @brief  Removes last element. </span>
<span class="lineNum"> 1031</span>              :        * </span>
<span class="lineNum"> 1032</span>              :        *  This is a typical stack operation.  It shrinks the %list by </span>
<span class="lineNum"> 1033</span>              :        *  one.  Due to the nature of a %list this operation can be done </span>
<span class="lineNum"> 1034</span>              :        *  in constant time, and only invalidates iterators&#047;references to </span>
<span class="lineNum"> 1035</span>              :        *  the element being removed. </span>
<span class="lineNum"> 1036</span>              :        * </span>
<span class="lineNum"> 1037</span>              :        *  Note that no data is returned, and if the last element&#039;s data </span>
<span class="lineNum"> 1038</span>              :        *  is needed, it should be retrieved before pop_back() is called. </span>
<span class="lineNum"> 1039</span>              :        *&#047; </span>
<span class="lineNum"> 1040</span>              :       void </span>
<span class="lineNum"> 1041</span>              :       pop_back() </span>
<span class="lineNum"> 1042</span>              :       { this-&gt;_M_erase(iterator(this-&gt;_M_impl._M_node._M_prev)); } </span>
<span class="lineNum"> 1043</span>              :  </span>
<span class="lineNum"> 1044</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum"> 1045</span>              :       &#047;** </span>
<span class="lineNum"> 1046</span>              :        *  @brief  Constructs object in %list before specified iterator. </span>
<span class="lineNum"> 1047</span>              :        *  @param  __position  A const_iterator into the %list. </span>
<span class="lineNum"> 1048</span>              :        *  @param  __args  Arguments. </span>
<span class="lineNum"> 1049</span>              :        *  @return  An iterator that points to the inserted data. </span>
<span class="lineNum"> 1050</span>              :        * </span>
<span class="lineNum"> 1051</span>              :        *  This function will insert an object of type T constructed </span>
<span class="lineNum"> 1052</span>              :        *  with T(std::forward&lt;Args&gt;(args)...) before the specified </span>
<span class="lineNum"> 1053</span>              :        *  location.  Due to the nature of a %list this operation can </span>
<span class="lineNum"> 1054</span>              :        *  be done in constant time, and does not invalidate iterators </span>
<span class="lineNum"> 1055</span>              :        *  and references. </span>
<span class="lineNum"> 1056</span>              :        *&#047; </span>
<span class="lineNum"> 1057</span>              :       template&lt;typename... _Args&gt; </span>
<span class="lineNum"> 1058</span>              :         iterator </span>
<span class="lineNum"> 1059</span>              :         emplace(iterator __position, _Args&amp;&amp;... __args); </span>
<span class="lineNum"> 1060</span>              : #endif </span>
<span class="lineNum"> 1061</span>              :  </span>
<span class="lineNum"> 1062</span>              :       &#047;** </span>
<span class="lineNum"> 1063</span>              :        *  @brief  Inserts given value into %list before specified iterator. </span>
<span class="lineNum"> 1064</span>              :        *  @param  __position  An iterator into the %list. </span>
<span class="lineNum"> 1065</span>              :        *  @param  __x  Data to be inserted. </span>
<span class="lineNum"> 1066</span>              :        *  @return  An iterator that points to the inserted data. </span>
<span class="lineNum"> 1067</span>              :        * </span>
<span class="lineNum"> 1068</span>              :        *  This function will insert a copy of the given value before </span>
<span class="lineNum"> 1069</span>              :        *  the specified location.  Due to the nature of a %list this </span>
<span class="lineNum"> 1070</span>              :        *  operation can be done in constant time, and does not </span>
<span class="lineNum"> 1071</span>              :        *  invalidate iterators and references. </span>
<span class="lineNum"> 1072</span>              :        *&#047; </span>
<span class="lineNum"> 1073</span>              :       iterator </span>
<span class="lineNum"> 1074</span>              :       insert(iterator __position, const value_type&amp; __x); </span>
<span class="lineNum"> 1075</span>              :  </span>
<span class="lineNum"> 1076</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum"> 1077</span>              :       &#047;** </span>
<span class="lineNum"> 1078</span>              :        *  @brief  Inserts given rvalue into %list before specified iterator. </span>
<span class="lineNum"> 1079</span>              :        *  @param  __position  An iterator into the %list. </span>
<span class="lineNum"> 1080</span>              :        *  @param  __x  Data to be inserted. </span>
<span class="lineNum"> 1081</span>              :        *  @return  An iterator that points to the inserted data. </span>
<span class="lineNum"> 1082</span>              :        * </span>
<span class="lineNum"> 1083</span>              :        *  This function will insert a copy of the given rvalue before </span>
<span class="lineNum"> 1084</span>              :        *  the specified location.  Due to the nature of a %list this </span>
<span class="lineNum"> 1085</span>              :        *  operation can be done in constant time, and does not </span>
<span class="lineNum"> 1086</span>              :        *  invalidate iterators and references. </span>
<span class="lineNum"> 1087</span>              :         *&#047; </span>
<span class="lineNum"> 1088</span>              :       iterator </span>
<span class="lineNum"> 1089</span>              :       insert(iterator __position, value_type&amp;&amp; __x) </span>
<span class="lineNum"> 1090</span>              :       { return emplace(__position, std::move(__x)); } </span>
<span class="lineNum"> 1091</span>              :  </span>
<span class="lineNum"> 1092</span>              :       &#047;** </span>
<span class="lineNum"> 1093</span>              :        *  @brief  Inserts the contents of an initializer_list into %list </span>
<span class="lineNum"> 1094</span>              :        *          before specified iterator. </span>
<span class="lineNum"> 1095</span>              :        *  @param  __p  An iterator into the %list. </span>
<span class="lineNum"> 1096</span>              :        *  @param  __l  An initializer_list of value_type. </span>
<span class="lineNum"> 1097</span>              :        * </span>
<span class="lineNum"> 1098</span>              :        *  This function will insert copies of the data in the </span>
<span class="lineNum"> 1099</span>              :        *  initializer_list @a l into the %list before the location </span>
<span class="lineNum"> 1100</span>              :        *  specified by @a p. </span>
<span class="lineNum"> 1101</span>              :        * </span>
<span class="lineNum"> 1102</span>              :        *  This operation is linear in the number of elements inserted and </span>
<span class="lineNum"> 1103</span>              :        *  does not invalidate iterators and references. </span>
<span class="lineNum"> 1104</span>              :        *&#047; </span>
<span class="lineNum"> 1105</span>              :       void </span>
<span class="lineNum"> 1106</span>              :       insert(iterator __p, initializer_list&lt;value_type&gt; __l) </span>
<span class="lineNum"> 1107</span>              :       { this-&gt;insert(__p, __l.begin(), __l.end()); } </span>
<span class="lineNum"> 1108</span>              : #endif </span>
<span class="lineNum"> 1109</span>              :  </span>
<span class="lineNum"> 1110</span>              :       &#047;** </span>
<span class="lineNum"> 1111</span>              :        *  @brief  Inserts a number of copies of given data into the %list. </span>
<span class="lineNum"> 1112</span>              :        *  @param  __position  An iterator into the %list. </span>
<span class="lineNum"> 1113</span>              :        *  @param  __n  Number of elements to be inserted. </span>
<span class="lineNum"> 1114</span>              :        *  @param  __x  Data to be inserted. </span>
<span class="lineNum"> 1115</span>              :        * </span>
<span class="lineNum"> 1116</span>              :        *  This function will insert a specified number of copies of the </span>
<span class="lineNum"> 1117</span>              :        *  given data before the location specified by @a position. </span>
<span class="lineNum"> 1118</span>              :        * </span>
<span class="lineNum"> 1119</span>              :        *  This operation is linear in the number of elements inserted and </span>
<span class="lineNum"> 1120</span>              :        *  does not invalidate iterators and references. </span>
<span class="lineNum"> 1121</span>              :        *&#047; </span>
<span class="lineNum"> 1122</span>              :       void </span>
<span class="lineNum"> 1123</span>              :       insert(iterator __position, size_type __n, const value_type&amp; __x) </span>
<span class="lineNum"> 1124</span>              :       { </span>
<span class="lineNum"> 1125</span>              : 	list __tmp(__n, __x, get_allocator()); </span>
<span class="lineNum"> 1126</span>              : 	splice(__position, __tmp); </span>
<span class="lineNum"> 1127</span>              :       } </span>
<span class="lineNum"> 1128</span>              :  </span>
<span class="lineNum"> 1129</span>              :       &#047;** </span>
<span class="lineNum"> 1130</span>              :        *  @brief  Inserts a range into the %list. </span>
<span class="lineNum"> 1131</span>              :        *  @param  __position  An iterator into the %list. </span>
<span class="lineNum"> 1132</span>              :        *  @param  __first  An input iterator. </span>
<span class="lineNum"> 1133</span>              :        *  @param  __last   An input iterator. </span>
<span class="lineNum"> 1134</span>              :        * </span>
<span class="lineNum"> 1135</span>              :        *  This function will insert copies of the data in the range [@a </span>
<span class="lineNum"> 1136</span>              :        *  first,@a last) into the %list before the location specified by </span>
<span class="lineNum"> 1137</span>              :        *  @a position. </span>
<span class="lineNum"> 1138</span>              :        * </span>
<span class="lineNum"> 1139</span>              :        *  This operation is linear in the number of elements inserted and </span>
<span class="lineNum"> 1140</span>              :        *  does not invalidate iterators and references. </span>
<span class="lineNum"> 1141</span>              :        *&#047; </span>
<span class="lineNum"> 1142</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum"> 1143</span>              :       template&lt;typename _InputIterator, </span>
<span class="lineNum"> 1144</span>              : 	       typename = std::_RequireInputIter&lt;_InputIterator&gt;&gt; </span>
<span class="lineNum"> 1145</span>              : #else </span>
<span class="lineNum"> 1146</span>              :       template&lt;typename _InputIterator&gt; </span>
<span class="lineNum"> 1147</span>              : #endif </span>
<span class="lineNum"> 1148</span>              :         void </span>
<span class="lineNum"> 1149</span>              :         insert(iterator __position, _InputIterator __first, </span>
<span class="lineNum"> 1150</span>              : 	       _InputIterator __last) </span>
<span class="lineNum"> 1151</span>              :         { </span>
<span class="lineNum"> 1152</span>              : 	  list __tmp(__first, __last, get_allocator()); </span>
<span class="lineNum"> 1153</span>              : 	  splice(__position, __tmp); </span>
<span class="lineNum"> 1154</span>              : 	} </span>
<span class="lineNum"> 1155</span>              :  </span>
<span class="lineNum"> 1156</span>              :       &#047;** </span>
<span class="lineNum"> 1157</span>              :        *  @brief  Remove element at given position. </span>
<span class="lineNum"> 1158</span>              :        *  @param  __position  Iterator pointing to element to be erased. </span>
<span class="lineNum"> 1159</span>              :        *  @return  An iterator pointing to the next element (or end()). </span>
<span class="lineNum"> 1160</span>              :        * </span>
<span class="lineNum"> 1161</span>              :        *  This function will erase the element at the given position and thus </span>
<span class="lineNum"> 1162</span>              :        *  shorten the %list by one. </span>
<span class="lineNum"> 1163</span>              :        * </span>
<span class="lineNum"> 1164</span>              :        *  Due to the nature of a %list this operation can be done in </span>
<span class="lineNum"> 1165</span>              :        *  constant time, and only invalidates iterators&#047;references to </span>
<span class="lineNum"> 1166</span>              :        *  the element being removed.  The user is also cautioned that </span>
<span class="lineNum"> 1167</span>              :        *  this function only erases the element, and that if the element </span>
<span class="lineNum"> 1168</span>              :        *  is itself a pointer, the pointed-to memory is not touched in </span>
<span class="lineNum"> 1169</span>              :        *  any way.  Managing the pointer is the user&#039;s responsibility. </span>
<span class="lineNum"> 1170</span>              :        *&#047; </span>
<span class="lineNum"> 1171</span>              :       iterator </span>
<span class="lineNum"> 1172</span>              :       erase(iterator __position); </span>
<span class="lineNum"> 1173</span>              :  </span>
<span class="lineNum"> 1174</span>              :       &#047;** </span>
<span class="lineNum"> 1175</span>              :        *  @brief  Remove a range of elements. </span>
<span class="lineNum"> 1176</span>              :        *  @param  __first  Iterator pointing to the first element to be erased. </span>
<span class="lineNum"> 1177</span>              :        *  @param  __last  Iterator pointing to one past the last element to be </span>
<span class="lineNum"> 1178</span>              :        *                erased. </span>
<span class="lineNum"> 1179</span>              :        *  @return  An iterator pointing to the element pointed to by @a last </span>
<span class="lineNum"> 1180</span>              :        *           prior to erasing (or end()). </span>
<span class="lineNum"> 1181</span>              :        * </span>
<span class="lineNum"> 1182</span>              :        *  This function will erase the elements in the range @a </span>
<span class="lineNum"> 1183</span>              :        *  [first,last) and shorten the %list accordingly. </span>
<span class="lineNum"> 1184</span>              :        * </span>
<span class="lineNum"> 1185</span>              :        *  This operation is linear time in the size of the range and only </span>
<span class="lineNum"> 1186</span>              :        *  invalidates iterators&#047;references to the element being removed. </span>
<span class="lineNum"> 1187</span>              :        *  The user is also cautioned that this function only erases the </span>
<span class="lineNum"> 1188</span>              :        *  elements, and that if the elements themselves are pointers, the </span>
<span class="lineNum"> 1189</span>              :        *  pointed-to memory is not touched in any way.  Managing the pointer </span>
<span class="lineNum"> 1190</span>              :        *  is the user&#039;s responsibility. </span>
<span class="lineNum"> 1191</span>              :        *&#047; </span>
<span class="lineNum"> 1192</span>              :       iterator </span>
<span class="lineNum"> 1193</span>              :       erase(iterator __first, iterator __last) </span>
<span class="lineNum"> 1194</span>              :       { </span>
<span class="lineNum"> 1195</span>              : 	while (__first != __last) </span>
<span class="lineNum"> 1196</span>              : 	  __first = erase(__first); </span>
<span class="lineNum"> 1197</span>              : 	return __last; </span>
<span class="lineNum"> 1198</span>              :       } </span>
<span class="lineNum"> 1199</span>              :  </span>
<span class="lineNum"> 1200</span>              :       &#047;** </span>
<span class="lineNum"> 1201</span>              :        *  @brief  Swaps data with another %list. </span>
<span class="lineNum"> 1202</span>              :        *  @param  __x  A %list of the same element and allocator types. </span>
<span class="lineNum"> 1203</span>              :        * </span>
<span class="lineNum"> 1204</span>              :        *  This exchanges the elements between two lists in constant </span>
<span class="lineNum"> 1205</span>              :        *  time.  Note that the global std::swap() function is </span>
<span class="lineNum"> 1206</span>              :        *  specialized such that std::swap(l1,l2) will feed to this </span>
<span class="lineNum"> 1207</span>              :        *  function. </span>
<span class="lineNum"> 1208</span>              :        *&#047; </span>
<span class="lineNum"> 1209</span>              :       void </span>
<span class="lineNum"> 1210</span>              :       swap(list&amp; __x) </span>
<span class="lineNum"> 1211</span>              :       { </span>
<span class="lineNum"> 1212</span>              : 	__detail::_List_node_base::swap(this-&gt;_M_impl._M_node,  </span>
<span class="lineNum"> 1213</span>              : 					__x._M_impl._M_node); </span>
<span class="lineNum"> 1214</span>              :  </span>
<span class="lineNum"> 1215</span>              : 	&#047;&#047; _GLIBCXX_RESOLVE_LIB_DEFECTS </span>
<span class="lineNum"> 1216</span>              : 	&#047;&#047; 431. Swapping containers with unequal allocators. </span>
<span class="lineNum"> 1217</span>              : 	std::__alloc_swap&lt;typename _Base::_Node_alloc_type&gt;:: </span>
<span class="lineNum"> 1218</span>              : 	  _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator()); </span>
<span class="lineNum"> 1219</span>              :       } </span>
<span class="lineNum"> 1220</span>              :  </span>
<span class="lineNum"> 1221</span>              :       &#047;** </span>
<span class="lineNum"> 1222</span>              :        *  Erases all the elements.  Note that this function only erases </span>
<span class="lineNum"> 1223</span>              :        *  the elements, and that if the elements themselves are </span>
<span class="lineNum"> 1224</span>              :        *  pointers, the pointed-to memory is not touched in any way. </span>
<span class="lineNum"> 1225</span>              :        *  Managing the pointer is the user&#039;s responsibility. </span>
<span class="lineNum"> 1226</span>              :        *&#047; </span>
<span class="lineNum"> 1227</span>              :       void </span>
<span class="lineNum"> 1228</span><span class="lineNoCov">      0  /   2:       clear() _GLIBCXX_NOEXCEPT </span>
<span class="lineNum"> 1229</span>              :       { </span>
<span class="lineNum"> 1230</span><span class="lineNoCov">      0  /   2:         _Base::_M_clear(); </span>
<span class="lineNum"> 1231</span><span class="lineNoCov">      0  /   2:         _Base::_M_init(); </span>
<span class="lineNum"> 1232</span><span class="lineNoCov">      0  /   4:       } </span>
<span class="lineNum"> 1233</span>              :  </span>
<span class="lineNum"> 1234</span>              :       &#047;&#047; [23.2.2.4] list operations </span>
<span class="lineNum"> 1235</span>              :       &#047;** </span>
<span class="lineNum"> 1236</span>              :        *  @brief  Insert contents of another %list. </span>
<span class="lineNum"> 1237</span>              :        *  @param  __position  Iterator referencing the element to insert before. </span>
<span class="lineNum"> 1238</span>              :        *  @param  __x  Source list. </span>
<span class="lineNum"> 1239</span>              :        * </span>
<span class="lineNum"> 1240</span>              :        *  The elements of @a __x are inserted in constant time in front of </span>
<span class="lineNum"> 1241</span>              :        *  the element referenced by @a __position.  @a __x becomes an empty </span>
<span class="lineNum"> 1242</span>              :        *  list. </span>
<span class="lineNum"> 1243</span>              :        * </span>
<span class="lineNum"> 1244</span>              :        *  Requires this != @a __x. </span>
<span class="lineNum"> 1245</span>              :        *&#047; </span>
<span class="lineNum"> 1246</span>              :       void </span>
<span class="lineNum"> 1247</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum"> 1248</span>              :       splice(iterator __position, list&amp;&amp; __x) </span>
<span class="lineNum"> 1249</span>              : #else </span>
<span class="lineNum"> 1250</span>              :       splice(iterator __position, list&amp; __x) </span>
<span class="lineNum"> 1251</span>              : #endif </span>
<span class="lineNum"> 1252</span>              :       { </span>
<span class="lineNum"> 1253</span>              : 	if (!__x.empty()) </span>
<span class="lineNum"> 1254</span>              : 	  { </span>
<span class="lineNum"> 1255</span>              : 	    _M_check_equal_allocators(__x); </span>
<span class="lineNum"> 1256</span>              :  </span>
<span class="lineNum"> 1257</span>              : 	    this-&gt;_M_transfer(__position, __x.begin(), __x.end()); </span>
<span class="lineNum"> 1258</span>              : 	  } </span>
<span class="lineNum"> 1259</span>              :       } </span>
<span class="lineNum"> 1260</span>              :  </span>
<span class="lineNum"> 1261</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum"> 1262</span>              :       void </span>
<span class="lineNum"> 1263</span>              :       splice(iterator __position, list&amp; __x) </span>
<span class="lineNum"> 1264</span>              :       { splice(__position, std::move(__x)); } </span>
<span class="lineNum"> 1265</span>              : #endif </span>
<span class="lineNum"> 1266</span>              :  </span>
<span class="lineNum"> 1267</span>              :       &#047;** </span>
<span class="lineNum"> 1268</span>              :        *  @brief  Insert element from another %list. </span>
<span class="lineNum"> 1269</span>              :        *  @param  __position  Iterator referencing the element to insert before. </span>
<span class="lineNum"> 1270</span>              :        *  @param  __x  Source list. </span>
<span class="lineNum"> 1271</span>              :        *  @param  __i  Iterator referencing the element to move. </span>
<span class="lineNum"> 1272</span>              :        * </span>
<span class="lineNum"> 1273</span>              :        *  Removes the element in list @a __x referenced by @a __i and </span>
<span class="lineNum"> 1274</span>              :        *  inserts it into the current list before @a __position. </span>
<span class="lineNum"> 1275</span>              :        *&#047; </span>
<span class="lineNum"> 1276</span>              :       void </span>
<span class="lineNum"> 1277</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum"> 1278</span>              :       splice(iterator __position, list&amp;&amp; __x, iterator __i) </span>
<span class="lineNum"> 1279</span>              : #else </span>
<span class="lineNum"> 1280</span>              :       splice(iterator __position, list&amp; __x, iterator __i) </span>
<span class="lineNum"> 1281</span>              : #endif </span>
<span class="lineNum"> 1282</span>              :       { </span>
<span class="lineNum"> 1283</span>              : 	iterator __j = __i; </span>
<span class="lineNum"> 1284</span>              : 	++__j; </span>
<span class="lineNum"> 1285</span>              : 	if (__position == __i || __position == __j) </span>
<span class="lineNum"> 1286</span>              : 	  return; </span>
<span class="lineNum"> 1287</span>              :  </span>
<span class="lineNum"> 1288</span>              : 	if (this != &amp;__x) </span>
<span class="lineNum"> 1289</span>              : 	  _M_check_equal_allocators(__x); </span>
<span class="lineNum"> 1290</span>              :  </span>
<span class="lineNum"> 1291</span>              : 	this-&gt;_M_transfer(__position, __i, __j); </span>
<span class="lineNum"> 1292</span>              :       } </span>
<span class="lineNum"> 1293</span>              :  </span>
<span class="lineNum"> 1294</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum"> 1295</span>              :       void </span>
<span class="lineNum"> 1296</span>              :       splice(iterator __position, list&amp; __x, iterator __i) </span>
<span class="lineNum"> 1297</span>              :       { splice(__position, std::move(__x), __i); } </span>
<span class="lineNum"> 1298</span>              : #endif </span>
<span class="lineNum"> 1299</span>              :  </span>
<span class="lineNum"> 1300</span>              :       &#047;** </span>
<span class="lineNum"> 1301</span>              :        *  @brief  Insert range from another %list. </span>
<span class="lineNum"> 1302</span>              :        *  @param  __position  Iterator referencing the element to insert before. </span>
<span class="lineNum"> 1303</span>              :        *  @param  __x  Source list. </span>
<span class="lineNum"> 1304</span>              :        *  @param  __first  Iterator referencing the start of range in x. </span>
<span class="lineNum"> 1305</span>              :        *  @param  __last  Iterator referencing the end of range in x. </span>
<span class="lineNum"> 1306</span>              :        * </span>
<span class="lineNum"> 1307</span>              :        *  Removes elements in the range [__first,__last) and inserts them </span>
<span class="lineNum"> 1308</span>              :        *  before @a __position in constant time. </span>
<span class="lineNum"> 1309</span>              :        * </span>
<span class="lineNum"> 1310</span>              :        *  Undefined if @a __position is in [__first,__last). </span>
<span class="lineNum"> 1311</span>              :        *&#047; </span>
<span class="lineNum"> 1312</span>              :       void </span>
<span class="lineNum"> 1313</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum"> 1314</span>              :       splice(iterator __position, list&amp;&amp; __x, iterator __first, </span>
<span class="lineNum"> 1315</span>              : 	     iterator __last) </span>
<span class="lineNum"> 1316</span>              : #else </span>
<span class="lineNum"> 1317</span>              :       splice(iterator __position, list&amp; __x, iterator __first, </span>
<span class="lineNum"> 1318</span>              : 	     iterator __last) </span>
<span class="lineNum"> 1319</span>              : #endif </span>
<span class="lineNum"> 1320</span>              :       { </span>
<span class="lineNum"> 1321</span>              : 	if (__first != __last) </span>
<span class="lineNum"> 1322</span>              : 	  { </span>
<span class="lineNum"> 1323</span>              : 	    if (this != &amp;__x) </span>
<span class="lineNum"> 1324</span>              : 	      _M_check_equal_allocators(__x); </span>
<span class="lineNum"> 1325</span>              :  </span>
<span class="lineNum"> 1326</span>              : 	    this-&gt;_M_transfer(__position, __first, __last); </span>
<span class="lineNum"> 1327</span>              : 	  } </span>
<span class="lineNum"> 1328</span>              :       } </span>
<span class="lineNum"> 1329</span>              :  </span>
<span class="lineNum"> 1330</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum"> 1331</span>              :       void </span>
<span class="lineNum"> 1332</span>              :       splice(iterator __position, list&amp; __x, iterator __first, iterator __last) </span>
<span class="lineNum"> 1333</span>              :       { splice(__position, std::move(__x), __first, __last); } </span>
<span class="lineNum"> 1334</span>              : #endif </span>
<span class="lineNum"> 1335</span>              :  </span>
<span class="lineNum"> 1336</span>              :       &#047;** </span>
<span class="lineNum"> 1337</span>              :        *  @brief  Remove all elements equal to value. </span>
<span class="lineNum"> 1338</span>              :        *  @param  __value  The value to remove. </span>
<span class="lineNum"> 1339</span>              :        * </span>
<span class="lineNum"> 1340</span>              :        *  Removes every element in the list equal to @a value. </span>
<span class="lineNum"> 1341</span>              :        *  Remaining elements stay in list order.  Note that this </span>
<span class="lineNum"> 1342</span>              :        *  function only erases the elements, and that if the elements </span>
<span class="lineNum"> 1343</span>              :        *  themselves are pointers, the pointed-to memory is not </span>
<span class="lineNum"> 1344</span>              :        *  touched in any way.  Managing the pointer is the user&#039;s </span>
<span class="lineNum"> 1345</span>              :        *  responsibility. </span>
<span class="lineNum"> 1346</span>              :        *&#047; </span>
<span class="lineNum"> 1347</span>              :       void </span>
<span class="lineNum"> 1348</span>              :       remove(const _Tp&amp; __value); </span>
<span class="lineNum"> 1349</span>              :  </span>
<span class="lineNum"> 1350</span>              :       &#047;** </span>
<span class="lineNum"> 1351</span>              :        *  @brief  Remove all elements satisfying a predicate. </span>
<span class="lineNum"> 1352</span>              :        *  @tparam  _Predicate  Unary predicate function or object. </span>
<span class="lineNum"> 1353</span>              :        * </span>
<span class="lineNum"> 1354</span>              :        *  Removes every element in the list for which the predicate </span>
<span class="lineNum"> 1355</span>              :        *  returns true.  Remaining elements stay in list order.  Note </span>
<span class="lineNum"> 1356</span>              :        *  that this function only erases the elements, and that if the </span>
<span class="lineNum"> 1357</span>              :        *  elements themselves are pointers, the pointed-to memory is </span>
<span class="lineNum"> 1358</span>              :        *  not touched in any way.  Managing the pointer is the user&#039;s </span>
<span class="lineNum"> 1359</span>              :        *  responsibility. </span>
<span class="lineNum"> 1360</span>              :        *&#047; </span>
<span class="lineNum"> 1361</span>              :       template&lt;typename _Predicate&gt; </span>
<span class="lineNum"> 1362</span>              :         void </span>
<span class="lineNum"> 1363</span>              :         remove_if(_Predicate); </span>
<span class="lineNum"> 1364</span>              :  </span>
<span class="lineNum"> 1365</span>              :       &#047;** </span>
<span class="lineNum"> 1366</span>              :        *  @brief  Remove consecutive duplicate elements. </span>
<span class="lineNum"> 1367</span>              :        * </span>
<span class="lineNum"> 1368</span>              :        *  For each consecutive set of elements with the same value, </span>
<span class="lineNum"> 1369</span>              :        *  remove all but the first one.  Remaining elements stay in </span>
<span class="lineNum"> 1370</span>              :        *  list order.  Note that this function only erases the </span>
<span class="lineNum"> 1371</span>              :        *  elements, and that if the elements themselves are pointers, </span>
<span class="lineNum"> 1372</span>              :        *  the pointed-to memory is not touched in any way.  Managing </span>
<span class="lineNum"> 1373</span>              :        *  the pointer is the user&#039;s responsibility. </span>
<span class="lineNum"> 1374</span>              :        *&#047; </span>
<span class="lineNum"> 1375</span>              :       void </span>
<span class="lineNum"> 1376</span>              :       unique(); </span>
<span class="lineNum"> 1377</span>              :  </span>
<span class="lineNum"> 1378</span>              :       &#047;** </span>
<span class="lineNum"> 1379</span>              :        *  @brief  Remove consecutive elements satisfying a predicate. </span>
<span class="lineNum"> 1380</span>              :        *  @tparam _BinaryPredicate  Binary predicate function or object. </span>
<span class="lineNum"> 1381</span>              :        * </span>
<span class="lineNum"> 1382</span>              :        *  For each consecutive set of elements [first,last) that </span>
<span class="lineNum"> 1383</span>              :        *  satisfy predicate(first,i) where i is an iterator in </span>
<span class="lineNum"> 1384</span>              :        *  [first,last), remove all but the first one.  Remaining </span>
<span class="lineNum"> 1385</span>              :        *  elements stay in list order.  Note that this function only </span>
<span class="lineNum"> 1386</span>              :        *  erases the elements, and that if the elements themselves are </span>
<span class="lineNum"> 1387</span>              :        *  pointers, the pointed-to memory is not touched in any way. </span>
<span class="lineNum"> 1388</span>              :        *  Managing the pointer is the user&#039;s responsibility. </span>
<span class="lineNum"> 1389</span>              :        *&#047; </span>
<span class="lineNum"> 1390</span>              :       template&lt;typename _BinaryPredicate&gt; </span>
<span class="lineNum"> 1391</span>              :         void </span>
<span class="lineNum"> 1392</span>              :         unique(_BinaryPredicate); </span>
<span class="lineNum"> 1393</span>              :  </span>
<span class="lineNum"> 1394</span>              :       &#047;** </span>
<span class="lineNum"> 1395</span>              :        *  @brief  Merge sorted lists. </span>
<span class="lineNum"> 1396</span>              :        *  @param  __x  Sorted list to merge. </span>
<span class="lineNum"> 1397</span>              :        * </span>
<span class="lineNum"> 1398</span>              :        *  Assumes that both @a __x and this list are sorted according to </span>
<span class="lineNum"> 1399</span>              :        *  operator&lt;().  Merges elements of @a __x into this list in </span>
<span class="lineNum"> 1400</span>              :        *  sorted order, leaving @a __x empty when complete.  Elements in </span>
<span class="lineNum"> 1401</span>              :        *  this list precede elements in @a __x that are equal. </span>
<span class="lineNum"> 1402</span>              :        *&#047; </span>
<span class="lineNum"> 1403</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum"> 1404</span>              :       void </span>
<span class="lineNum"> 1405</span>              :       merge(list&amp;&amp; __x); </span>
<span class="lineNum"> 1406</span>              :  </span>
<span class="lineNum"> 1407</span>              :       void </span>
<span class="lineNum"> 1408</span>              :       merge(list&amp; __x) </span>
<span class="lineNum"> 1409</span>              :       { merge(std::move(__x)); } </span>
<span class="lineNum"> 1410</span>              : #else </span>
<span class="lineNum"> 1411</span>              :       void </span>
<span class="lineNum"> 1412</span>              :       merge(list&amp; __x); </span>
<span class="lineNum"> 1413</span>              : #endif </span>
<span class="lineNum"> 1414</span>              :  </span>
<span class="lineNum"> 1415</span>              :       &#047;** </span>
<span class="lineNum"> 1416</span>              :        *  @brief  Merge sorted lists according to comparison function. </span>
<span class="lineNum"> 1417</span>              :        *  @tparam _StrictWeakOrdering Comparison function defining </span>
<span class="lineNum"> 1418</span>              :        *  sort order. </span>
<span class="lineNum"> 1419</span>              :        *  @param  __x  Sorted list to merge. </span>
<span class="lineNum"> 1420</span>              :        *  @param  __comp  Comparison functor. </span>
<span class="lineNum"> 1421</span>              :        * </span>
<span class="lineNum"> 1422</span>              :        *  Assumes that both @a __x and this list are sorted according to </span>
<span class="lineNum"> 1423</span>              :        *  StrictWeakOrdering.  Merges elements of @a __x into this list </span>
<span class="lineNum"> 1424</span>              :        *  in sorted order, leaving @a __x empty when complete.  Elements </span>
<span class="lineNum"> 1425</span>              :        *  in this list precede elements in @a __x that are equivalent </span>
<span class="lineNum"> 1426</span>              :        *  according to StrictWeakOrdering(). </span>
<span class="lineNum"> 1427</span>              :        *&#047; </span>
<span class="lineNum"> 1428</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum"> 1429</span>              :       template&lt;typename _StrictWeakOrdering&gt; </span>
<span class="lineNum"> 1430</span>              :         void </span>
<span class="lineNum"> 1431</span>              :         merge(list&amp;&amp; __x, _StrictWeakOrdering __comp); </span>
<span class="lineNum"> 1432</span>              :  </span>
<span class="lineNum"> 1433</span>              :       template&lt;typename _StrictWeakOrdering&gt; </span>
<span class="lineNum"> 1434</span>              :         void </span>
<span class="lineNum"> 1435</span>              :         merge(list&amp; __x, _StrictWeakOrdering __comp) </span>
<span class="lineNum"> 1436</span>              :         { merge(std::move(__x), __comp); } </span>
<span class="lineNum"> 1437</span>              : #else </span>
<span class="lineNum"> 1438</span>              :       template&lt;typename _StrictWeakOrdering&gt; </span>
<span class="lineNum"> 1439</span>              :         void </span>
<span class="lineNum"> 1440</span>              :         merge(list&amp; __x, _StrictWeakOrdering __comp); </span>
<span class="lineNum"> 1441</span>              : #endif </span>
<span class="lineNum"> 1442</span>              :  </span>
<span class="lineNum"> 1443</span>              :       &#047;** </span>
<span class="lineNum"> 1444</span>              :        *  @brief  Reverse the elements in list. </span>
<span class="lineNum"> 1445</span>              :        * </span>
<span class="lineNum"> 1446</span>              :        *  Reverse the order of elements in the list in linear time. </span>
<span class="lineNum"> 1447</span>              :        *&#047; </span>
<span class="lineNum"> 1448</span>              :       void </span>
<span class="lineNum"> 1449</span>              :       reverse() _GLIBCXX_NOEXCEPT </span>
<span class="lineNum"> 1450</span>              :       { this-&gt;_M_impl._M_node._M_reverse(); } </span>
<span class="lineNum"> 1451</span>              :  </span>
<span class="lineNum"> 1452</span>              :       &#047;** </span>
<span class="lineNum"> 1453</span>              :        *  @brief  Sort the elements. </span>
<span class="lineNum"> 1454</span>              :        * </span>
<span class="lineNum"> 1455</span>              :        *  Sorts the elements of this list in NlogN time.  Equivalent </span>
<span class="lineNum"> 1456</span>              :        *  elements remain in list order. </span>
<span class="lineNum"> 1457</span>              :        *&#047; </span>
<span class="lineNum"> 1458</span>              :       void </span>
<span class="lineNum"> 1459</span>              :       sort(); </span>
<span class="lineNum"> 1460</span>              :  </span>
<span class="lineNum"> 1461</span>              :       &#047;** </span>
<span class="lineNum"> 1462</span>              :        *  @brief  Sort the elements according to comparison function. </span>
<span class="lineNum"> 1463</span>              :        * </span>
<span class="lineNum"> 1464</span>              :        *  Sorts the elements of this list in NlogN time.  Equivalent </span>
<span class="lineNum"> 1465</span>              :        *  elements remain in list order. </span>
<span class="lineNum"> 1466</span>              :        *&#047; </span>
<span class="lineNum"> 1467</span>              :       template&lt;typename _StrictWeakOrdering&gt; </span>
<span class="lineNum"> 1468</span>              :         void </span>
<span class="lineNum"> 1469</span>              :         sort(_StrictWeakOrdering); </span>
<span class="lineNum"> 1470</span>              :  </span>
<span class="lineNum"> 1471</span>              :     protected: </span>
<span class="lineNum"> 1472</span>              :       &#047;&#047; Internal constructor functions follow. </span>
<span class="lineNum"> 1473</span>              :  </span>
<span class="lineNum"> 1474</span>              :       &#047;&#047; Called by the range constructor to implement [23.1.1]&#047;9 </span>
<span class="lineNum"> 1475</span>              :  </span>
<span class="lineNum"> 1476</span>              :       &#047;&#047; _GLIBCXX_RESOLVE_LIB_DEFECTS </span>
<span class="lineNum"> 1477</span>              :       &#047;&#047; 438. Ambiguity in the &quot;do the right thing&quot; clause </span>
<span class="lineNum"> 1478</span>              :       template&lt;typename _Integer&gt; </span>
<span class="lineNum"> 1479</span>              :         void </span>
<span class="lineNum"> 1480</span>              :         _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type) </span>
<span class="lineNum"> 1481</span>              :         { _M_fill_initialize(static_cast&lt;size_type&gt;(__n), __x); } </span>
<span class="lineNum"> 1482</span>              :  </span>
<span class="lineNum"> 1483</span>              :       &#047;&#047; Called by the range constructor to implement [23.1.1]&#047;9 </span>
<span class="lineNum"> 1484</span>              :       template&lt;typename _InputIterator&gt; </span>
<span class="lineNum"> 1485</span>              :         void </span>
<span class="lineNum"> 1486</span>              :         _M_initialize_dispatch(_InputIterator __first, _InputIterator __last, </span>
<span class="lineNum"> 1487</span>              : 			       __false_type) </span>
<span class="lineNum"> 1488</span>              :         { </span>
<span class="lineNum"> 1489</span>              : 	  for (; __first != __last; ++__first) </span>
<span class="lineNum"> 1490</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum"> 1491</span>              : 	    emplace_back(*__first); </span>
<span class="lineNum"> 1492</span>              : #else </span>
<span class="lineNum"> 1493</span>              : 	    push_back(*__first); </span>
<span class="lineNum"> 1494</span>              : #endif </span>
<span class="lineNum"> 1495</span>              : 	} </span>
<span class="lineNum"> 1496</span>              :  </span>
<span class="lineNum"> 1497</span>              :       &#047;&#047; Called by list(n,v,a), and the range constructor when it turns out </span>
<span class="lineNum"> 1498</span>              :       &#047;&#047; to be the same thing. </span>
<span class="lineNum"> 1499</span>              :       void </span>
<span class="lineNum"> 1500</span>              :       _M_fill_initialize(size_type __n, const value_type&amp; __x) </span>
<span class="lineNum"> 1501</span>              :       { </span>
<span class="lineNum"> 1502</span>              : 	for (; __n; --__n) </span>
<span class="lineNum"> 1503</span>              : 	  push_back(__x); </span>
<span class="lineNum"> 1504</span>              :       } </span>
<span class="lineNum"> 1505</span>              :  </span>
<span class="lineNum"> 1506</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum"> 1507</span>              :       &#047;&#047; Called by list(n). </span>
<span class="lineNum"> 1508</span>              :       void </span>
<span class="lineNum"> 1509</span>              :       _M_default_initialize(size_type __n) </span>
<span class="lineNum"> 1510</span>              :       { </span>
<span class="lineNum"> 1511</span>              : 	for (; __n; --__n) </span>
<span class="lineNum"> 1512</span>              : 	  emplace_back(); </span>
<span class="lineNum"> 1513</span>              :       } </span>
<span class="lineNum"> 1514</span>              :  </span>
<span class="lineNum"> 1515</span>              :       &#047;&#047; Called by resize(sz). </span>
<span class="lineNum"> 1516</span>              :       void </span>
<span class="lineNum"> 1517</span>              :       _M_default_append(size_type __n); </span>
<span class="lineNum"> 1518</span>              : #endif </span>
<span class="lineNum"> 1519</span>              :  </span>
<span class="lineNum"> 1520</span>              :       &#047;&#047; Internal assign functions follow. </span>
<span class="lineNum"> 1521</span>              :  </span>
<span class="lineNum"> 1522</span>              :       &#047;&#047; Called by the range assign to implement [23.1.1]&#047;9 </span>
<span class="lineNum"> 1523</span>              :  </span>
<span class="lineNum"> 1524</span>              :       &#047;&#047; _GLIBCXX_RESOLVE_LIB_DEFECTS </span>
<span class="lineNum"> 1525</span>              :       &#047;&#047; 438. Ambiguity in the &quot;do the right thing&quot; clause </span>
<span class="lineNum"> 1526</span>              :       template&lt;typename _Integer&gt; </span>
<span class="lineNum"> 1527</span>              :         void </span>
<span class="lineNum"> 1528</span>              :         _M_assign_dispatch(_Integer __n, _Integer __val, __true_type) </span>
<span class="lineNum"> 1529</span>              :         { _M_fill_assign(__n, __val); } </span>
<span class="lineNum"> 1530</span>              :  </span>
<span class="lineNum"> 1531</span>              :       &#047;&#047; Called by the range assign to implement [23.1.1]&#047;9 </span>
<span class="lineNum"> 1532</span>              :       template&lt;typename _InputIterator&gt; </span>
<span class="lineNum"> 1533</span>              :         void </span>
<span class="lineNum"> 1534</span>              :         _M_assign_dispatch(_InputIterator __first, _InputIterator __last, </span>
<span class="lineNum"> 1535</span>              : 			   __false_type); </span>
<span class="lineNum"> 1536</span>              :  </span>
<span class="lineNum"> 1537</span>              :       &#047;&#047; Called by assign(n,t), and the range assign when it turns out </span>
<span class="lineNum"> 1538</span>              :       &#047;&#047; to be the same thing. </span>
<span class="lineNum"> 1539</span>              :       void </span>
<span class="lineNum"> 1540</span>              :       _M_fill_assign(size_type __n, const value_type&amp; __val); </span>
<span class="lineNum"> 1541</span>              :  </span>
<span class="lineNum"> 1542</span>              :  </span>
<span class="lineNum"> 1543</span>              :       &#047;&#047; Moves the elements from [first,last) before position. </span>
<span class="lineNum"> 1544</span>              :       void </span>
<span class="lineNum"> 1545</span>              :       _M_transfer(iterator __position, iterator __first, iterator __last) </span>
<span class="lineNum"> 1546</span>              :       { __position._M_node-&gt;_M_transfer(__first._M_node, __last._M_node); } </span>
<span class="lineNum"> 1547</span>              :  </span>
<span class="lineNum"> 1548</span>              :       &#047;&#047; Inserts new element at position given and with value given. </span>
<span class="lineNum"> 1549</span>              : #if __cplusplus &lt; 201103L </span>
<span class="lineNum"> 1550</span>              :       void </span>
<span class="lineNum"> 1551</span>              :       _M_insert(iterator __position, const value_type&amp; __x) </span>
<span class="lineNum"> 1552</span>              :       { </span>
<span class="lineNum"> 1553</span>              :         _Node* __tmp = _M_create_node(__x); </span>
<span class="lineNum"> 1554</span>              :         __tmp-&gt;_M_hook(__position._M_node); </span>
<span class="lineNum"> 1555</span>              :       } </span>
<span class="lineNum"> 1556</span>              : #else </span>
<span class="lineNum"> 1557</span>              :      template&lt;typename... _Args&gt; </span>
<span class="lineNum"> 1558</span>              :        void </span>
<span class="lineNum"> 1559</span><span class="linePartCov">      7  /  10:        _M_insert(iterator __position, _Args&amp;&amp;... __args) </span>
<span class="lineNum"> 1560</span>              :        { </span>
<span class="lineNum"> 1561</span><span class="linePartCov">      7  /  10: 	 _Node* __tmp = _M_create_node(std::forward&lt;_Args&gt;(__args)...); </span>
<span class="lineNum"> 1562</span><span class="linePartCov">      7  /  10: 	 __tmp-&gt;_M_hook(__position._M_node); </span>
<span class="lineNum"> 1563</span><span class="linePartCov">      7  /  20:        } </span>
<span class="lineNum"> 1564</span>              : #endif </span>
<span class="lineNum"> 1565</span>              :  </span>
<span class="lineNum"> 1566</span>              :       &#047;&#047; Erases element at position given. </span>
<span class="lineNum"> 1567</span>              :       void </span>
<span class="lineNum"> 1568</span><span class="lineNoCov">      0  /   1:       _M_erase(iterator __position) </span>
<span class="lineNum"> 1569</span>              :       { </span>
<span class="lineNum"> 1570</span><span class="lineNoCov">      0  /   1:         __position._M_node-&gt;_M_unhook(); </span>
<span class="lineNum"> 1571</span><span class="lineNoCov">      0  /   1:         _Node* __n = static_cast&lt;_Node*&gt;(__position._M_node); </span>
<span class="lineNum"> 1572</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum"> 1573</span><span class="lineNoCov">      0  /   1:         _M_get_Node_allocator().destroy(__n); </span>
<span class="lineNum"> 1574</span>              : #else </span>
<span class="lineNum"> 1575</span>              : 	_M_get_Tp_allocator().destroy(std::__addressof(__n-&gt;_M_data)); </span>
<span class="lineNum"> 1576</span>              : #endif </span>
<span class="lineNum"> 1577</span><span class="lineNoCov">      0  /   1:         _M_put_node(__n); </span>
<span class="lineNum"> 1578</span><span class="lineNoCov">      0  /   2:       } </span>
<span class="lineNum"> 1579</span>              :  </span>
<span class="lineNum"> 1580</span>              :       &#047;&#047; To implement the splice (and merge) bits of N1599. </span>
<span class="lineNum"> 1581</span>              :       void </span>
<span class="lineNum"> 1582</span>              :       _M_check_equal_allocators(list&amp; __x) </span>
<span class="lineNum"> 1583</span>              :       { </span>
<span class="lineNum"> 1584</span>              : 	if (std::__alloc_neq&lt;typename _Base::_Node_alloc_type&gt;:: </span>
<span class="lineNum"> 1585</span>              : 	    _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator())) </span>
<span class="lineNum"> 1586</span>              : 	  __throw_runtime_error(__N(&quot;list::_M_check_equal_allocators&quot;)); </span>
<span class="lineNum"> 1587</span>              :       } </span>
<span class="lineNum"> 1588</span>              :     }; </span>
<span class="lineNum"> 1589</span>              :  </span>
<span class="lineNum"> 1590</span>              :   &#047;** </span>
<span class="lineNum"> 1591</span>              :    *  @brief  List equality comparison. </span>
<span class="lineNum"> 1592</span>              :    *  @param  __x  A %list. </span>
<span class="lineNum"> 1593</span>              :    *  @param  __y  A %list of the same type as @a __x. </span>
<span class="lineNum"> 1594</span>              :    *  @return  True iff the size and elements of the lists are equal. </span>
<span class="lineNum"> 1595</span>              :    * </span>
<span class="lineNum"> 1596</span>              :    *  This is an equivalence relation.  It is linear in the size of </span>
<span class="lineNum"> 1597</span>              :    *  the lists.  Lists are considered equivalent if their sizes are </span>
<span class="lineNum"> 1598</span>              :    *  equal, and if corresponding elements compare equal. </span>
<span class="lineNum"> 1599</span>              :   *&#047; </span>
<span class="lineNum"> 1600</span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum"> 1601</span>              :     inline bool </span>
<span class="lineNum"> 1602</span>              :     operator==(const list&lt;_Tp, _Alloc&gt;&amp; __x, const list&lt;_Tp, _Alloc&gt;&amp; __y) </span>
<span class="lineNum"> 1603</span>              :     { </span>
<span class="lineNum"> 1604</span>              :       typedef typename list&lt;_Tp, _Alloc&gt;::const_iterator const_iterator; </span>
<span class="lineNum"> 1605</span>              :       const_iterator __end1 = __x.end(); </span>
<span class="lineNum"> 1606</span>              :       const_iterator __end2 = __y.end(); </span>
<span class="lineNum"> 1607</span>              :  </span>
<span class="lineNum"> 1608</span>              :       const_iterator __i1 = __x.begin(); </span>
<span class="lineNum"> 1609</span>              :       const_iterator __i2 = __y.begin(); </span>
<span class="lineNum"> 1610</span>              :       while (__i1 != __end1 &amp;&amp; __i2 != __end2 &amp;&amp; *__i1 == *__i2) </span>
<span class="lineNum"> 1611</span>              : 	{ </span>
<span class="lineNum"> 1612</span>              : 	  ++__i1; </span>
<span class="lineNum"> 1613</span>              : 	  ++__i2; </span>
<span class="lineNum"> 1614</span>              : 	} </span>
<span class="lineNum"> 1615</span>              :       return __i1 == __end1 &amp;&amp; __i2 == __end2; </span>
<span class="lineNum"> 1616</span>              :     } </span>
<span class="lineNum"> 1617</span>              :  </span>
<span class="lineNum"> 1618</span>              :   &#047;** </span>
<span class="lineNum"> 1619</span>              :    *  @brief  List ordering relation. </span>
<span class="lineNum"> 1620</span>              :    *  @param  __x  A %list. </span>
<span class="lineNum"> 1621</span>              :    *  @param  __y  A %list of the same type as @a __x. </span>
<span class="lineNum"> 1622</span>              :    *  @return  True iff @a __x is lexicographically less than @a __y. </span>
<span class="lineNum"> 1623</span>              :    * </span>
<span class="lineNum"> 1624</span>              :    *  This is a total ordering relation.  It is linear in the size of the </span>
<span class="lineNum"> 1625</span>              :    *  lists.  The elements must be comparable with @c &lt;. </span>
<span class="lineNum"> 1626</span>              :    * </span>
<span class="lineNum"> 1627</span>              :    *  See std::lexicographical_compare() for how the determination is made. </span>
<span class="lineNum"> 1628</span>              :   *&#047; </span>
<span class="lineNum"> 1629</span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum"> 1630</span>              :     inline bool </span>
<span class="lineNum"> 1631</span>              :     operator&lt;(const list&lt;_Tp, _Alloc&gt;&amp; __x, const list&lt;_Tp, _Alloc&gt;&amp; __y) </span>
<span class="lineNum"> 1632</span>              :     { return std::lexicographical_compare(__x.begin(), __x.end(), </span>
<span class="lineNum"> 1633</span>              : 					  __y.begin(), __y.end()); } </span>
<span class="lineNum"> 1634</span>              :  </span>
<span class="lineNum"> 1635</span>              :   &#047;&#047;&#047; Based on operator== </span>
<span class="lineNum"> 1636</span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum"> 1637</span>              :     inline bool </span>
<span class="lineNum"> 1638</span>              :     operator!=(const list&lt;_Tp, _Alloc&gt;&amp; __x, const list&lt;_Tp, _Alloc&gt;&amp; __y) </span>
<span class="lineNum"> 1639</span>              :     { return !(__x == __y); } </span>
<span class="lineNum"> 1640</span>              :  </span>
<span class="lineNum"> 1641</span>              :   &#047;&#047;&#047; Based on operator&lt; </span>
<span class="lineNum"> 1642</span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum"> 1643</span>              :     inline bool </span>
<span class="lineNum"> 1644</span>              :     operator&gt;(const list&lt;_Tp, _Alloc&gt;&amp; __x, const list&lt;_Tp, _Alloc&gt;&amp; __y) </span>
<span class="lineNum"> 1645</span>              :     { return __y &lt; __x; } </span>
<span class="lineNum"> 1646</span>              :  </span>
<span class="lineNum"> 1647</span>              :   &#047;&#047;&#047; Based on operator&lt; </span>
<span class="lineNum"> 1648</span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum"> 1649</span>              :     inline bool </span>
<span class="lineNum"> 1650</span>              :     operator&lt;=(const list&lt;_Tp, _Alloc&gt;&amp; __x, const list&lt;_Tp, _Alloc&gt;&amp; __y) </span>
<span class="lineNum"> 1651</span>              :     { return !(__y &lt; __x); } </span>
<span class="lineNum"> 1652</span>              :  </span>
<span class="lineNum"> 1653</span>              :   &#047;&#047;&#047; Based on operator&lt; </span>
<span class="lineNum"> 1654</span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum"> 1655</span>              :     inline bool </span>
<span class="lineNum"> 1656</span>              :     operator&gt;=(const list&lt;_Tp, _Alloc&gt;&amp; __x, const list&lt;_Tp, _Alloc&gt;&amp; __y) </span>
<span class="lineNum"> 1657</span>              :     { return !(__x &lt; __y); } </span>
<span class="lineNum"> 1658</span>              :  </span>
<span class="lineNum"> 1659</span>              :   &#047;&#047;&#047; See std::list::swap(). </span>
<span class="lineNum"> 1660</span>              :   template&lt;typename _Tp, typename _Alloc&gt; </span>
<span class="lineNum"> 1661</span>              :     inline void </span>
<span class="lineNum"> 1662</span>              :     swap(list&lt;_Tp, _Alloc&gt;&amp; __x, list&lt;_Tp, _Alloc&gt;&amp; __y) </span>
<span class="lineNum"> 1663</span>              :     { __x.swap(__y); } </span>
<span class="lineNum"> 1664</span>              :  </span>
<span class="lineNum"> 1665</span>              : _GLIBCXX_END_NAMESPACE_CONTAINER </span>
<span class="lineNum"> 1666</span>              : } &#047;&#047; namespace std </span>
<span class="lineNum"> 1667</span>              :  </span>
<span class="lineNum"> 1668</span>              : #endif &#047;* _STL_LIST_H *&#047; </span>
</pre>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr><td class="versionInfo">Generated by: <a href="http://simonkagstrom.github.com/kcov/index.html">Kcov</a></td></tr>
</table>
<br/>
</body>
</html>
