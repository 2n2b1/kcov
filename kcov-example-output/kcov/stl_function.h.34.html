<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Coverage - kcov</title>
  <link rel="stylesheet" type="text/css" href="bcov.css"/>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="title">Coverage Report</td></tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr>
    <td width="100%">
      <table cellpadding="1" border="0" width="100%">
        <tr>
          <td class="headerItem" width="20%">Command:</td>
          <td class="headerValue" width="80%" colspan=6>kcov</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Date:</td>
          <td class="headerValue" width="15%">2014-03-01 10:11:51</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Instrumented&nbsp;lines:</td>
          <td class="headerValue" width="10%">8</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Code&nbsp;covered:</td>
          <td class="coverPerLeftHi" width="15%">100.0%</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Executed&nbsp;lines:</td>
          <td class="headerValue" width="10%">8</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
</table>
<pre class="source">
<span class="lineNum">    1</span>              : &#047;&#047; Functor implementations -*- C++ -*- </span>
<span class="lineNum">    2</span>              :  </span>
<span class="lineNum">    3</span>              : &#047;&#047; Copyright (C) 2001-2013 Free Software Foundation, Inc. </span>
<span class="lineNum">    4</span>              : &#047;&#047; </span>
<span class="lineNum">    5</span>              : &#047;&#047; This file is part of the GNU ISO C++ Library.  This library is free </span>
<span class="lineNum">    6</span>              : &#047;&#047; software; you can redistribute it and&#047;or modify it under the </span>
<span class="lineNum">    7</span>              : &#047;&#047; terms of the GNU General Public License as published by the </span>
<span class="lineNum">    8</span>              : &#047;&#047; Free Software Foundation; either version 3, or (at your option) </span>
<span class="lineNum">    9</span>              : &#047;&#047; any later version. </span>
<span class="lineNum">   10</span>              :  </span>
<span class="lineNum">   11</span>              : &#047;&#047; This library is distributed in the hope that it will be useful, </span>
<span class="lineNum">   12</span>              : &#047;&#047; but WITHOUT ANY WARRANTY; without even the implied warranty of </span>
<span class="lineNum">   13</span>              : &#047;&#047; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the </span>
<span class="lineNum">   14</span>              : &#047;&#047; GNU General Public License for more details. </span>
<span class="lineNum">   15</span>              :  </span>
<span class="lineNum">   16</span>              : &#047;&#047; Under Section 7 of GPL version 3, you are granted additional </span>
<span class="lineNum">   17</span>              : &#047;&#047; permissions described in the GCC Runtime Library Exception, version </span>
<span class="lineNum">   18</span>              : &#047;&#047; 3.1, as published by the Free Software Foundation. </span>
<span class="lineNum">   19</span>              :  </span>
<span class="lineNum">   20</span>              : &#047;&#047; You should have received a copy of the GNU General Public License and </span>
<span class="lineNum">   21</span>              : &#047;&#047; a copy of the GCC Runtime Library Exception along with this program; </span>
<span class="lineNum">   22</span>              : &#047;&#047; see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see </span>
<span class="lineNum">   23</span>              : &#047;&#047; &lt;http:&#047;&#047;www.gnu.org&#047;licenses&#047;&gt;. </span>
<span class="lineNum">   24</span>              :  </span>
<span class="lineNum">   25</span>              : &#047;* </span>
<span class="lineNum">   26</span>              :  * </span>
<span class="lineNum">   27</span>              :  * Copyright (c) 1994 </span>
<span class="lineNum">   28</span>              :  * Hewlett-Packard Company </span>
<span class="lineNum">   29</span>              :  * </span>
<span class="lineNum">   30</span>              :  * Permission to use, copy, modify, distribute and sell this software </span>
<span class="lineNum">   31</span>              :  * and its documentation for any purpose is hereby granted without fee, </span>
<span class="lineNum">   32</span>              :  * provided that the above copyright notice appear in all copies and </span>
<span class="lineNum">   33</span>              :  * that both that copyright notice and this permission notice appear </span>
<span class="lineNum">   34</span>              :  * in supporting documentation.  Hewlett-Packard Company makes no </span>
<span class="lineNum">   35</span>              :  * representations about the suitability of this software for any </span>
<span class="lineNum">   36</span>              :  * purpose.  It is provided &quot;as is&quot; without express or implied warranty. </span>
<span class="lineNum">   37</span>              :  * </span>
<span class="lineNum">   38</span>              :  * </span>
<span class="lineNum">   39</span>              :  * Copyright (c) 1996-1998 </span>
<span class="lineNum">   40</span>              :  * Silicon Graphics Computer Systems, Inc. </span>
<span class="lineNum">   41</span>              :  * </span>
<span class="lineNum">   42</span>              :  * Permission to use, copy, modify, distribute and sell this software </span>
<span class="lineNum">   43</span>              :  * and its documentation for any purpose is hereby granted without fee, </span>
<span class="lineNum">   44</span>              :  * provided that the above copyright notice appear in all copies and </span>
<span class="lineNum">   45</span>              :  * that both that copyright notice and this permission notice appear </span>
<span class="lineNum">   46</span>              :  * in supporting documentation.  Silicon Graphics makes no </span>
<span class="lineNum">   47</span>              :  * representations about the suitability of this software for any </span>
<span class="lineNum">   48</span>              :  * purpose.  It is provided &quot;as is&quot; without express or implied warranty. </span>
<span class="lineNum">   49</span>              :  *&#047; </span>
<span class="lineNum">   50</span>              :  </span>
<span class="lineNum">   51</span>              : &#047;** @file bits&#047;stl_function.h </span>
<span class="lineNum">   52</span>              :  *  This is an internal header file, included by other library headers. </span>
<span class="lineNum">   53</span>              :  *  Do not attempt to use it directly. @headername{functional} </span>
<span class="lineNum">   54</span>              :  *&#047; </span>
<span class="lineNum">   55</span>              :  </span>
<span class="lineNum">   56</span>              : #ifndef _STL_FUNCTION_H </span>
<span class="lineNum">   57</span>              : #define _STL_FUNCTION_H 1 </span>
<span class="lineNum">   58</span>              :  </span>
<span class="lineNum">   59</span>              : namespace std _GLIBCXX_VISIBILITY(default) </span>
<span class="lineNum">   60</span>              : { </span>
<span class="lineNum">   61</span>              : _GLIBCXX_BEGIN_NAMESPACE_VERSION </span>
<span class="lineNum">   62</span>              :  </span>
<span class="lineNum">   63</span>              :   &#047;&#047; 20.3.1 base classes </span>
<span class="lineNum">   64</span>              :   &#047;** @defgroup functors Function Objects </span>
<span class="lineNum">   65</span>              :    * @ingroup utilities </span>
<span class="lineNum">   66</span>              :    * </span>
<span class="lineNum">   67</span>              :    *  Function objects, or @e functors, are objects with an @c operator() </span>
<span class="lineNum">   68</span>              :    *  defined and accessible.  They can be passed as arguments to algorithm </span>
<span class="lineNum">   69</span>              :    *  templates and used in place of a function pointer.  Not only is the </span>
<span class="lineNum">   70</span>              :    *  resulting expressiveness of the library increased, but the generated </span>
<span class="lineNum">   71</span>              :    *  code can be more efficient than what you might write by hand.  When we </span>
<span class="lineNum">   72</span>              :    *  refer to @a functors, then, generally we include function pointers in </span>
<span class="lineNum">   73</span>              :    *  the description as well. </span>
<span class="lineNum">   74</span>              :    * </span>
<span class="lineNum">   75</span>              :    *  Often, functors are only created as temporaries passed to algorithm </span>
<span class="lineNum">   76</span>              :    *  calls, rather than being created as named variables. </span>
<span class="lineNum">   77</span>              :    * </span>
<span class="lineNum">   78</span>              :    *  Two examples taken from the standard itself follow.  To perform a </span>
<span class="lineNum">   79</span>              :    *  by-element addition of two vectors @c a and @c b containing @c double, </span>
<span class="lineNum">   80</span>              :    *  and put the result in @c a, use </span>
<span class="lineNum">   81</span>              :    *  &#092;code </span>
<span class="lineNum">   82</span>              :    *  transform (a.begin(), a.end(), b.begin(), a.begin(), plus&lt;double&gt;()); </span>
<span class="lineNum">   83</span>              :    *  &#092;endcode </span>
<span class="lineNum">   84</span>              :    *  To negate every element in @c a, use </span>
<span class="lineNum">   85</span>              :    *  &#092;code </span>
<span class="lineNum">   86</span>              :    *  transform(a.begin(), a.end(), a.begin(), negate&lt;double&gt;()); </span>
<span class="lineNum">   87</span>              :    *  &#092;endcode </span>
<span class="lineNum">   88</span>              :    *  The addition and negation functions will be inlined directly. </span>
<span class="lineNum">   89</span>              :    * </span>
<span class="lineNum">   90</span>              :    *  The standard functors are derived from structs named @c unary_function </span>
<span class="lineNum">   91</span>              :    *  and @c binary_function.  These two classes contain nothing but typedefs, </span>
<span class="lineNum">   92</span>              :    *  to aid in generic (template) programming.  If you write your own </span>
<span class="lineNum">   93</span>              :    *  functors, you might consider doing the same. </span>
<span class="lineNum">   94</span>              :    * </span>
<span class="lineNum">   95</span>              :    *  @{ </span>
<span class="lineNum">   96</span>              :    *&#047; </span>
<span class="lineNum">   97</span>              :   &#047;** </span>
<span class="lineNum">   98</span>              :    *  This is one of the @link functors functor base classes@endlink. </span>
<span class="lineNum">   99</span>              :    *&#047; </span>
<span class="lineNum">  100</span>              :   template&lt;typename _Arg, typename _Result&gt; </span>
<span class="lineNum">  101</span>              :     struct unary_function </span>
<span class="lineNum">  102</span>              :     { </span>
<span class="lineNum">  103</span>              :       &#047;&#047;&#047; @c argument_type is the type of the argument </span>
<span class="lineNum">  104</span>              :       typedef _Arg 	argument_type;    </span>
<span class="lineNum">  105</span>              :  </span>
<span class="lineNum">  106</span>              :       &#047;&#047;&#047; @c result_type is the return type </span>
<span class="lineNum">  107</span>              :       typedef _Result 	result_type;   </span>
<span class="lineNum">  108</span>              :     }; </span>
<span class="lineNum">  109</span>              :  </span>
<span class="lineNum">  110</span>              :   &#047;** </span>
<span class="lineNum">  111</span>              :    *  This is one of the @link functors functor base classes@endlink. </span>
<span class="lineNum">  112</span>              :    *&#047; </span>
<span class="lineNum">  113</span>              :   template&lt;typename _Arg1, typename _Arg2, typename _Result&gt; </span>
<span class="lineNum">  114</span>              :     struct binary_function </span>
<span class="lineNum">  115</span>              :     { </span>
<span class="lineNum">  116</span>              :       &#047;&#047;&#047; @c first_argument_type is the type of the first argument </span>
<span class="lineNum">  117</span>              :       typedef _Arg1 	first_argument_type;  </span>
<span class="lineNum">  118</span>              :  </span>
<span class="lineNum">  119</span>              :       &#047;&#047;&#047; @c second_argument_type is the type of the second argument </span>
<span class="lineNum">  120</span>              :       typedef _Arg2 	second_argument_type; </span>
<span class="lineNum">  121</span>              :  </span>
<span class="lineNum">  122</span>              :       &#047;&#047;&#047; @c result_type is the return type </span>
<span class="lineNum">  123</span>              :       typedef _Result 	result_type; </span>
<span class="lineNum">  124</span>              :     }; </span>
<span class="lineNum">  125</span>              :   &#047;** @}  *&#047; </span>
<span class="lineNum">  126</span>              :  </span>
<span class="lineNum">  127</span>              :   &#047;&#047; 20.3.2 arithmetic </span>
<span class="lineNum">  128</span>              :   &#047;** @defgroup arithmetic_functors Arithmetic Classes </span>
<span class="lineNum">  129</span>              :    * @ingroup functors </span>
<span class="lineNum">  130</span>              :    * </span>
<span class="lineNum">  131</span>              :    *  Because basic math often needs to be done during an algorithm, </span>
<span class="lineNum">  132</span>              :    *  the library provides functors for those operations.  See the </span>
<span class="lineNum">  133</span>              :    *  documentation for @link functors the base classes@endlink </span>
<span class="lineNum">  134</span>              :    *  for examples of their use. </span>
<span class="lineNum">  135</span>              :    * </span>
<span class="lineNum">  136</span>              :    *  @{ </span>
<span class="lineNum">  137</span>              :    *&#047; </span>
<span class="lineNum">  138</span>              :   &#047;&#047;&#047; One of the @link arithmetic_functors math functors@endlink. </span>
<span class="lineNum">  139</span>              :   template&lt;typename _Tp&gt; </span>
<span class="lineNum">  140</span>              :     struct plus : public binary_function&lt;_Tp, _Tp, _Tp&gt; </span>
<span class="lineNum">  141</span>              :     { </span>
<span class="lineNum">  142</span>              :       _Tp </span>
<span class="lineNum">  143</span>              :       operator()(const _Tp&amp; __x, const _Tp&amp; __y) const </span>
<span class="lineNum">  144</span>              :       { return __x + __y; } </span>
<span class="lineNum">  145</span>              :     }; </span>
<span class="lineNum">  146</span>              :  </span>
<span class="lineNum">  147</span>              :   &#047;&#047;&#047; One of the @link arithmetic_functors math functors@endlink. </span>
<span class="lineNum">  148</span>              :   template&lt;typename _Tp&gt; </span>
<span class="lineNum">  149</span>              :     struct minus : public binary_function&lt;_Tp, _Tp, _Tp&gt; </span>
<span class="lineNum">  150</span>              :     { </span>
<span class="lineNum">  151</span>              :       _Tp </span>
<span class="lineNum">  152</span>              :       operator()(const _Tp&amp; __x, const _Tp&amp; __y) const </span>
<span class="lineNum">  153</span>              :       { return __x - __y; } </span>
<span class="lineNum">  154</span>              :     }; </span>
<span class="lineNum">  155</span>              :  </span>
<span class="lineNum">  156</span>              :   &#047;&#047;&#047; One of the @link arithmetic_functors math functors@endlink. </span>
<span class="lineNum">  157</span>              :   template&lt;typename _Tp&gt; </span>
<span class="lineNum">  158</span>              :     struct multiplies : public binary_function&lt;_Tp, _Tp, _Tp&gt; </span>
<span class="lineNum">  159</span>              :     { </span>
<span class="lineNum">  160</span>              :       _Tp </span>
<span class="lineNum">  161</span>              :       operator()(const _Tp&amp; __x, const _Tp&amp; __y) const </span>
<span class="lineNum">  162</span>              :       { return __x * __y; } </span>
<span class="lineNum">  163</span>              :     }; </span>
<span class="lineNum">  164</span>              :  </span>
<span class="lineNum">  165</span>              :   &#047;&#047;&#047; One of the @link arithmetic_functors math functors@endlink. </span>
<span class="lineNum">  166</span>              :   template&lt;typename _Tp&gt; </span>
<span class="lineNum">  167</span>              :     struct divides : public binary_function&lt;_Tp, _Tp, _Tp&gt; </span>
<span class="lineNum">  168</span>              :     { </span>
<span class="lineNum">  169</span>              :       _Tp </span>
<span class="lineNum">  170</span>              :       operator()(const _Tp&amp; __x, const _Tp&amp; __y) const </span>
<span class="lineNum">  171</span>              :       { return __x &#047; __y; } </span>
<span class="lineNum">  172</span>              :     }; </span>
<span class="lineNum">  173</span>              :  </span>
<span class="lineNum">  174</span>              :   &#047;&#047;&#047; One of the @link arithmetic_functors math functors@endlink. </span>
<span class="lineNum">  175</span>              :   template&lt;typename _Tp&gt; </span>
<span class="lineNum">  176</span>              :     struct modulus : public binary_function&lt;_Tp, _Tp, _Tp&gt; </span>
<span class="lineNum">  177</span>              :     { </span>
<span class="lineNum">  178</span>              :       _Tp </span>
<span class="lineNum">  179</span>              :       operator()(const _Tp&amp; __x, const _Tp&amp; __y) const </span>
<span class="lineNum">  180</span>              :       { return __x % __y; } </span>
<span class="lineNum">  181</span>              :     }; </span>
<span class="lineNum">  182</span>              :  </span>
<span class="lineNum">  183</span>              :   &#047;&#047;&#047; One of the @link arithmetic_functors math functors@endlink. </span>
<span class="lineNum">  184</span>              :   template&lt;typename _Tp&gt; </span>
<span class="lineNum">  185</span>              :     struct negate : public unary_function&lt;_Tp, _Tp&gt; </span>
<span class="lineNum">  186</span>              :     { </span>
<span class="lineNum">  187</span>              :       _Tp </span>
<span class="lineNum">  188</span>              :       operator()(const _Tp&amp; __x) const </span>
<span class="lineNum">  189</span>              :       { return -__x; } </span>
<span class="lineNum">  190</span>              :     }; </span>
<span class="lineNum">  191</span>              :   &#047;** @}  *&#047; </span>
<span class="lineNum">  192</span>              :  </span>
<span class="lineNum">  193</span>              :   &#047;&#047; 20.3.3 comparisons </span>
<span class="lineNum">  194</span>              :   &#047;** @defgroup comparison_functors Comparison Classes </span>
<span class="lineNum">  195</span>              :    * @ingroup functors </span>
<span class="lineNum">  196</span>              :    * </span>
<span class="lineNum">  197</span>              :    *  The library provides six wrapper functors for all the basic comparisons </span>
<span class="lineNum">  198</span>              :    *  in C++, like @c &lt;. </span>
<span class="lineNum">  199</span>              :    * </span>
<span class="lineNum">  200</span>              :    *  @{ </span>
<span class="lineNum">  201</span>              :    *&#047; </span>
<span class="lineNum">  202</span>              :   &#047;&#047;&#047; One of the @link comparison_functors comparison functors@endlink. </span>
<span class="lineNum">  203</span>              :   template&lt;typename _Tp&gt; </span>
<span class="lineNum">  204</span>              :     struct equal_to : public binary_function&lt;_Tp, _Tp, bool&gt; </span>
<span class="lineNum">  205</span>              :     { </span>
<span class="lineNum">  206</span>              :       bool </span>
<span class="lineNum">  207</span><span class="linePartCov">      4  /   5:       operator()(const _Tp&amp; __x, const _Tp&amp; __y) const </span>
<span class="lineNum">  208</span><span class="linePartCov">      4  /  10:       { return __x == __y; } </span>
<span class="lineNum">  209</span>              :     }; </span>
<span class="lineNum">  210</span>              :  </span>
<span class="lineNum">  211</span>              :   &#047;&#047;&#047; One of the @link comparison_functors comparison functors@endlink. </span>
<span class="lineNum">  212</span>              :   template&lt;typename _Tp&gt; </span>
<span class="lineNum">  213</span>              :     struct not_equal_to : public binary_function&lt;_Tp, _Tp, bool&gt; </span>
<span class="lineNum">  214</span>              :     { </span>
<span class="lineNum">  215</span>              :       bool </span>
<span class="lineNum">  216</span>              :       operator()(const _Tp&amp; __x, const _Tp&amp; __y) const </span>
<span class="lineNum">  217</span>              :       { return __x != __y; } </span>
<span class="lineNum">  218</span>              :     }; </span>
<span class="lineNum">  219</span>              :  </span>
<span class="lineNum">  220</span>              :   &#047;&#047;&#047; One of the @link comparison_functors comparison functors@endlink. </span>
<span class="lineNum">  221</span>              :   template&lt;typename _Tp&gt; </span>
<span class="lineNum">  222</span>              :     struct greater : public binary_function&lt;_Tp, _Tp, bool&gt; </span>
<span class="lineNum">  223</span>              :     { </span>
<span class="lineNum">  224</span>              :       bool </span>
<span class="lineNum">  225</span>              :       operator()(const _Tp&amp; __x, const _Tp&amp; __y) const </span>
<span class="lineNum">  226</span>              :       { return __x &gt; __y; } </span>
<span class="lineNum">  227</span>              :     }; </span>
<span class="lineNum">  228</span>              :  </span>
<span class="lineNum">  229</span>              :   &#047;&#047;&#047; One of the @link comparison_functors comparison functors@endlink. </span>
<span class="lineNum">  230</span>              :   template&lt;typename _Tp&gt; </span>
<span class="lineNum">  231</span>              :     struct less : public binary_function&lt;_Tp, _Tp, bool&gt; </span>
<span class="lineNum">  232</span>              :     { </span>
<span class="lineNum">  233</span>              :       bool </span>
<span class="lineNum">  234</span><span class="linePartCov">      2  /   3:       operator()(const _Tp&amp; __x, const _Tp&amp; __y) const </span>
<span class="lineNum">  235</span><span class="linePartCov">      2  /   6:       { return __x &lt; __y; } </span>
<span class="lineNum">  236</span>              :     }; </span>
<span class="lineNum">  237</span>              :  </span>
<span class="lineNum">  238</span>              :   &#047;&#047;&#047; One of the @link comparison_functors comparison functors@endlink. </span>
<span class="lineNum">  239</span>              :   template&lt;typename _Tp&gt; </span>
<span class="lineNum">  240</span>              :     struct greater_equal : public binary_function&lt;_Tp, _Tp, bool&gt; </span>
<span class="lineNum">  241</span>              :     { </span>
<span class="lineNum">  242</span>              :       bool </span>
<span class="lineNum">  243</span>              :       operator()(const _Tp&amp; __x, const _Tp&amp; __y) const </span>
<span class="lineNum">  244</span>              :       { return __x &gt;= __y; } </span>
<span class="lineNum">  245</span>              :     }; </span>
<span class="lineNum">  246</span>              :  </span>
<span class="lineNum">  247</span>              :   &#047;&#047;&#047; One of the @link comparison_functors comparison functors@endlink. </span>
<span class="lineNum">  248</span>              :   template&lt;typename _Tp&gt; </span>
<span class="lineNum">  249</span>              :     struct less_equal : public binary_function&lt;_Tp, _Tp, bool&gt; </span>
<span class="lineNum">  250</span>              :     { </span>
<span class="lineNum">  251</span>              :       bool </span>
<span class="lineNum">  252</span>              :       operator()(const _Tp&amp; __x, const _Tp&amp; __y) const </span>
<span class="lineNum">  253</span>              :       { return __x &lt;= __y; } </span>
<span class="lineNum">  254</span>              :     }; </span>
<span class="lineNum">  255</span>              :   &#047;** @}  *&#047; </span>
<span class="lineNum">  256</span>              :  </span>
<span class="lineNum">  257</span>              :   &#047;&#047; 20.3.4 logical operations </span>
<span class="lineNum">  258</span>              :   &#047;** @defgroup logical_functors Boolean Operations Classes </span>
<span class="lineNum">  259</span>              :    * @ingroup functors </span>
<span class="lineNum">  260</span>              :    * </span>
<span class="lineNum">  261</span>              :    *  Here are wrapper functors for Boolean operations: @c &amp;&amp;, @c ||, </span>
<span class="lineNum">  262</span>              :    *  and @c !. </span>
<span class="lineNum">  263</span>              :    * </span>
<span class="lineNum">  264</span>              :    *  @{ </span>
<span class="lineNum">  265</span>              :    *&#047; </span>
<span class="lineNum">  266</span>              :   &#047;&#047;&#047; One of the @link logical_functors Boolean operations functors@endlink. </span>
<span class="lineNum">  267</span>              :   template&lt;typename _Tp&gt; </span>
<span class="lineNum">  268</span>              :     struct logical_and : public binary_function&lt;_Tp, _Tp, bool&gt; </span>
<span class="lineNum">  269</span>              :     { </span>
<span class="lineNum">  270</span>              :       bool </span>
<span class="lineNum">  271</span>              :       operator()(const _Tp&amp; __x, const _Tp&amp; __y) const </span>
<span class="lineNum">  272</span>              :       { return __x &amp;&amp; __y; } </span>
<span class="lineNum">  273</span>              :     }; </span>
<span class="lineNum">  274</span>              :  </span>
<span class="lineNum">  275</span>              :   &#047;&#047;&#047; One of the @link logical_functors Boolean operations functors@endlink. </span>
<span class="lineNum">  276</span>              :   template&lt;typename _Tp&gt; </span>
<span class="lineNum">  277</span>              :     struct logical_or : public binary_function&lt;_Tp, _Tp, bool&gt; </span>
<span class="lineNum">  278</span>              :     { </span>
<span class="lineNum">  279</span>              :       bool </span>
<span class="lineNum">  280</span>              :       operator()(const _Tp&amp; __x, const _Tp&amp; __y) const </span>
<span class="lineNum">  281</span>              :       { return __x || __y; } </span>
<span class="lineNum">  282</span>              :     }; </span>
<span class="lineNum">  283</span>              :  </span>
<span class="lineNum">  284</span>              :   &#047;&#047;&#047; One of the @link logical_functors Boolean operations functors@endlink. </span>
<span class="lineNum">  285</span>              :   template&lt;typename _Tp&gt; </span>
<span class="lineNum">  286</span>              :     struct logical_not : public unary_function&lt;_Tp, bool&gt; </span>
<span class="lineNum">  287</span>              :     { </span>
<span class="lineNum">  288</span>              :       bool </span>
<span class="lineNum">  289</span>              :       operator()(const _Tp&amp; __x) const </span>
<span class="lineNum">  290</span>              :       { return !__x; } </span>
<span class="lineNum">  291</span>              :     }; </span>
<span class="lineNum">  292</span>              :   &#047;** @}  *&#047; </span>
<span class="lineNum">  293</span>              :  </span>
<span class="lineNum">  294</span>              :   &#047;&#047; _GLIBCXX_RESOLVE_LIB_DEFECTS </span>
<span class="lineNum">  295</span>              :   &#047;&#047; DR 660. Missing Bitwise Operations. </span>
<span class="lineNum">  296</span>              :   template&lt;typename _Tp&gt; </span>
<span class="lineNum">  297</span>              :     struct bit_and : public binary_function&lt;_Tp, _Tp, _Tp&gt; </span>
<span class="lineNum">  298</span>              :     { </span>
<span class="lineNum">  299</span>              :       _Tp </span>
<span class="lineNum">  300</span>              :       operator()(const _Tp&amp; __x, const _Tp&amp; __y) const </span>
<span class="lineNum">  301</span>              :       { return __x &amp; __y; } </span>
<span class="lineNum">  302</span>              :     }; </span>
<span class="lineNum">  303</span>              :  </span>
<span class="lineNum">  304</span>              :   template&lt;typename _Tp&gt; </span>
<span class="lineNum">  305</span>              :     struct bit_or : public binary_function&lt;_Tp, _Tp, _Tp&gt; </span>
<span class="lineNum">  306</span>              :     { </span>
<span class="lineNum">  307</span>              :       _Tp </span>
<span class="lineNum">  308</span>              :       operator()(const _Tp&amp; __x, const _Tp&amp; __y) const </span>
<span class="lineNum">  309</span>              :       { return __x | __y; } </span>
<span class="lineNum">  310</span>              :     }; </span>
<span class="lineNum">  311</span>              :  </span>
<span class="lineNum">  312</span>              :   template&lt;typename _Tp&gt; </span>
<span class="lineNum">  313</span>              :     struct bit_xor : public binary_function&lt;_Tp, _Tp, _Tp&gt; </span>
<span class="lineNum">  314</span>              :     { </span>
<span class="lineNum">  315</span>              :       _Tp </span>
<span class="lineNum">  316</span>              :       operator()(const _Tp&amp; __x, const _Tp&amp; __y) const </span>
<span class="lineNum">  317</span>              :       { return __x ^ __y; } </span>
<span class="lineNum">  318</span>              :     }; </span>
<span class="lineNum">  319</span>              :  </span>
<span class="lineNum">  320</span>              :   &#047;&#047; 20.3.5 negators </span>
<span class="lineNum">  321</span>              :   &#047;** @defgroup negators Negators </span>
<span class="lineNum">  322</span>              :    * @ingroup functors </span>
<span class="lineNum">  323</span>              :    * </span>
<span class="lineNum">  324</span>              :    *  The functions @c not1 and @c not2 each take a predicate functor </span>
<span class="lineNum">  325</span>              :    *  and return an instance of @c unary_negate or </span>
<span class="lineNum">  326</span>              :    *  @c binary_negate, respectively.  These classes are functors whose </span>
<span class="lineNum">  327</span>              :    *  @c operator() performs the stored predicate function and then returns </span>
<span class="lineNum">  328</span>              :    *  the negation of the result. </span>
<span class="lineNum">  329</span>              :    * </span>
<span class="lineNum">  330</span>              :    *  For example, given a vector of integers and a trivial predicate, </span>
<span class="lineNum">  331</span>              :    *  &#092;code </span>
<span class="lineNum">  332</span>              :    *  struct IntGreaterThanThree </span>
<span class="lineNum">  333</span>              :    *    : public std::unary_function&lt;int, bool&gt; </span>
<span class="lineNum">  334</span>              :    *  { </span>
<span class="lineNum">  335</span>              :    *      bool operator() (int x) { return x &gt; 3; } </span>
<span class="lineNum">  336</span>              :    *  }; </span>
<span class="lineNum">  337</span>              :    * </span>
<span class="lineNum">  338</span>              :    *  std::find_if (v.begin(), v.end(), not1(IntGreaterThanThree())); </span>
<span class="lineNum">  339</span>              :    *  &#092;endcode </span>
<span class="lineNum">  340</span>              :    *  The call to @c find_if will locate the first index (i) of @c v for which </span>
<span class="lineNum">  341</span>              :    *  &lt;code&gt;!(v[i] &gt; 3)&lt;&#047;code&gt; is true. </span>
<span class="lineNum">  342</span>              :    * </span>
<span class="lineNum">  343</span>              :    *  The not1&#047;unary_negate combination works on predicates taking a single </span>
<span class="lineNum">  344</span>              :    *  argument.  The not2&#047;binary_negate combination works on predicates which </span>
<span class="lineNum">  345</span>              :    *  take two arguments. </span>
<span class="lineNum">  346</span>              :    * </span>
<span class="lineNum">  347</span>              :    *  @{ </span>
<span class="lineNum">  348</span>              :    *&#047; </span>
<span class="lineNum">  349</span>              :   &#047;&#047;&#047; One of the @link negators negation functors@endlink. </span>
<span class="lineNum">  350</span>              :   template&lt;typename _Predicate&gt; </span>
<span class="lineNum">  351</span>              :     class unary_negate </span>
<span class="lineNum">  352</span>              :     : public unary_function&lt;typename _Predicate::argument_type, bool&gt; </span>
<span class="lineNum">  353</span>              :     { </span>
<span class="lineNum">  354</span>              :     protected: </span>
<span class="lineNum">  355</span>              :       _Predicate _M_pred; </span>
<span class="lineNum">  356</span>              :  </span>
<span class="lineNum">  357</span>              :     public: </span>
<span class="lineNum">  358</span>              :       explicit </span>
<span class="lineNum">  359</span>              :       unary_negate(const _Predicate&amp; __x) : _M_pred(__x) { } </span>
<span class="lineNum">  360</span>              :  </span>
<span class="lineNum">  361</span>              :       bool </span>
<span class="lineNum">  362</span>              :       operator()(const typename _Predicate::argument_type&amp; __x) const </span>
<span class="lineNum">  363</span>              :       { return !_M_pred(__x); } </span>
<span class="lineNum">  364</span>              :     }; </span>
<span class="lineNum">  365</span>              :  </span>
<span class="lineNum">  366</span>              :   &#047;&#047;&#047; One of the @link negators negation functors@endlink. </span>
<span class="lineNum">  367</span>              :   template&lt;typename _Predicate&gt; </span>
<span class="lineNum">  368</span>              :     inline unary_negate&lt;_Predicate&gt; </span>
<span class="lineNum">  369</span>              :     not1(const _Predicate&amp; __pred) </span>
<span class="lineNum">  370</span>              :     { return unary_negate&lt;_Predicate&gt;(__pred); } </span>
<span class="lineNum">  371</span>              :  </span>
<span class="lineNum">  372</span>              :   &#047;&#047;&#047; One of the @link negators negation functors@endlink. </span>
<span class="lineNum">  373</span>              :   template&lt;typename _Predicate&gt; </span>
<span class="lineNum">  374</span>              :     class binary_negate </span>
<span class="lineNum">  375</span>              :     : public binary_function&lt;typename _Predicate::first_argument_type, </span>
<span class="lineNum">  376</span>              : 			     typename _Predicate::second_argument_type, bool&gt; </span>
<span class="lineNum">  377</span>              :     { </span>
<span class="lineNum">  378</span>              :     protected: </span>
<span class="lineNum">  379</span>              :       _Predicate _M_pred; </span>
<span class="lineNum">  380</span>              :  </span>
<span class="lineNum">  381</span>              :     public: </span>
<span class="lineNum">  382</span>              :       explicit </span>
<span class="lineNum">  383</span>              :       binary_negate(const _Predicate&amp; __x) : _M_pred(__x) { } </span>
<span class="lineNum">  384</span>              :  </span>
<span class="lineNum">  385</span>              :       bool </span>
<span class="lineNum">  386</span>              :       operator()(const typename _Predicate::first_argument_type&amp; __x, </span>
<span class="lineNum">  387</span>              : 		 const typename _Predicate::second_argument_type&amp; __y) const </span>
<span class="lineNum">  388</span>              :       { return !_M_pred(__x, __y); } </span>
<span class="lineNum">  389</span>              :     }; </span>
<span class="lineNum">  390</span>              :  </span>
<span class="lineNum">  391</span>              :   &#047;&#047;&#047; One of the @link negators negation functors@endlink. </span>
<span class="lineNum">  392</span>              :   template&lt;typename _Predicate&gt; </span>
<span class="lineNum">  393</span>              :     inline binary_negate&lt;_Predicate&gt; </span>
<span class="lineNum">  394</span>              :     not2(const _Predicate&amp; __pred) </span>
<span class="lineNum">  395</span>              :     { return binary_negate&lt;_Predicate&gt;(__pred); } </span>
<span class="lineNum">  396</span>              :   &#047;** @}  *&#047; </span>
<span class="lineNum">  397</span>              :  </span>
<span class="lineNum">  398</span>              :   &#047;&#047; 20.3.7 adaptors pointers functions </span>
<span class="lineNum">  399</span>              :   &#047;** @defgroup pointer_adaptors Adaptors for pointers to functions </span>
<span class="lineNum">  400</span>              :    * @ingroup functors </span>
<span class="lineNum">  401</span>              :    * </span>
<span class="lineNum">  402</span>              :    *  The advantage of function objects over pointers to functions is that </span>
<span class="lineNum">  403</span>              :    *  the objects in the standard library declare nested typedefs describing </span>
<span class="lineNum">  404</span>              :    *  their argument and result types with uniform names (e.g., @c result_type </span>
<span class="lineNum">  405</span>              :    *  from the base classes @c unary_function and @c binary_function). </span>
<span class="lineNum">  406</span>              :    *  Sometimes those typedefs are required, not just optional. </span>
<span class="lineNum">  407</span>              :    * </span>
<span class="lineNum">  408</span>              :    *  Adaptors are provided to turn pointers to unary (single-argument) and </span>
<span class="lineNum">  409</span>              :    *  binary (double-argument) functions into function objects.  The </span>
<span class="lineNum">  410</span>              :    *  long-winded functor @c pointer_to_unary_function is constructed with a </span>
<span class="lineNum">  411</span>              :    *  function pointer @c f, and its @c operator() called with argument @c x </span>
<span class="lineNum">  412</span>              :    *  returns @c f(x).  The functor @c pointer_to_binary_function does the same </span>
<span class="lineNum">  413</span>              :    *  thing, but with a double-argument @c f and @c operator(). </span>
<span class="lineNum">  414</span>              :    * </span>
<span class="lineNum">  415</span>              :    *  The function @c ptr_fun takes a pointer-to-function @c f and constructs </span>
<span class="lineNum">  416</span>              :    *  an instance of the appropriate functor. </span>
<span class="lineNum">  417</span>              :    * </span>
<span class="lineNum">  418</span>              :    *  @{ </span>
<span class="lineNum">  419</span>              :    *&#047; </span>
<span class="lineNum">  420</span>              :   &#047;&#047;&#047; One of the @link pointer_adaptors adaptors for function pointers@endlink. </span>
<span class="lineNum">  421</span>              :   template&lt;typename _Arg, typename _Result&gt; </span>
<span class="lineNum">  422</span>              :     class pointer_to_unary_function : public unary_function&lt;_Arg, _Result&gt; </span>
<span class="lineNum">  423</span>              :     { </span>
<span class="lineNum">  424</span>              :     protected: </span>
<span class="lineNum">  425</span>              :       _Result (*_M_ptr)(_Arg); </span>
<span class="lineNum">  426</span>              :  </span>
<span class="lineNum">  427</span>              :     public: </span>
<span class="lineNum">  428</span>              :       pointer_to_unary_function() { } </span>
<span class="lineNum">  429</span>              :  </span>
<span class="lineNum">  430</span>              :       explicit </span>
<span class="lineNum">  431</span>              :       pointer_to_unary_function(_Result (*__x)(_Arg)) </span>
<span class="lineNum">  432</span>              :       : _M_ptr(__x) { } </span>
<span class="lineNum">  433</span>              :  </span>
<span class="lineNum">  434</span>              :       _Result </span>
<span class="lineNum">  435</span>              :       operator()(_Arg __x) const </span>
<span class="lineNum">  436</span>              :       { return _M_ptr(__x); } </span>
<span class="lineNum">  437</span>              :     }; </span>
<span class="lineNum">  438</span>              :  </span>
<span class="lineNum">  439</span>              :   &#047;&#047;&#047; One of the @link pointer_adaptors adaptors for function pointers@endlink. </span>
<span class="lineNum">  440</span>              :   template&lt;typename _Arg, typename _Result&gt; </span>
<span class="lineNum">  441</span>              :     inline pointer_to_unary_function&lt;_Arg, _Result&gt; </span>
<span class="lineNum">  442</span>              :     ptr_fun(_Result (*__x)(_Arg)) </span>
<span class="lineNum">  443</span>              :     { return pointer_to_unary_function&lt;_Arg, _Result&gt;(__x); } </span>
<span class="lineNum">  444</span>              :  </span>
<span class="lineNum">  445</span>              :   &#047;&#047;&#047; One of the @link pointer_adaptors adaptors for function pointers@endlink. </span>
<span class="lineNum">  446</span>              :   template&lt;typename _Arg1, typename _Arg2, typename _Result&gt; </span>
<span class="lineNum">  447</span>              :     class pointer_to_binary_function </span>
<span class="lineNum">  448</span>              :     : public binary_function&lt;_Arg1, _Arg2, _Result&gt; </span>
<span class="lineNum">  449</span>              :     { </span>
<span class="lineNum">  450</span>              :     protected: </span>
<span class="lineNum">  451</span>              :       _Result (*_M_ptr)(_Arg1, _Arg2); </span>
<span class="lineNum">  452</span>              :  </span>
<span class="lineNum">  453</span>              :     public: </span>
<span class="lineNum">  454</span>              :       pointer_to_binary_function() { } </span>
<span class="lineNum">  455</span>              :  </span>
<span class="lineNum">  456</span>              :       explicit </span>
<span class="lineNum">  457</span>              :       pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2)) </span>
<span class="lineNum">  458</span>              :       : _M_ptr(__x) { } </span>
<span class="lineNum">  459</span>              :  </span>
<span class="lineNum">  460</span>              :       _Result </span>
<span class="lineNum">  461</span>              :       operator()(_Arg1 __x, _Arg2 __y) const </span>
<span class="lineNum">  462</span>              :       { return _M_ptr(__x, __y); } </span>
<span class="lineNum">  463</span>              :     }; </span>
<span class="lineNum">  464</span>              :  </span>
<span class="lineNum">  465</span>              :   &#047;&#047;&#047; One of the @link pointer_adaptors adaptors for function pointers@endlink. </span>
<span class="lineNum">  466</span>              :   template&lt;typename _Arg1, typename _Arg2, typename _Result&gt; </span>
<span class="lineNum">  467</span>              :     inline pointer_to_binary_function&lt;_Arg1, _Arg2, _Result&gt; </span>
<span class="lineNum">  468</span>              :     ptr_fun(_Result (*__x)(_Arg1, _Arg2)) </span>
<span class="lineNum">  469</span>              :     { return pointer_to_binary_function&lt;_Arg1, _Arg2, _Result&gt;(__x); } </span>
<span class="lineNum">  470</span>              :   &#047;** @}  *&#047; </span>
<span class="lineNum">  471</span>              :  </span>
<span class="lineNum">  472</span>              :   template&lt;typename _Tp&gt; </span>
<span class="lineNum">  473</span>              :     struct _Identity </span>
<span class="lineNum">  474</span>              :     : public unary_function&lt;_Tp,_Tp&gt; </span>
<span class="lineNum">  475</span>              :     { </span>
<span class="lineNum">  476</span>              :       _Tp&amp; </span>
<span class="lineNum">  477</span>              :       operator()(_Tp&amp; __x) const </span>
<span class="lineNum">  478</span>              :       { return __x; } </span>
<span class="lineNum">  479</span>              :  </span>
<span class="lineNum">  480</span>              :       const _Tp&amp; </span>
<span class="lineNum">  481</span>              :       operator()(const _Tp&amp; __x) const </span>
<span class="lineNum">  482</span>              :       { return __x; } </span>
<span class="lineNum">  483</span>              :     }; </span>
<span class="lineNum">  484</span>              :  </span>
<span class="lineNum">  485</span>              :   template&lt;typename _Pair&gt; </span>
<span class="lineNum">  486</span>              :     struct _Select1st </span>
<span class="lineNum">  487</span>              :     : public unary_function&lt;_Pair, typename _Pair::first_type&gt; </span>
<span class="lineNum">  488</span>              :     { </span>
<span class="lineNum">  489</span>              :       typename _Pair::first_type&amp; </span>
<span class="lineNum">  490</span>              :       operator()(_Pair&amp; __x) const </span>
<span class="lineNum">  491</span>              :       { return __x.first; } </span>
<span class="lineNum">  492</span>              :  </span>
<span class="lineNum">  493</span>              :       const typename _Pair::first_type&amp; </span>
<span class="lineNum">  494</span><span class="linePartCov">      2  /   3:       operator()(const _Pair&amp; __x) const </span>
<span class="lineNum">  495</span><span class="linePartCov">      2  /   6:       { return __x.first; } </span>
<span class="lineNum">  496</span>              :  </span>
<span class="lineNum">  497</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  498</span>              :       template&lt;typename _Pair2&gt; </span>
<span class="lineNum">  499</span>              :         typename _Pair2::first_type&amp; </span>
<span class="lineNum">  500</span><span class="lineCov">      1  /   1:         operator()(_Pair2&amp; __x) const </span>
<span class="lineNum">  501</span><span class="linePartCov">      1  /   2:         { return __x.first; } </span>
<span class="lineNum">  502</span>              :  </span>
<span class="lineNum">  503</span>              :       template&lt;typename _Pair2&gt; </span>
<span class="lineNum">  504</span>              :         const typename _Pair2::first_type&amp; </span>
<span class="lineNum">  505</span>              :         operator()(const _Pair2&amp; __x) const </span>
<span class="lineNum">  506</span>              :         { return __x.first; } </span>
<span class="lineNum">  507</span>              : #endif </span>
<span class="lineNum">  508</span>              :     }; </span>
<span class="lineNum">  509</span>              :  </span>
<span class="lineNum">  510</span>              :   template&lt;typename _Pair&gt; </span>
<span class="lineNum">  511</span>              :     struct _Select2nd </span>
<span class="lineNum">  512</span>              :     : public unary_function&lt;_Pair, typename _Pair::second_type&gt; </span>
<span class="lineNum">  513</span>              :     { </span>
<span class="lineNum">  514</span>              :       typename _Pair::second_type&amp; </span>
<span class="lineNum">  515</span>              :       operator()(_Pair&amp; __x) const </span>
<span class="lineNum">  516</span>              :       { return __x.second; } </span>
<span class="lineNum">  517</span>              :  </span>
<span class="lineNum">  518</span>              :       const typename _Pair::second_type&amp; </span>
<span class="lineNum">  519</span>              :       operator()(const _Pair&amp; __x) const </span>
<span class="lineNum">  520</span>              :       { return __x.second; } </span>
<span class="lineNum">  521</span>              :     }; </span>
<span class="lineNum">  522</span>              :  </span>
<span class="lineNum">  523</span>              :   &#047;&#047; 20.3.8 adaptors pointers members </span>
<span class="lineNum">  524</span>              :   &#047;** @defgroup memory_adaptors Adaptors for pointers to members </span>
<span class="lineNum">  525</span>              :    * @ingroup functors </span>
<span class="lineNum">  526</span>              :    * </span>
<span class="lineNum">  527</span>              :    *  There are a total of 8 = 2^3 function objects in this family. </span>
<span class="lineNum">  528</span>              :    *   (1) Member functions taking no arguments vs member functions taking </span>
<span class="lineNum">  529</span>              :    *        one argument. </span>
<span class="lineNum">  530</span>              :    *   (2) Call through pointer vs call through reference. </span>
<span class="lineNum">  531</span>              :    *   (3) Const vs non-const member function. </span>
<span class="lineNum">  532</span>              :    * </span>
<span class="lineNum">  533</span>              :    *  All of this complexity is in the function objects themselves.  You can </span>
<span class="lineNum">  534</span>              :    *   ignore it by using the helper function mem_fun and mem_fun_ref, </span>
<span class="lineNum">  535</span>              :    *   which create whichever type of adaptor is appropriate. </span>
<span class="lineNum">  536</span>              :    * </span>
<span class="lineNum">  537</span>              :    *  @{ </span>
<span class="lineNum">  538</span>              :    *&#047; </span>
<span class="lineNum">  539</span>              :   &#047;&#047;&#047; One of the @link memory_adaptors adaptors for member </span>
<span class="lineNum">  540</span>              :   &#047;&#047;&#047; pointers@endlink. </span>
<span class="lineNum">  541</span>              :   template&lt;typename _Ret, typename _Tp&gt; </span>
<span class="lineNum">  542</span>              :     class mem_fun_t : public unary_function&lt;_Tp*, _Ret&gt; </span>
<span class="lineNum">  543</span>              :     { </span>
<span class="lineNum">  544</span>              :     public: </span>
<span class="lineNum">  545</span>              :       explicit </span>
<span class="lineNum">  546</span>              :       mem_fun_t(_Ret (_Tp::*__pf)()) </span>
<span class="lineNum">  547</span>              :       : _M_f(__pf) { } </span>
<span class="lineNum">  548</span>              :  </span>
<span class="lineNum">  549</span>              :       _Ret </span>
<span class="lineNum">  550</span>              :       operator()(_Tp* __p) const </span>
<span class="lineNum">  551</span>              :       { return (__p-&gt;*_M_f)(); } </span>
<span class="lineNum">  552</span>              :  </span>
<span class="lineNum">  553</span>              :     private: </span>
<span class="lineNum">  554</span>              :       _Ret (_Tp::*_M_f)(); </span>
<span class="lineNum">  555</span>              :     }; </span>
<span class="lineNum">  556</span>              :  </span>
<span class="lineNum">  557</span>              :   &#047;&#047;&#047; One of the @link memory_adaptors adaptors for member </span>
<span class="lineNum">  558</span>              :   &#047;&#047;&#047; pointers@endlink. </span>
<span class="lineNum">  559</span>              :   template&lt;typename _Ret, typename _Tp&gt; </span>
<span class="lineNum">  560</span>              :     class const_mem_fun_t : public unary_function&lt;const _Tp*, _Ret&gt; </span>
<span class="lineNum">  561</span>              :     { </span>
<span class="lineNum">  562</span>              :     public: </span>
<span class="lineNum">  563</span>              :       explicit </span>
<span class="lineNum">  564</span>              :       const_mem_fun_t(_Ret (_Tp::*__pf)() const) </span>
<span class="lineNum">  565</span>              :       : _M_f(__pf) { } </span>
<span class="lineNum">  566</span>              :  </span>
<span class="lineNum">  567</span>              :       _Ret </span>
<span class="lineNum">  568</span>              :       operator()(const _Tp* __p) const </span>
<span class="lineNum">  569</span>              :       { return (__p-&gt;*_M_f)(); } </span>
<span class="lineNum">  570</span>              :  </span>
<span class="lineNum">  571</span>              :     private: </span>
<span class="lineNum">  572</span>              :       _Ret (_Tp::*_M_f)() const; </span>
<span class="lineNum">  573</span>              :     }; </span>
<span class="lineNum">  574</span>              :  </span>
<span class="lineNum">  575</span>              :   &#047;&#047;&#047; One of the @link memory_adaptors adaptors for member </span>
<span class="lineNum">  576</span>              :   &#047;&#047;&#047; pointers@endlink. </span>
<span class="lineNum">  577</span>              :   template&lt;typename _Ret, typename _Tp&gt; </span>
<span class="lineNum">  578</span>              :     class mem_fun_ref_t : public unary_function&lt;_Tp, _Ret&gt; </span>
<span class="lineNum">  579</span>              :     { </span>
<span class="lineNum">  580</span>              :     public: </span>
<span class="lineNum">  581</span>              :       explicit </span>
<span class="lineNum">  582</span>              :       mem_fun_ref_t(_Ret (_Tp::*__pf)()) </span>
<span class="lineNum">  583</span>              :       : _M_f(__pf) { } </span>
<span class="lineNum">  584</span>              :  </span>
<span class="lineNum">  585</span>              :       _Ret </span>
<span class="lineNum">  586</span>              :       operator()(_Tp&amp; __r) const </span>
<span class="lineNum">  587</span>              :       { return (__r.*_M_f)(); } </span>
<span class="lineNum">  588</span>              :  </span>
<span class="lineNum">  589</span>              :     private: </span>
<span class="lineNum">  590</span>              :       _Ret (_Tp::*_M_f)(); </span>
<span class="lineNum">  591</span>              :   }; </span>
<span class="lineNum">  592</span>              :  </span>
<span class="lineNum">  593</span>              :   &#047;&#047;&#047; One of the @link memory_adaptors adaptors for member </span>
<span class="lineNum">  594</span>              :   &#047;&#047;&#047; pointers@endlink. </span>
<span class="lineNum">  595</span>              :   template&lt;typename _Ret, typename _Tp&gt; </span>
<span class="lineNum">  596</span>              :     class const_mem_fun_ref_t : public unary_function&lt;_Tp, _Ret&gt; </span>
<span class="lineNum">  597</span>              :     { </span>
<span class="lineNum">  598</span>              :     public: </span>
<span class="lineNum">  599</span>              :       explicit </span>
<span class="lineNum">  600</span>              :       const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const) </span>
<span class="lineNum">  601</span>              :       : _M_f(__pf) { } </span>
<span class="lineNum">  602</span>              :  </span>
<span class="lineNum">  603</span>              :       _Ret </span>
<span class="lineNum">  604</span>              :       operator()(const _Tp&amp; __r) const </span>
<span class="lineNum">  605</span>              :       { return (__r.*_M_f)(); } </span>
<span class="lineNum">  606</span>              :  </span>
<span class="lineNum">  607</span>              :     private: </span>
<span class="lineNum">  608</span>              :       _Ret (_Tp::*_M_f)() const; </span>
<span class="lineNum">  609</span>              :     }; </span>
<span class="lineNum">  610</span>              :  </span>
<span class="lineNum">  611</span>              :   &#047;&#047;&#047; One of the @link memory_adaptors adaptors for member </span>
<span class="lineNum">  612</span>              :   &#047;&#047;&#047; pointers@endlink. </span>
<span class="lineNum">  613</span>              :   template&lt;typename _Ret, typename _Tp, typename _Arg&gt; </span>
<span class="lineNum">  614</span>              :     class mem_fun1_t : public binary_function&lt;_Tp*, _Arg, _Ret&gt; </span>
<span class="lineNum">  615</span>              :     { </span>
<span class="lineNum">  616</span>              :     public: </span>
<span class="lineNum">  617</span>              :       explicit </span>
<span class="lineNum">  618</span>              :       mem_fun1_t(_Ret (_Tp::*__pf)(_Arg)) </span>
<span class="lineNum">  619</span>              :       : _M_f(__pf) { } </span>
<span class="lineNum">  620</span>              :  </span>
<span class="lineNum">  621</span>              :       _Ret </span>
<span class="lineNum">  622</span>              :       operator()(_Tp* __p, _Arg __x) const </span>
<span class="lineNum">  623</span>              :       { return (__p-&gt;*_M_f)(__x); } </span>
<span class="lineNum">  624</span>              :  </span>
<span class="lineNum">  625</span>              :     private: </span>
<span class="lineNum">  626</span>              :       _Ret (_Tp::*_M_f)(_Arg); </span>
<span class="lineNum">  627</span>              :     }; </span>
<span class="lineNum">  628</span>              :  </span>
<span class="lineNum">  629</span>              :   &#047;&#047;&#047; One of the @link memory_adaptors adaptors for member </span>
<span class="lineNum">  630</span>              :   &#047;&#047;&#047; pointers@endlink. </span>
<span class="lineNum">  631</span>              :   template&lt;typename _Ret, typename _Tp, typename _Arg&gt; </span>
<span class="lineNum">  632</span>              :     class const_mem_fun1_t : public binary_function&lt;const _Tp*, _Arg, _Ret&gt; </span>
<span class="lineNum">  633</span>              :     { </span>
<span class="lineNum">  634</span>              :     public: </span>
<span class="lineNum">  635</span>              :       explicit </span>
<span class="lineNum">  636</span>              :       const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const) </span>
<span class="lineNum">  637</span>              :       : _M_f(__pf) { } </span>
<span class="lineNum">  638</span>              :  </span>
<span class="lineNum">  639</span>              :       _Ret </span>
<span class="lineNum">  640</span>              :       operator()(const _Tp* __p, _Arg __x) const </span>
<span class="lineNum">  641</span>              :       { return (__p-&gt;*_M_f)(__x); } </span>
<span class="lineNum">  642</span>              :  </span>
<span class="lineNum">  643</span>              :     private: </span>
<span class="lineNum">  644</span>              :       _Ret (_Tp::*_M_f)(_Arg) const; </span>
<span class="lineNum">  645</span>              :     }; </span>
<span class="lineNum">  646</span>              :  </span>
<span class="lineNum">  647</span>              :   &#047;&#047;&#047; One of the @link memory_adaptors adaptors for member </span>
<span class="lineNum">  648</span>              :   &#047;&#047;&#047; pointers@endlink. </span>
<span class="lineNum">  649</span>              :   template&lt;typename _Ret, typename _Tp, typename _Arg&gt; </span>
<span class="lineNum">  650</span>              :     class mem_fun1_ref_t : public binary_function&lt;_Tp, _Arg, _Ret&gt; </span>
<span class="lineNum">  651</span>              :     { </span>
<span class="lineNum">  652</span>              :     public: </span>
<span class="lineNum">  653</span>              :       explicit </span>
<span class="lineNum">  654</span>              :       mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg)) </span>
<span class="lineNum">  655</span>              :       : _M_f(__pf) { } </span>
<span class="lineNum">  656</span>              :  </span>
<span class="lineNum">  657</span>              :       _Ret </span>
<span class="lineNum">  658</span>              :       operator()(_Tp&amp; __r, _Arg __x) const </span>
<span class="lineNum">  659</span>              :       { return (__r.*_M_f)(__x); } </span>
<span class="lineNum">  660</span>              :  </span>
<span class="lineNum">  661</span>              :     private: </span>
<span class="lineNum">  662</span>              :       _Ret (_Tp::*_M_f)(_Arg); </span>
<span class="lineNum">  663</span>              :     }; </span>
<span class="lineNum">  664</span>              :  </span>
<span class="lineNum">  665</span>              :   &#047;&#047;&#047; One of the @link memory_adaptors adaptors for member </span>
<span class="lineNum">  666</span>              :   &#047;&#047;&#047; pointers@endlink. </span>
<span class="lineNum">  667</span>              :   template&lt;typename _Ret, typename _Tp, typename _Arg&gt; </span>
<span class="lineNum">  668</span>              :     class const_mem_fun1_ref_t : public binary_function&lt;_Tp, _Arg, _Ret&gt; </span>
<span class="lineNum">  669</span>              :     { </span>
<span class="lineNum">  670</span>              :     public: </span>
<span class="lineNum">  671</span>              :       explicit </span>
<span class="lineNum">  672</span>              :       const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const) </span>
<span class="lineNum">  673</span>              :       : _M_f(__pf) { } </span>
<span class="lineNum">  674</span>              :  </span>
<span class="lineNum">  675</span>              :       _Ret </span>
<span class="lineNum">  676</span>              :       operator()(const _Tp&amp; __r, _Arg __x) const </span>
<span class="lineNum">  677</span>              :       { return (__r.*_M_f)(__x); } </span>
<span class="lineNum">  678</span>              :  </span>
<span class="lineNum">  679</span>              :     private: </span>
<span class="lineNum">  680</span>              :       _Ret (_Tp::*_M_f)(_Arg) const; </span>
<span class="lineNum">  681</span>              :     }; </span>
<span class="lineNum">  682</span>              :  </span>
<span class="lineNum">  683</span>              :   &#047;&#047; Mem_fun adaptor helper functions.  There are only two: </span>
<span class="lineNum">  684</span>              :   &#047;&#047; mem_fun and mem_fun_ref. </span>
<span class="lineNum">  685</span>              :   template&lt;typename _Ret, typename _Tp&gt; </span>
<span class="lineNum">  686</span>              :     inline mem_fun_t&lt;_Ret, _Tp&gt; </span>
<span class="lineNum">  687</span>              :     mem_fun(_Ret (_Tp::*__f)()) </span>
<span class="lineNum">  688</span>              :     { return mem_fun_t&lt;_Ret, _Tp&gt;(__f); } </span>
<span class="lineNum">  689</span>              :  </span>
<span class="lineNum">  690</span>              :   template&lt;typename _Ret, typename _Tp&gt; </span>
<span class="lineNum">  691</span>              :     inline const_mem_fun_t&lt;_Ret, _Tp&gt; </span>
<span class="lineNum">  692</span>              :     mem_fun(_Ret (_Tp::*__f)() const) </span>
<span class="lineNum">  693</span>              :     { return const_mem_fun_t&lt;_Ret, _Tp&gt;(__f); } </span>
<span class="lineNum">  694</span>              :  </span>
<span class="lineNum">  695</span>              :   template&lt;typename _Ret, typename _Tp&gt; </span>
<span class="lineNum">  696</span>              :     inline mem_fun_ref_t&lt;_Ret, _Tp&gt; </span>
<span class="lineNum">  697</span>              :     mem_fun_ref(_Ret (_Tp::*__f)()) </span>
<span class="lineNum">  698</span>              :     { return mem_fun_ref_t&lt;_Ret, _Tp&gt;(__f); } </span>
<span class="lineNum">  699</span>              :  </span>
<span class="lineNum">  700</span>              :   template&lt;typename _Ret, typename _Tp&gt; </span>
<span class="lineNum">  701</span>              :     inline const_mem_fun_ref_t&lt;_Ret, _Tp&gt; </span>
<span class="lineNum">  702</span>              :     mem_fun_ref(_Ret (_Tp::*__f)() const) </span>
<span class="lineNum">  703</span>              :     { return const_mem_fun_ref_t&lt;_Ret, _Tp&gt;(__f); } </span>
<span class="lineNum">  704</span>              :  </span>
<span class="lineNum">  705</span>              :   template&lt;typename _Ret, typename _Tp, typename _Arg&gt; </span>
<span class="lineNum">  706</span>              :     inline mem_fun1_t&lt;_Ret, _Tp, _Arg&gt; </span>
<span class="lineNum">  707</span>              :     mem_fun(_Ret (_Tp::*__f)(_Arg)) </span>
<span class="lineNum">  708</span>              :     { return mem_fun1_t&lt;_Ret, _Tp, _Arg&gt;(__f); } </span>
<span class="lineNum">  709</span>              :  </span>
<span class="lineNum">  710</span>              :   template&lt;typename _Ret, typename _Tp, typename _Arg&gt; </span>
<span class="lineNum">  711</span>              :     inline const_mem_fun1_t&lt;_Ret, _Tp, _Arg&gt; </span>
<span class="lineNum">  712</span>              :     mem_fun(_Ret (_Tp::*__f)(_Arg) const) </span>
<span class="lineNum">  713</span>              :     { return const_mem_fun1_t&lt;_Ret, _Tp, _Arg&gt;(__f); } </span>
<span class="lineNum">  714</span>              :  </span>
<span class="lineNum">  715</span>              :   template&lt;typename _Ret, typename _Tp, typename _Arg&gt; </span>
<span class="lineNum">  716</span>              :     inline mem_fun1_ref_t&lt;_Ret, _Tp, _Arg&gt; </span>
<span class="lineNum">  717</span>              :     mem_fun_ref(_Ret (_Tp::*__f)(_Arg)) </span>
<span class="lineNum">  718</span>              :     { return mem_fun1_ref_t&lt;_Ret, _Tp, _Arg&gt;(__f); } </span>
<span class="lineNum">  719</span>              :  </span>
<span class="lineNum">  720</span>              :   template&lt;typename _Ret, typename _Tp, typename _Arg&gt; </span>
<span class="lineNum">  721</span>              :     inline const_mem_fun1_ref_t&lt;_Ret, _Tp, _Arg&gt; </span>
<span class="lineNum">  722</span>              :     mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const) </span>
<span class="lineNum">  723</span>              :     { return const_mem_fun1_ref_t&lt;_Ret, _Tp, _Arg&gt;(__f); } </span>
<span class="lineNum">  724</span>              :  </span>
<span class="lineNum">  725</span>              :   &#047;** @}  *&#047; </span>
<span class="lineNum">  726</span>              :  </span>
<span class="lineNum">  727</span>              : _GLIBCXX_END_NAMESPACE_VERSION </span>
<span class="lineNum">  728</span>              : } &#047;&#047; namespace </span>
<span class="lineNum">  729</span>              :  </span>
<span class="lineNum">  730</span>              : #if (__cplusplus &lt; 201103L) || _GLIBCXX_USE_DEPRECATED </span>
<span class="lineNum">  731</span>              : # include &lt;backward&#047;binders.h&gt; </span>
<span class="lineNum">  732</span>              : #endif </span>
<span class="lineNum">  733</span>              :  </span>
<span class="lineNum">  734</span>              : #endif &#047;* _STL_FUNCTION_H *&#047; </span>
</pre>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr><td class="versionInfo">Generated by: <a href="http://simonkagstrom.github.com/kcov/index.html">Kcov</a></td></tr>
</table>
<br/>
</body>
</html>
