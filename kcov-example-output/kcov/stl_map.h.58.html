<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Coverage - kcov</title>
  <link rel="stylesheet" type="text/css" href="bcov.css"/>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="title">Coverage Report</td></tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr>
    <td width="100%">
      <table cellpadding="1" border="0" width="100%">
        <tr>
          <td class="headerItem" width="20%">Command:</td>
          <td class="headerValue" width="80%" colspan=6>kcov</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Date:</td>
          <td class="headerValue" width="15%">2014-03-01 10:11:51</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Instrumented&nbsp;lines:</td>
          <td class="headerValue" width="10%">35</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Code&nbsp;covered:</td>
          <td class="coverPerLeftMed" width="15%">60.0%</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Executed&nbsp;lines:</td>
          <td class="headerValue" width="10%">21</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
</table>
<pre class="source">
<span class="lineNum">    1</span>              : &#047;&#047; Map implementation -*- C++ -*- </span>
<span class="lineNum">    2</span>              :  </span>
<span class="lineNum">    3</span>              : &#047;&#047; Copyright (C) 2001-2013 Free Software Foundation, Inc. </span>
<span class="lineNum">    4</span>              : &#047;&#047; </span>
<span class="lineNum">    5</span>              : &#047;&#047; This file is part of the GNU ISO C++ Library.  This library is free </span>
<span class="lineNum">    6</span>              : &#047;&#047; software; you can redistribute it and&#047;or modify it under the </span>
<span class="lineNum">    7</span>              : &#047;&#047; terms of the GNU General Public License as published by the </span>
<span class="lineNum">    8</span>              : &#047;&#047; Free Software Foundation; either version 3, or (at your option) </span>
<span class="lineNum">    9</span>              : &#047;&#047; any later version. </span>
<span class="lineNum">   10</span>              :  </span>
<span class="lineNum">   11</span>              : &#047;&#047; This library is distributed in the hope that it will be useful, </span>
<span class="lineNum">   12</span>              : &#047;&#047; but WITHOUT ANY WARRANTY; without even the implied warranty of </span>
<span class="lineNum">   13</span>              : &#047;&#047; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the </span>
<span class="lineNum">   14</span>              : &#047;&#047; GNU General Public License for more details. </span>
<span class="lineNum">   15</span>              :  </span>
<span class="lineNum">   16</span>              : &#047;&#047; Under Section 7 of GPL version 3, you are granted additional </span>
<span class="lineNum">   17</span>              : &#047;&#047; permissions described in the GCC Runtime Library Exception, version </span>
<span class="lineNum">   18</span>              : &#047;&#047; 3.1, as published by the Free Software Foundation. </span>
<span class="lineNum">   19</span>              :  </span>
<span class="lineNum">   20</span>              : &#047;&#047; You should have received a copy of the GNU General Public License and </span>
<span class="lineNum">   21</span>              : &#047;&#047; a copy of the GCC Runtime Library Exception along with this program; </span>
<span class="lineNum">   22</span>              : &#047;&#047; see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see </span>
<span class="lineNum">   23</span>              : &#047;&#047; &lt;http:&#047;&#047;www.gnu.org&#047;licenses&#047;&gt;. </span>
<span class="lineNum">   24</span>              :  </span>
<span class="lineNum">   25</span>              : &#047;* </span>
<span class="lineNum">   26</span>              :  * </span>
<span class="lineNum">   27</span>              :  * Copyright (c) 1994 </span>
<span class="lineNum">   28</span>              :  * Hewlett-Packard Company </span>
<span class="lineNum">   29</span>              :  * </span>
<span class="lineNum">   30</span>              :  * Permission to use, copy, modify, distribute and sell this software </span>
<span class="lineNum">   31</span>              :  * and its documentation for any purpose is hereby granted without fee, </span>
<span class="lineNum">   32</span>              :  * provided that the above copyright notice appear in all copies and </span>
<span class="lineNum">   33</span>              :  * that both that copyright notice and this permission notice appear </span>
<span class="lineNum">   34</span>              :  * in supporting documentation.  Hewlett-Packard Company makes no </span>
<span class="lineNum">   35</span>              :  * representations about the suitability of this software for any </span>
<span class="lineNum">   36</span>              :  * purpose.  It is provided &quot;as is&quot; without express or implied warranty. </span>
<span class="lineNum">   37</span>              :  * </span>
<span class="lineNum">   38</span>              :  * </span>
<span class="lineNum">   39</span>              :  * Copyright (c) 1996,1997 </span>
<span class="lineNum">   40</span>              :  * Silicon Graphics Computer Systems, Inc. </span>
<span class="lineNum">   41</span>              :  * </span>
<span class="lineNum">   42</span>              :  * Permission to use, copy, modify, distribute and sell this software </span>
<span class="lineNum">   43</span>              :  * and its documentation for any purpose is hereby granted without fee, </span>
<span class="lineNum">   44</span>              :  * provided that the above copyright notice appear in all copies and </span>
<span class="lineNum">   45</span>              :  * that both that copyright notice and this permission notice appear </span>
<span class="lineNum">   46</span>              :  * in supporting documentation.  Silicon Graphics makes no </span>
<span class="lineNum">   47</span>              :  * representations about the suitability of this software for any </span>
<span class="lineNum">   48</span>              :  * purpose.  It is provided &quot;as is&quot; without express or implied warranty. </span>
<span class="lineNum">   49</span>              :  *&#047; </span>
<span class="lineNum">   50</span>              :  </span>
<span class="lineNum">   51</span>              : &#047;** @file bits&#047;stl_map.h </span>
<span class="lineNum">   52</span>              :  *  This is an internal header file, included by other library headers. </span>
<span class="lineNum">   53</span>              :  *  Do not attempt to use it directly. @headername{map} </span>
<span class="lineNum">   54</span>              :  *&#047; </span>
<span class="lineNum">   55</span>              :  </span>
<span class="lineNum">   56</span>              : #ifndef _STL_MAP_H </span>
<span class="lineNum">   57</span>              : #define _STL_MAP_H 1 </span>
<span class="lineNum">   58</span>              :  </span>
<span class="lineNum">   59</span>              : #include &lt;bits&#047;functexcept.h&gt; </span>
<span class="lineNum">   60</span>              : #include &lt;bits&#047;concept_check.h&gt; </span>
<span class="lineNum">   61</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">   62</span>              : #include &lt;initializer_list&gt; </span>
<span class="lineNum">   63</span>              : #include &lt;tuple&gt; </span>
<span class="lineNum">   64</span>              : #endif </span>
<span class="lineNum">   65</span>              :  </span>
<span class="lineNum">   66</span>              : namespace std _GLIBCXX_VISIBILITY(default) </span>
<span class="lineNum">   67</span>              : { </span>
<span class="lineNum">   68</span>              : _GLIBCXX_BEGIN_NAMESPACE_CONTAINER </span>
<span class="lineNum">   69</span>              :  </span>
<span class="lineNum">   70</span>              :   &#047;** </span>
<span class="lineNum">   71</span>              :    *  @brief A standard container made up of (key,value) pairs, which can be </span>
<span class="lineNum">   72</span>              :    *  retrieved based on a key, in logarithmic time. </span>
<span class="lineNum">   73</span>              :    * </span>
<span class="lineNum">   74</span>              :    *  @ingroup associative_containers </span>
<span class="lineNum">   75</span>              :    * </span>
<span class="lineNum">   76</span>              :    *  @tparam _Key  Type of key objects. </span>
<span class="lineNum">   77</span>              :    *  @tparam  _Tp  Type of mapped objects. </span>
<span class="lineNum">   78</span>              :    *  @tparam _Compare  Comparison function object type, defaults to less&lt;_Key&gt;. </span>
<span class="lineNum">   79</span>              :    *  @tparam _Alloc  Allocator type, defaults to  </span>
<span class="lineNum">   80</span>              :    *                  allocator&lt;pair&lt;const _Key, _Tp&gt;. </span>
<span class="lineNum">   81</span>              :    * </span>
<span class="lineNum">   82</span>              :    *  Meets the requirements of a &lt;a href=&quot;tables.html#65&quot;&gt;container&lt;&#047;a&gt;, a </span>
<span class="lineNum">   83</span>              :    *  &lt;a href=&quot;tables.html#66&quot;&gt;reversible container&lt;&#047;a&gt;, and an </span>
<span class="lineNum">   84</span>              :    *  &lt;a href=&quot;tables.html#69&quot;&gt;associative container&lt;&#047;a&gt; (using unique keys). </span>
<span class="lineNum">   85</span>              :    *  For a @c map&lt;Key,T&gt; the key_type is Key, the mapped_type is T, and the </span>
<span class="lineNum">   86</span>              :    *  value_type is std::pair&lt;const Key,T&gt;. </span>
<span class="lineNum">   87</span>              :    * </span>
<span class="lineNum">   88</span>              :    *  Maps support bidirectional iterators. </span>
<span class="lineNum">   89</span>              :    * </span>
<span class="lineNum">   90</span>              :    *  The private tree data is declared exactly the same way for map and </span>
<span class="lineNum">   91</span>              :    *  multimap; the distinction is made entirely in how the tree functions are </span>
<span class="lineNum">   92</span>              :    *  called (*_unique versus *_equal, same as the standard). </span>
<span class="lineNum">   93</span>              :   *&#047; </span>
<span class="lineNum">   94</span>              :   template &lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, </span>
<span class="lineNum">   95</span>              :             typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt; &gt; </span>
<span class="lineNum">   96</span><span class="linePartCov">      2  /   6:     class map </span>
<span class="lineNum">   97</span>              :     { </span>
<span class="lineNum">   98</span>              :     public: </span>
<span class="lineNum">   99</span>              :       typedef _Key                                          key_type; </span>
<span class="lineNum">  100</span>              :       typedef _Tp                                           mapped_type; </span>
<span class="lineNum">  101</span>              :       typedef std::pair&lt;const _Key, _Tp&gt;                    value_type; </span>
<span class="lineNum">  102</span>              :       typedef _Compare                                      key_compare; </span>
<span class="lineNum">  103</span>              :       typedef _Alloc                                        allocator_type; </span>
<span class="lineNum">  104</span>              :  </span>
<span class="lineNum">  105</span>              :     private: </span>
<span class="lineNum">  106</span>              :       &#047;&#047; concept requirements </span>
<span class="lineNum">  107</span>              :       typedef typename _Alloc::value_type                   _Alloc_value_type; </span>
<span class="lineNum">  108</span>              :       __glibcxx_class_requires(_Tp, _SGIAssignableConcept) </span>
<span class="lineNum">  109</span>              :       __glibcxx_class_requires4(_Compare, bool, _Key, _Key, </span>
<span class="lineNum">  110</span>              : 				_BinaryFunctionConcept) </span>
<span class="lineNum">  111</span>              :       __glibcxx_class_requires2(value_type, _Alloc_value_type, _SameTypeConcept) </span>
<span class="lineNum">  112</span>              :  </span>
<span class="lineNum">  113</span>              :     public: </span>
<span class="lineNum">  114</span>              :       class value_compare </span>
<span class="lineNum">  115</span>              :       : public std::binary_function&lt;value_type, value_type, bool&gt; </span>
<span class="lineNum">  116</span>              :       { </span>
<span class="lineNum">  117</span>              : 	friend class map&lt;_Key, _Tp, _Compare, _Alloc&gt;; </span>
<span class="lineNum">  118</span>              :       protected: </span>
<span class="lineNum">  119</span>              : 	_Compare comp; </span>
<span class="lineNum">  120</span>              :  </span>
<span class="lineNum">  121</span>              : 	value_compare(_Compare __c) </span>
<span class="lineNum">  122</span>              : 	: comp(__c) { } </span>
<span class="lineNum">  123</span>              :  </span>
<span class="lineNum">  124</span>              :       public: </span>
<span class="lineNum">  125</span>              : 	bool operator()(const value_type&amp; __x, const value_type&amp; __y) const </span>
<span class="lineNum">  126</span>              : 	{ return comp(__x.first, __y.first); } </span>
<span class="lineNum">  127</span>              :       }; </span>
<span class="lineNum">  128</span>              :  </span>
<span class="lineNum">  129</span>              :     private: </span>
<span class="lineNum">  130</span>              :       &#047;&#047;&#047; This turns a red-black tree into a [multi]map.  </span>
<span class="lineNum">  131</span>              :       typedef typename _Alloc::template rebind&lt;value_type&gt;::other  </span>
<span class="lineNum">  132</span>              :         _Pair_alloc_type; </span>
<span class="lineNum">  133</span>              :  </span>
<span class="lineNum">  134</span>              :       typedef _Rb_tree&lt;key_type, value_type, _Select1st&lt;value_type&gt;, </span>
<span class="lineNum">  135</span>              : 		       key_compare, _Pair_alloc_type&gt; _Rep_type; </span>
<span class="lineNum">  136</span>              :  </span>
<span class="lineNum">  137</span>              :       &#047;&#047;&#047; The actual tree structure. </span>
<span class="lineNum">  138</span>              :       _Rep_type _M_t; </span>
<span class="lineNum">  139</span>              :  </span>
<span class="lineNum">  140</span>              :     public: </span>
<span class="lineNum">  141</span>              :       &#047;&#047; many of these are specified differently in ISO, but the following are </span>
<span class="lineNum">  142</span>              :       &#047;&#047; &quot;functionally equivalent&quot; </span>
<span class="lineNum">  143</span>              :       typedef typename _Pair_alloc_type::pointer         pointer; </span>
<span class="lineNum">  144</span>              :       typedef typename _Pair_alloc_type::const_pointer   const_pointer; </span>
<span class="lineNum">  145</span>              :       typedef typename _Pair_alloc_type::reference       reference; </span>
<span class="lineNum">  146</span>              :       typedef typename _Pair_alloc_type::const_reference const_reference; </span>
<span class="lineNum">  147</span>              :       typedef typename _Rep_type::iterator               iterator; </span>
<span class="lineNum">  148</span>              :       typedef typename _Rep_type::const_iterator         const_iterator; </span>
<span class="lineNum">  149</span>              :       typedef typename _Rep_type::size_type              size_type; </span>
<span class="lineNum">  150</span>              :       typedef typename _Rep_type::difference_type        difference_type; </span>
<span class="lineNum">  151</span>              :       typedef typename _Rep_type::reverse_iterator       reverse_iterator; </span>
<span class="lineNum">  152</span>              :       typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator; </span>
<span class="lineNum">  153</span>              :  </span>
<span class="lineNum">  154</span>              :       &#047;&#047; [23.3.1.1] construct&#047;copy&#047;destroy </span>
<span class="lineNum">  155</span>              :       &#047;&#047; (get_allocator() is normally listed in this section, but seems to have </span>
<span class="lineNum">  156</span>              :       &#047;&#047; been accidentally omitted in the printed standard) </span>
<span class="lineNum">  157</span>              :       &#047;** </span>
<span class="lineNum">  158</span>              :        *  @brief  Default constructor creates no elements. </span>
<span class="lineNum">  159</span>              :        *&#047; </span>
<span class="lineNum">  160</span><span class="lineCov">      2  /   2:       map() </span>
<span class="lineNum">  161</span><span class="linePartCov">      2  /   4:       : _M_t() { } </span>
<span class="lineNum">  162</span>              :  </span>
<span class="lineNum">  163</span>              :       &#047;** </span>
<span class="lineNum">  164</span>              :        *  @brief  Creates a %map with no elements. </span>
<span class="lineNum">  165</span>              :        *  @param  __comp  A comparison object. </span>
<span class="lineNum">  166</span>              :        *  @param  __a  An allocator object. </span>
<span class="lineNum">  167</span>              :        *&#047; </span>
<span class="lineNum">  168</span>              :       explicit </span>
<span class="lineNum">  169</span>              :       map(const _Compare&amp; __comp, </span>
<span class="lineNum">  170</span>              : 	  const allocator_type&amp; __a = allocator_type()) </span>
<span class="lineNum">  171</span>              :       : _M_t(__comp, _Pair_alloc_type(__a)) { } </span>
<span class="lineNum">  172</span>              :  </span>
<span class="lineNum">  173</span>              :       &#047;** </span>
<span class="lineNum">  174</span>              :        *  @brief  %Map copy constructor. </span>
<span class="lineNum">  175</span>              :        *  @param  __x  A %map of identical element and allocator types. </span>
<span class="lineNum">  176</span>              :        * </span>
<span class="lineNum">  177</span>              :        *  The newly-created %map uses a copy of the allocation object </span>
<span class="lineNum">  178</span>              :        *  used by @a __x. </span>
<span class="lineNum">  179</span>              :        *&#047; </span>
<span class="lineNum">  180</span>              :       map(const map&amp; __x) </span>
<span class="lineNum">  181</span>              :       : _M_t(__x._M_t) { } </span>
<span class="lineNum">  182</span>              :  </span>
<span class="lineNum">  183</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  184</span>              :       &#047;** </span>
<span class="lineNum">  185</span>              :        *  @brief  %Map move constructor. </span>
<span class="lineNum">  186</span>              :        *  @param  __x  A %map of identical element and allocator types. </span>
<span class="lineNum">  187</span>              :        * </span>
<span class="lineNum">  188</span>              :        *  The newly-created %map contains the exact contents of @a __x. </span>
<span class="lineNum">  189</span>              :        *  The contents of @a __x are a valid, but unspecified %map. </span>
<span class="lineNum">  190</span>              :        *&#047; </span>
<span class="lineNum">  191</span>              :       map(map&amp;&amp; __x) </span>
<span class="lineNum">  192</span>              :       noexcept(is_nothrow_copy_constructible&lt;_Compare&gt;::value) </span>
<span class="lineNum">  193</span>              :       : _M_t(std::move(__x._M_t)) { } </span>
<span class="lineNum">  194</span>              :  </span>
<span class="lineNum">  195</span>              :       &#047;** </span>
<span class="lineNum">  196</span>              :        *  @brief  Builds a %map from an initializer_list. </span>
<span class="lineNum">  197</span>              :        *  @param  __l  An initializer_list. </span>
<span class="lineNum">  198</span>              :        *  @param  __comp  A comparison object. </span>
<span class="lineNum">  199</span>              :        *  @param  __a  An allocator object. </span>
<span class="lineNum">  200</span>              :        * </span>
<span class="lineNum">  201</span>              :        *  Create a %map consisting of copies of the elements in the </span>
<span class="lineNum">  202</span>              :        *  initializer_list @a __l. </span>
<span class="lineNum">  203</span>              :        *  This is linear in N if the range is already sorted, and NlogN </span>
<span class="lineNum">  204</span>              :        *  otherwise (where N is @a __l.size()). </span>
<span class="lineNum">  205</span>              :        *&#047; </span>
<span class="lineNum">  206</span>              :       map(initializer_list&lt;value_type&gt; __l, </span>
<span class="lineNum">  207</span>              : 	  const _Compare&amp; __comp = _Compare(), </span>
<span class="lineNum">  208</span>              : 	  const allocator_type&amp; __a = allocator_type()) </span>
<span class="lineNum">  209</span>              :       : _M_t(__comp, _Pair_alloc_type(__a)) </span>
<span class="lineNum">  210</span>              :       { _M_t._M_insert_unique(__l.begin(), __l.end()); } </span>
<span class="lineNum">  211</span>              : #endif </span>
<span class="lineNum">  212</span>              :  </span>
<span class="lineNum">  213</span>              :       &#047;** </span>
<span class="lineNum">  214</span>              :        *  @brief  Builds a %map from a range. </span>
<span class="lineNum">  215</span>              :        *  @param  __first  An input iterator. </span>
<span class="lineNum">  216</span>              :        *  @param  __last  An input iterator. </span>
<span class="lineNum">  217</span>              :        * </span>
<span class="lineNum">  218</span>              :        *  Create a %map consisting of copies of the elements from </span>
<span class="lineNum">  219</span>              :        *  [__first,__last).  This is linear in N if the range is </span>
<span class="lineNum">  220</span>              :        *  already sorted, and NlogN otherwise (where N is </span>
<span class="lineNum">  221</span>              :        *  distance(__first,__last)). </span>
<span class="lineNum">  222</span>              :        *&#047; </span>
<span class="lineNum">  223</span>              :       template&lt;typename _InputIterator&gt; </span>
<span class="lineNum">  224</span>              :         map(_InputIterator __first, _InputIterator __last) </span>
<span class="lineNum">  225</span>              : 	: _M_t() </span>
<span class="lineNum">  226</span>              :         { _M_t._M_insert_unique(__first, __last); } </span>
<span class="lineNum">  227</span>              :  </span>
<span class="lineNum">  228</span>              :       &#047;** </span>
<span class="lineNum">  229</span>              :        *  @brief  Builds a %map from a range. </span>
<span class="lineNum">  230</span>              :        *  @param  __first  An input iterator. </span>
<span class="lineNum">  231</span>              :        *  @param  __last  An input iterator. </span>
<span class="lineNum">  232</span>              :        *  @param  __comp  A comparison functor. </span>
<span class="lineNum">  233</span>              :        *  @param  __a  An allocator object. </span>
<span class="lineNum">  234</span>              :        * </span>
<span class="lineNum">  235</span>              :        *  Create a %map consisting of copies of the elements from </span>
<span class="lineNum">  236</span>              :        *  [__first,__last).  This is linear in N if the range is </span>
<span class="lineNum">  237</span>              :        *  already sorted, and NlogN otherwise (where N is </span>
<span class="lineNum">  238</span>              :        *  distance(__first,__last)). </span>
<span class="lineNum">  239</span>              :        *&#047; </span>
<span class="lineNum">  240</span>              :       template&lt;typename _InputIterator&gt; </span>
<span class="lineNum">  241</span>              :         map(_InputIterator __first, _InputIterator __last, </span>
<span class="lineNum">  242</span>              : 	    const _Compare&amp; __comp, </span>
<span class="lineNum">  243</span>              : 	    const allocator_type&amp; __a = allocator_type()) </span>
<span class="lineNum">  244</span>              : 	: _M_t(__comp, _Pair_alloc_type(__a)) </span>
<span class="lineNum">  245</span>              :         { _M_t._M_insert_unique(__first, __last); } </span>
<span class="lineNum">  246</span>              :  </span>
<span class="lineNum">  247</span>              :       &#047;&#047; FIXME There is no dtor declared, but we should have something </span>
<span class="lineNum">  248</span>              :       &#047;&#047; generated by Doxygen.  I don&#039;t know what tags to add to this </span>
<span class="lineNum">  249</span>              :       &#047;&#047; paragraph to make that happen: </span>
<span class="lineNum">  250</span>              :       &#047;** </span>
<span class="lineNum">  251</span>              :        *  The dtor only erases the elements, and note that if the elements </span>
<span class="lineNum">  252</span>              :        *  themselves are pointers, the pointed-to memory is not touched in any </span>
<span class="lineNum">  253</span>              :        *  way.  Managing the pointer is the user&#039;s responsibility. </span>
<span class="lineNum">  254</span>              :        *&#047; </span>
<span class="lineNum">  255</span>              :  </span>
<span class="lineNum">  256</span>              :       &#047;** </span>
<span class="lineNum">  257</span>              :        *  @brief  %Map assignment operator. </span>
<span class="lineNum">  258</span>              :        *  @param  __x  A %map of identical element and allocator types. </span>
<span class="lineNum">  259</span>              :        * </span>
<span class="lineNum">  260</span>              :        *  All the elements of @a __x are copied, but unlike the copy </span>
<span class="lineNum">  261</span>              :        *  constructor, the allocator object is not copied. </span>
<span class="lineNum">  262</span>              :        *&#047; </span>
<span class="lineNum">  263</span>              :       map&amp; </span>
<span class="lineNum">  264</span>              :       operator=(const map&amp; __x) </span>
<span class="lineNum">  265</span>              :       { </span>
<span class="lineNum">  266</span>              : 	_M_t = __x._M_t; </span>
<span class="lineNum">  267</span>              : 	return *this; </span>
<span class="lineNum">  268</span>              :       } </span>
<span class="lineNum">  269</span>              :  </span>
<span class="lineNum">  270</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  271</span>              :       &#047;** </span>
<span class="lineNum">  272</span>              :        *  @brief  %Map move assignment operator. </span>
<span class="lineNum">  273</span>              :        *  @param  __x  A %map of identical element and allocator types. </span>
<span class="lineNum">  274</span>              :        * </span>
<span class="lineNum">  275</span>              :        *  The contents of @a __x are moved into this map (without copying). </span>
<span class="lineNum">  276</span>              :        *  @a __x is a valid, but unspecified %map. </span>
<span class="lineNum">  277</span>              :        *&#047; </span>
<span class="lineNum">  278</span>              :       map&amp; </span>
<span class="lineNum">  279</span><span class="lineNoCov">      0  /   1:       operator=(map&amp;&amp; __x) </span>
<span class="lineNum">  280</span>              :       { </span>
<span class="lineNum">  281</span>              : 	&#047;&#047; NB: DR 1204. </span>
<span class="lineNum">  282</span>              : 	&#047;&#047; NB: DR 675. </span>
<span class="lineNum">  283</span><span class="lineNoCov">      0  /   1: 	this-&gt;clear(); </span>
<span class="lineNum">  284</span><span class="lineNoCov">      0  /   1: 	this-&gt;swap(__x); </span>
<span class="lineNum">  285</span><span class="lineNoCov">      0  /   1: 	return *this; </span>
<span class="lineNum">  286</span><span class="lineNoCov">      0  /   2:       } </span>
<span class="lineNum">  287</span>              :  </span>
<span class="lineNum">  288</span>              :       &#047;** </span>
<span class="lineNum">  289</span>              :        *  @brief  %Map list assignment operator. </span>
<span class="lineNum">  290</span>              :        *  @param  __l  An initializer_list. </span>
<span class="lineNum">  291</span>              :        * </span>
<span class="lineNum">  292</span>              :        *  This function fills a %map with copies of the elements in the </span>
<span class="lineNum">  293</span>              :        *  initializer list @a __l. </span>
<span class="lineNum">  294</span>              :        * </span>
<span class="lineNum">  295</span>              :        *  Note that the assignment completely changes the %map and </span>
<span class="lineNum">  296</span>              :        *  that the resulting %map&#039;s size is the same as the number </span>
<span class="lineNum">  297</span>              :        *  of elements assigned.  Old data may be lost. </span>
<span class="lineNum">  298</span>              :        *&#047; </span>
<span class="lineNum">  299</span>              :       map&amp; </span>
<span class="lineNum">  300</span>              :       operator=(initializer_list&lt;value_type&gt; __l) </span>
<span class="lineNum">  301</span>              :       { </span>
<span class="lineNum">  302</span>              : 	this-&gt;clear(); </span>
<span class="lineNum">  303</span>              : 	this-&gt;insert(__l.begin(), __l.end()); </span>
<span class="lineNum">  304</span>              : 	return *this; </span>
<span class="lineNum">  305</span>              :       } </span>
<span class="lineNum">  306</span>              : #endif </span>
<span class="lineNum">  307</span>              :  </span>
<span class="lineNum">  308</span>              :       &#047;&#047;&#047; Get a copy of the memory allocation object. </span>
<span class="lineNum">  309</span>              :       allocator_type </span>
<span class="lineNum">  310</span>              :       get_allocator() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  311</span>              :       { return allocator_type(_M_t.get_allocator()); } </span>
<span class="lineNum">  312</span>              :  </span>
<span class="lineNum">  313</span>              :       &#047;&#047; iterators </span>
<span class="lineNum">  314</span>              :       &#047;** </span>
<span class="lineNum">  315</span>              :        *  Returns a read&#047;write iterator that points to the first pair in the </span>
<span class="lineNum">  316</span>              :        *  %map. </span>
<span class="lineNum">  317</span>              :        *  Iteration is done in ascending order according to the keys. </span>
<span class="lineNum">  318</span>              :        *&#047; </span>
<span class="lineNum">  319</span>              :       iterator </span>
<span class="lineNum">  320</span><span class="linePartCov">      1  /   2:       begin() _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  321</span><span class="linePartCov">      1  /   4:       { return _M_t.begin(); } </span>
<span class="lineNum">  322</span>              :  </span>
<span class="lineNum">  323</span>              :       &#047;** </span>
<span class="lineNum">  324</span>              :        *  Returns a read-only (constant) iterator that points to the first pair </span>
<span class="lineNum">  325</span>              :        *  in the %map.  Iteration is done in ascending order according to the </span>
<span class="lineNum">  326</span>              :        *  keys. </span>
<span class="lineNum">  327</span>              :        *&#047; </span>
<span class="lineNum">  328</span>              :       const_iterator </span>
<span class="lineNum">  329</span>              :       begin() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  330</span>              :       { return _M_t.begin(); } </span>
<span class="lineNum">  331</span>              :  </span>
<span class="lineNum">  332</span>              :       &#047;** </span>
<span class="lineNum">  333</span>              :        *  Returns a read&#047;write iterator that points one past the last </span>
<span class="lineNum">  334</span>              :        *  pair in the %map.  Iteration is done in ascending order </span>
<span class="lineNum">  335</span>              :        *  according to the keys. </span>
<span class="lineNum">  336</span>              :        *&#047; </span>
<span class="lineNum">  337</span>              :       iterator </span>
<span class="lineNum">  338</span><span class="linePartCov">      1  /   2:       end() _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  339</span><span class="linePartCov">      1  /   4:       { return _M_t.end(); } </span>
<span class="lineNum">  340</span>              :  </span>
<span class="lineNum">  341</span>              :       &#047;** </span>
<span class="lineNum">  342</span>              :        *  Returns a read-only (constant) iterator that points one past the last </span>
<span class="lineNum">  343</span>              :        *  pair in the %map.  Iteration is done in ascending order according to </span>
<span class="lineNum">  344</span>              :        *  the keys. </span>
<span class="lineNum">  345</span>              :        *&#047; </span>
<span class="lineNum">  346</span>              :       const_iterator </span>
<span class="lineNum">  347</span>              :       end() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  348</span>              :       { return _M_t.end(); } </span>
<span class="lineNum">  349</span>              :  </span>
<span class="lineNum">  350</span>              :       &#047;** </span>
<span class="lineNum">  351</span>              :        *  Returns a read&#047;write reverse iterator that points to the last pair in </span>
<span class="lineNum">  352</span>              :        *  the %map.  Iteration is done in descending order according to the </span>
<span class="lineNum">  353</span>              :        *  keys. </span>
<span class="lineNum">  354</span>              :        *&#047; </span>
<span class="lineNum">  355</span>              :       reverse_iterator </span>
<span class="lineNum">  356</span>              :       rbegin() _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  357</span>              :       { return _M_t.rbegin(); } </span>
<span class="lineNum">  358</span>              :  </span>
<span class="lineNum">  359</span>              :       &#047;** </span>
<span class="lineNum">  360</span>              :        *  Returns a read-only (constant) reverse iterator that points to the </span>
<span class="lineNum">  361</span>              :        *  last pair in the %map.  Iteration is done in descending order </span>
<span class="lineNum">  362</span>              :        *  according to the keys. </span>
<span class="lineNum">  363</span>              :        *&#047; </span>
<span class="lineNum">  364</span>              :       const_reverse_iterator </span>
<span class="lineNum">  365</span>              :       rbegin() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  366</span>              :       { return _M_t.rbegin(); } </span>
<span class="lineNum">  367</span>              :  </span>
<span class="lineNum">  368</span>              :       &#047;** </span>
<span class="lineNum">  369</span>              :        *  Returns a read&#047;write reverse iterator that points to one before the </span>
<span class="lineNum">  370</span>              :        *  first pair in the %map.  Iteration is done in descending order </span>
<span class="lineNum">  371</span>              :        *  according to the keys. </span>
<span class="lineNum">  372</span>              :        *&#047; </span>
<span class="lineNum">  373</span>              :       reverse_iterator </span>
<span class="lineNum">  374</span>              :       rend() _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  375</span>              :       { return _M_t.rend(); } </span>
<span class="lineNum">  376</span>              :  </span>
<span class="lineNum">  377</span>              :       &#047;** </span>
<span class="lineNum">  378</span>              :        *  Returns a read-only (constant) reverse iterator that points to one </span>
<span class="lineNum">  379</span>              :        *  before the first pair in the %map.  Iteration is done in descending </span>
<span class="lineNum">  380</span>              :        *  order according to the keys. </span>
<span class="lineNum">  381</span>              :        *&#047; </span>
<span class="lineNum">  382</span>              :       const_reverse_iterator </span>
<span class="lineNum">  383</span>              :       rend() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  384</span>              :       { return _M_t.rend(); } </span>
<span class="lineNum">  385</span>              :  </span>
<span class="lineNum">  386</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  387</span>              :       &#047;** </span>
<span class="lineNum">  388</span>              :        *  Returns a read-only (constant) iterator that points to the first pair </span>
<span class="lineNum">  389</span>              :        *  in the %map.  Iteration is done in ascending order according to the </span>
<span class="lineNum">  390</span>              :        *  keys. </span>
<span class="lineNum">  391</span>              :        *&#047; </span>
<span class="lineNum">  392</span>              :       const_iterator </span>
<span class="lineNum">  393</span>              :       cbegin() const noexcept </span>
<span class="lineNum">  394</span>              :       { return _M_t.begin(); } </span>
<span class="lineNum">  395</span>              :  </span>
<span class="lineNum">  396</span>              :       &#047;** </span>
<span class="lineNum">  397</span>              :        *  Returns a read-only (constant) iterator that points one past the last </span>
<span class="lineNum">  398</span>              :        *  pair in the %map.  Iteration is done in ascending order according to </span>
<span class="lineNum">  399</span>              :        *  the keys. </span>
<span class="lineNum">  400</span>              :        *&#047; </span>
<span class="lineNum">  401</span>              :       const_iterator </span>
<span class="lineNum">  402</span>              :       cend() const noexcept </span>
<span class="lineNum">  403</span>              :       { return _M_t.end(); } </span>
<span class="lineNum">  404</span>              :  </span>
<span class="lineNum">  405</span>              :       &#047;** </span>
<span class="lineNum">  406</span>              :        *  Returns a read-only (constant) reverse iterator that points to the </span>
<span class="lineNum">  407</span>              :        *  last pair in the %map.  Iteration is done in descending order </span>
<span class="lineNum">  408</span>              :        *  according to the keys. </span>
<span class="lineNum">  409</span>              :        *&#047; </span>
<span class="lineNum">  410</span>              :       const_reverse_iterator </span>
<span class="lineNum">  411</span>              :       crbegin() const noexcept </span>
<span class="lineNum">  412</span>              :       { return _M_t.rbegin(); } </span>
<span class="lineNum">  413</span>              :  </span>
<span class="lineNum">  414</span>              :       &#047;** </span>
<span class="lineNum">  415</span>              :        *  Returns a read-only (constant) reverse iterator that points to one </span>
<span class="lineNum">  416</span>              :        *  before the first pair in the %map.  Iteration is done in descending </span>
<span class="lineNum">  417</span>              :        *  order according to the keys. </span>
<span class="lineNum">  418</span>              :        *&#047; </span>
<span class="lineNum">  419</span>              :       const_reverse_iterator </span>
<span class="lineNum">  420</span>              :       crend() const noexcept </span>
<span class="lineNum">  421</span>              :       { return _M_t.rend(); } </span>
<span class="lineNum">  422</span>              : #endif </span>
<span class="lineNum">  423</span>              :  </span>
<span class="lineNum">  424</span>              :       &#047;&#047; capacity </span>
<span class="lineNum">  425</span>              :       &#047;** Returns true if the %map is empty.  (Thus begin() would equal </span>
<span class="lineNum">  426</span>              :        *  end().) </span>
<span class="lineNum">  427</span>              :       *&#047; </span>
<span class="lineNum">  428</span>              :       bool </span>
<span class="lineNum">  429</span>              :       empty() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  430</span>              :       { return _M_t.empty(); } </span>
<span class="lineNum">  431</span>              :  </span>
<span class="lineNum">  432</span>              :       &#047;** Returns the size of the %map.  *&#047; </span>
<span class="lineNum">  433</span>              :       size_type </span>
<span class="lineNum">  434</span><span class="lineCov">      1  /   1:       size() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  435</span><span class="linePartCov">      1  /   2:       { return _M_t.size(); } </span>
<span class="lineNum">  436</span>              :  </span>
<span class="lineNum">  437</span>              :       &#047;** Returns the maximum size of the %map.  *&#047; </span>
<span class="lineNum">  438</span>              :       size_type </span>
<span class="lineNum">  439</span>              :       max_size() const _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  440</span>              :       { return _M_t.max_size(); } </span>
<span class="lineNum">  441</span>              :  </span>
<span class="lineNum">  442</span>              :       &#047;&#047; [23.3.1.2] element access </span>
<span class="lineNum">  443</span>              :       &#047;** </span>
<span class="lineNum">  444</span>              :        *  @brief  Subscript ( @c [] ) access to %map data. </span>
<span class="lineNum">  445</span>              :        *  @param  __k  The key for which data should be retrieved. </span>
<span class="lineNum">  446</span>              :        *  @return  A reference to the data of the (key,data) %pair. </span>
<span class="lineNum">  447</span>              :        * </span>
<span class="lineNum">  448</span>              :        *  Allows for easy lookup with the subscript ( @c [] ) </span>
<span class="lineNum">  449</span>              :        *  operator.  Returns data associated with the key specified in </span>
<span class="lineNum">  450</span>              :        *  subscript.  If the key does not exist, a pair with that key </span>
<span class="lineNum">  451</span>              :        *  is created using default values, which is then returned. </span>
<span class="lineNum">  452</span>              :        * </span>
<span class="lineNum">  453</span>              :        *  Lookup requires logarithmic time. </span>
<span class="lineNum">  454</span>              :        *&#047; </span>
<span class="lineNum">  455</span>              :       mapped_type&amp; </span>
<span class="lineNum">  456</span><span class="linePartCov">      1  /   2:       operator[](const key_type&amp; __k) </span>
<span class="lineNum">  457</span>              :       { </span>
<span class="lineNum">  458</span>              : 	&#047;&#047; concept requirements </span>
<span class="lineNum">  459</span>              : 	__glibcxx_function_requires(_DefaultConstructibleConcept&lt;mapped_type&gt;) </span>
<span class="lineNum">  460</span>              :  </span>
<span class="lineNum">  461</span><span class="linePartCov">      1  /   2: 	iterator __i = lower_bound(__k); </span>
<span class="lineNum">  462</span>              : 	&#047;&#047; __i-&gt;first is greater than or equivalent to __k. </span>
<span class="lineNum">  463</span><span class="linePartCov">      1  /   4: 	if (__i == end() || key_comp()(__k, (*__i).first)) </span>
<span class="lineNum">  464</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  465</span><span class="linePartCov">      1  /   2: 	  __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct, </span>
<span class="lineNum">  466</span>              : 					    std::tuple&lt;const key_type&amp;&gt;(__k), </span>
<span class="lineNum">  467</span>              : 					    std::tuple&lt;&gt;()); </span>
<span class="lineNum">  468</span>              : #else </span>
<span class="lineNum">  469</span>              :           __i = insert(__i, value_type(__k, mapped_type())); </span>
<span class="lineNum">  470</span>              : #endif </span>
<span class="lineNum">  471</span><span class="linePartCov">      1  /   2: 	return (*__i).second; </span>
<span class="lineNum">  472</span><span class="linePartCov">      1  /   4:       } </span>
<span class="lineNum">  473</span>              :  </span>
<span class="lineNum">  474</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  475</span>              :       mapped_type&amp; </span>
<span class="lineNum">  476</span><span class="lineNoCov">      0  /   1:       operator[](key_type&amp;&amp; __k) </span>
<span class="lineNum">  477</span>              :       { </span>
<span class="lineNum">  478</span>              : 	&#047;&#047; concept requirements </span>
<span class="lineNum">  479</span>              : 	__glibcxx_function_requires(_DefaultConstructibleConcept&lt;mapped_type&gt;) </span>
<span class="lineNum">  480</span>              :  </span>
<span class="lineNum">  481</span><span class="lineNoCov">      0  /   1: 	iterator __i = lower_bound(__k); </span>
<span class="lineNum">  482</span>              : 	&#047;&#047; __i-&gt;first is greater than or equivalent to __k. </span>
<span class="lineNum">  483</span><span class="lineNoCov">      0  /   2: 	if (__i == end() || key_comp()(__k, (*__i).first)) </span>
<span class="lineNum">  484</span><span class="lineNoCov">      0  /   1: 	  __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct, </span>
<span class="lineNum">  485</span><span class="lineNoCov">      0  /   1: 					std::forward_as_tuple(std::move(__k)), </span>
<span class="lineNum">  486</span>              : 					std::tuple&lt;&gt;()); </span>
<span class="lineNum">  487</span><span class="lineNoCov">      0  /   1: 	return (*__i).second; </span>
<span class="lineNum">  488</span><span class="lineNoCov">      0  /   2:       } </span>
<span class="lineNum">  489</span>              : #endif </span>
<span class="lineNum">  490</span>              :  </span>
<span class="lineNum">  491</span>              :       &#047;&#047; _GLIBCXX_RESOLVE_LIB_DEFECTS </span>
<span class="lineNum">  492</span>              :       &#047;&#047; DR 464. Suggestion for new member functions in standard containers. </span>
<span class="lineNum">  493</span>              :       &#047;** </span>
<span class="lineNum">  494</span>              :        *  @brief  Access to %map data. </span>
<span class="lineNum">  495</span>              :        *  @param  __k  The key for which data should be retrieved. </span>
<span class="lineNum">  496</span>              :        *  @return  A reference to the data whose key is equivalent to @a __k, if </span>
<span class="lineNum">  497</span>              :        *           such a data is present in the %map. </span>
<span class="lineNum">  498</span>              :        *  @throw  std::out_of_range  If no such data is present. </span>
<span class="lineNum">  499</span>              :        *&#047; </span>
<span class="lineNum">  500</span>              :       mapped_type&amp; </span>
<span class="lineNum">  501</span>              :       at(const key_type&amp; __k) </span>
<span class="lineNum">  502</span>              :       { </span>
<span class="lineNum">  503</span>              : 	iterator __i = lower_bound(__k); </span>
<span class="lineNum">  504</span>              : 	if (__i == end() || key_comp()(__k, (*__i).first)) </span>
<span class="lineNum">  505</span>              : 	  __throw_out_of_range(__N(&quot;map::at&quot;)); </span>
<span class="lineNum">  506</span>              : 	return (*__i).second; </span>
<span class="lineNum">  507</span>              :       } </span>
<span class="lineNum">  508</span>              :  </span>
<span class="lineNum">  509</span>              :       const mapped_type&amp; </span>
<span class="lineNum">  510</span>              :       at(const key_type&amp; __k) const </span>
<span class="lineNum">  511</span>              :       { </span>
<span class="lineNum">  512</span>              : 	const_iterator __i = lower_bound(__k); </span>
<span class="lineNum">  513</span>              : 	if (__i == end() || key_comp()(__k, (*__i).first)) </span>
<span class="lineNum">  514</span>              : 	  __throw_out_of_range(__N(&quot;map::at&quot;)); </span>
<span class="lineNum">  515</span>              : 	return (*__i).second; </span>
<span class="lineNum">  516</span>              :       } </span>
<span class="lineNum">  517</span>              :  </span>
<span class="lineNum">  518</span>              :       &#047;&#047; modifiers </span>
<span class="lineNum">  519</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  520</span>              :       &#047;** </span>
<span class="lineNum">  521</span>              :        *  @brief Attempts to build and insert a std::pair into the %map. </span>
<span class="lineNum">  522</span>              :        * </span>
<span class="lineNum">  523</span>              :        *  @param __args  Arguments used to generate a new pair instance (see </span>
<span class="lineNum">  524</span>              :        *	        std::piecewise_contruct for passing arguments to each </span>
<span class="lineNum">  525</span>              :        *	        part of the pair constructor). </span>
<span class="lineNum">  526</span>              :        * </span>
<span class="lineNum">  527</span>              :        *  @return  A pair, of which the first element is an iterator that points </span>
<span class="lineNum">  528</span>              :        *           to the possibly inserted pair, and the second is a bool that </span>
<span class="lineNum">  529</span>              :        *           is true if the pair was actually inserted. </span>
<span class="lineNum">  530</span>              :        * </span>
<span class="lineNum">  531</span>              :        *  This function attempts to build and insert a (key, value) %pair into </span>
<span class="lineNum">  532</span>              :        *  the %map. </span>
<span class="lineNum">  533</span>              :        *  A %map relies on unique keys and thus a %pair is only inserted if its </span>
<span class="lineNum">  534</span>              :        *  first element (the key) is not already present in the %map. </span>
<span class="lineNum">  535</span>              :        * </span>
<span class="lineNum">  536</span>              :        *  Insertion requires logarithmic time. </span>
<span class="lineNum">  537</span>              :        *&#047; </span>
<span class="lineNum">  538</span>              :       template&lt;typename... _Args&gt; </span>
<span class="lineNum">  539</span>              : 	std::pair&lt;iterator, bool&gt; </span>
<span class="lineNum">  540</span>              : 	emplace(_Args&amp;&amp;... __args) </span>
<span class="lineNum">  541</span>              : 	{ return _M_t._M_emplace_unique(std::forward&lt;_Args&gt;(__args)...); } </span>
<span class="lineNum">  542</span>              :  </span>
<span class="lineNum">  543</span>              :       &#047;** </span>
<span class="lineNum">  544</span>              :        *  @brief Attempts to build and insert a std::pair into the %map. </span>
<span class="lineNum">  545</span>              :        * </span>
<span class="lineNum">  546</span>              :        *  @param  __pos  An iterator that serves as a hint as to where the pair </span>
<span class="lineNum">  547</span>              :        *                should be inserted. </span>
<span class="lineNum">  548</span>              :        *  @param  __args  Arguments used to generate a new pair instance (see </span>
<span class="lineNum">  549</span>              :        *	         std::piecewise_contruct for passing arguments to each </span>
<span class="lineNum">  550</span>              :        *	         part of the pair constructor). </span>
<span class="lineNum">  551</span>              :        *  @return An iterator that points to the element with key of the </span>
<span class="lineNum">  552</span>              :        *          std::pair built from @a __args (may or may not be that </span>
<span class="lineNum">  553</span>              :        *          std::pair). </span>
<span class="lineNum">  554</span>              :        * </span>
<span class="lineNum">  555</span>              :        *  This function is not concerned about whether the insertion took place, </span>
<span class="lineNum">  556</span>              :        *  and thus does not return a boolean like the single-argument emplace() </span>
<span class="lineNum">  557</span>              :        *  does. </span>
<span class="lineNum">  558</span>              :        *  Note that the first parameter is only a hint and can potentially </span>
<span class="lineNum">  559</span>              :        *  improve the performance of the insertion process. A bad hint would </span>
<span class="lineNum">  560</span>              :        *  cause no gains in efficiency. </span>
<span class="lineNum">  561</span>              :        * </span>
<span class="lineNum">  562</span>              :        *  See </span>
<span class="lineNum">  563</span>              :        *  http:&#047;&#047;gcc.gnu.org&#047;onlinedocs&#047;libstdc++&#047;manual&#047;bk01pt07ch17.html </span>
<span class="lineNum">  564</span>              :        *  for more on @a hinting. </span>
<span class="lineNum">  565</span>              :        * </span>
<span class="lineNum">  566</span>              :        *  Insertion requires logarithmic time (if the hint is not taken). </span>
<span class="lineNum">  567</span>              :        *&#047; </span>
<span class="lineNum">  568</span>              :       template&lt;typename... _Args&gt; </span>
<span class="lineNum">  569</span>              : 	iterator </span>
<span class="lineNum">  570</span>              : 	emplace_hint(const_iterator __pos, _Args&amp;&amp;... __args) </span>
<span class="lineNum">  571</span>              : 	{ </span>
<span class="lineNum">  572</span>              : 	  return _M_t._M_emplace_hint_unique(__pos, </span>
<span class="lineNum">  573</span>              : 					     std::forward&lt;_Args&gt;(__args)...); </span>
<span class="lineNum">  574</span>              : 	} </span>
<span class="lineNum">  575</span>              : #endif </span>
<span class="lineNum">  576</span>              :  </span>
<span class="lineNum">  577</span>              :       &#047;** </span>
<span class="lineNum">  578</span>              :        *  @brief Attempts to insert a std::pair into the %map. </span>
<span class="lineNum">  579</span>              :  </span>
<span class="lineNum">  580</span>              :        *  @param __x Pair to be inserted (see std::make_pair for easy </span>
<span class="lineNum">  581</span>              :        *	     creation of pairs). </span>
<span class="lineNum">  582</span>              :        * </span>
<span class="lineNum">  583</span>              :        *  @return  A pair, of which the first element is an iterator that  </span>
<span class="lineNum">  584</span>              :        *           points to the possibly inserted pair, and the second is  </span>
<span class="lineNum">  585</span>              :        *           a bool that is true if the pair was actually inserted. </span>
<span class="lineNum">  586</span>              :        * </span>
<span class="lineNum">  587</span>              :        *  This function attempts to insert a (key, value) %pair into the %map. </span>
<span class="lineNum">  588</span>              :        *  A %map relies on unique keys and thus a %pair is only inserted if its </span>
<span class="lineNum">  589</span>              :        *  first element (the key) is not already present in the %map. </span>
<span class="lineNum">  590</span>              :        * </span>
<span class="lineNum">  591</span>              :        *  Insertion requires logarithmic time. </span>
<span class="lineNum">  592</span>              :        *&#047; </span>
<span class="lineNum">  593</span>              :       std::pair&lt;iterator, bool&gt; </span>
<span class="lineNum">  594</span>              :       insert(const value_type&amp; __x) </span>
<span class="lineNum">  595</span>              :       { return _M_t._M_insert_unique(__x); } </span>
<span class="lineNum">  596</span>              :  </span>
<span class="lineNum">  597</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  598</span>              :       template&lt;typename _Pair, typename = typename </span>
<span class="lineNum">  599</span>              : 	       std::enable_if&lt;std::is_constructible&lt;value_type, </span>
<span class="lineNum">  600</span>              : 						    _Pair&amp;&amp;&gt;::value&gt;::type&gt; </span>
<span class="lineNum">  601</span>              :         std::pair&lt;iterator, bool&gt; </span>
<span class="lineNum">  602</span>              :         insert(_Pair&amp;&amp; __x) </span>
<span class="lineNum">  603</span>              :         { return _M_t._M_insert_unique(std::forward&lt;_Pair&gt;(__x)); } </span>
<span class="lineNum">  604</span>              : #endif </span>
<span class="lineNum">  605</span>              :  </span>
<span class="lineNum">  606</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  607</span>              :       &#047;** </span>
<span class="lineNum">  608</span>              :        *  @brief Attempts to insert a list of std::pairs into the %map. </span>
<span class="lineNum">  609</span>              :        *  @param  __list  A std::initializer_list&lt;value_type&gt; of pairs to be </span>
<span class="lineNum">  610</span>              :        *                  inserted. </span>
<span class="lineNum">  611</span>              :        * </span>
<span class="lineNum">  612</span>              :        *  Complexity similar to that of the range constructor. </span>
<span class="lineNum">  613</span>              :        *&#047; </span>
<span class="lineNum">  614</span>              :       void </span>
<span class="lineNum">  615</span>              :       insert(std::initializer_list&lt;value_type&gt; __list) </span>
<span class="lineNum">  616</span>              :       { insert(__list.begin(), __list.end()); } </span>
<span class="lineNum">  617</span>              : #endif </span>
<span class="lineNum">  618</span>              :  </span>
<span class="lineNum">  619</span>              :       &#047;** </span>
<span class="lineNum">  620</span>              :        *  @brief Attempts to insert a std::pair into the %map. </span>
<span class="lineNum">  621</span>              :        *  @param  __position  An iterator that serves as a hint as to where the </span>
<span class="lineNum">  622</span>              :        *                    pair should be inserted. </span>
<span class="lineNum">  623</span>              :        *  @param  __x  Pair to be inserted (see std::make_pair for easy creation </span>
<span class="lineNum">  624</span>              :        *               of pairs). </span>
<span class="lineNum">  625</span>              :        *  @return An iterator that points to the element with key of </span>
<span class="lineNum">  626</span>              :        *           @a __x (may or may not be the %pair passed in). </span>
<span class="lineNum">  627</span>              :        * </span>
<span class="lineNum">  628</span>              :  </span>
<span class="lineNum">  629</span>              :        *  This function is not concerned about whether the insertion </span>
<span class="lineNum">  630</span>              :        *  took place, and thus does not return a boolean like the </span>
<span class="lineNum">  631</span>              :        *  single-argument insert() does.  Note that the first </span>
<span class="lineNum">  632</span>              :        *  parameter is only a hint and can potentially improve the </span>
<span class="lineNum">  633</span>              :        *  performance of the insertion process.  A bad hint would </span>
<span class="lineNum">  634</span>              :        *  cause no gains in efficiency. </span>
<span class="lineNum">  635</span>              :        * </span>
<span class="lineNum">  636</span>              :        *  See </span>
<span class="lineNum">  637</span>              :        *  http:&#047;&#047;gcc.gnu.org&#047;onlinedocs&#047;libstdc++&#047;manual&#047;bk01pt07ch17.html </span>
<span class="lineNum">  638</span>              :        *  for more on @a hinting. </span>
<span class="lineNum">  639</span>              :        * </span>
<span class="lineNum">  640</span>              :        *  Insertion requires logarithmic time (if the hint is not taken). </span>
<span class="lineNum">  641</span>              :        *&#047; </span>
<span class="lineNum">  642</span>              :       iterator </span>
<span class="lineNum">  643</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  644</span>              :       insert(const_iterator __position, const value_type&amp; __x) </span>
<span class="lineNum">  645</span>              : #else </span>
<span class="lineNum">  646</span>              :       insert(iterator __position, const value_type&amp; __x) </span>
<span class="lineNum">  647</span>              : #endif </span>
<span class="lineNum">  648</span>              :       { return _M_t._M_insert_unique_(__position, __x); } </span>
<span class="lineNum">  649</span>              :  </span>
<span class="lineNum">  650</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  651</span>              :       template&lt;typename _Pair, typename = typename </span>
<span class="lineNum">  652</span>              : 	       std::enable_if&lt;std::is_constructible&lt;value_type, </span>
<span class="lineNum">  653</span>              : 						    _Pair&amp;&amp;&gt;::value&gt;::type&gt; </span>
<span class="lineNum">  654</span>              :         iterator </span>
<span class="lineNum">  655</span>              :         insert(const_iterator __position, _Pair&amp;&amp; __x) </span>
<span class="lineNum">  656</span>              :         { return _M_t._M_insert_unique_(__position, </span>
<span class="lineNum">  657</span>              : 					std::forward&lt;_Pair&gt;(__x)); } </span>
<span class="lineNum">  658</span>              : #endif </span>
<span class="lineNum">  659</span>              :  </span>
<span class="lineNum">  660</span>              :       &#047;** </span>
<span class="lineNum">  661</span>              :        *  @brief Template function that attempts to insert a range of elements. </span>
<span class="lineNum">  662</span>              :        *  @param  __first  Iterator pointing to the start of the range to be </span>
<span class="lineNum">  663</span>              :        *                   inserted. </span>
<span class="lineNum">  664</span>              :        *  @param  __last  Iterator pointing to the end of the range. </span>
<span class="lineNum">  665</span>              :        * </span>
<span class="lineNum">  666</span>              :        *  Complexity similar to that of the range constructor. </span>
<span class="lineNum">  667</span>              :        *&#047; </span>
<span class="lineNum">  668</span>              :       template&lt;typename _InputIterator&gt; </span>
<span class="lineNum">  669</span>              :         void </span>
<span class="lineNum">  670</span>              :         insert(_InputIterator __first, _InputIterator __last) </span>
<span class="lineNum">  671</span>              :         { _M_t._M_insert_unique(__first, __last); } </span>
<span class="lineNum">  672</span>              :  </span>
<span class="lineNum">  673</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  674</span>              :       &#047;&#047; _GLIBCXX_RESOLVE_LIB_DEFECTS </span>
<span class="lineNum">  675</span>              :       &#047;&#047; DR 130. Associative erase should return an iterator. </span>
<span class="lineNum">  676</span>              :       &#047;** </span>
<span class="lineNum">  677</span>              :        *  @brief Erases an element from a %map. </span>
<span class="lineNum">  678</span>              :        *  @param  __position  An iterator pointing to the element to be erased. </span>
<span class="lineNum">  679</span>              :        *  @return An iterator pointing to the element immediately following </span>
<span class="lineNum">  680</span>              :        *          @a position prior to the element being erased. If no such  </span>
<span class="lineNum">  681</span>              :        *          element exists, end() is returned. </span>
<span class="lineNum">  682</span>              :        * </span>
<span class="lineNum">  683</span>              :        *  This function erases an element, pointed to by the given </span>
<span class="lineNum">  684</span>              :        *  iterator, from a %map.  Note that this function only erases </span>
<span class="lineNum">  685</span>              :        *  the element, and that if the element is itself a pointer, </span>
<span class="lineNum">  686</span>              :        *  the pointed-to memory is not touched in any way.  Managing </span>
<span class="lineNum">  687</span>              :        *  the pointer is the user&#039;s responsibility. </span>
<span class="lineNum">  688</span>              :        *&#047; </span>
<span class="lineNum">  689</span>              :       iterator </span>
<span class="lineNum">  690</span>              :       erase(const_iterator __position) </span>
<span class="lineNum">  691</span>              :       { return _M_t.erase(__position); } </span>
<span class="lineNum">  692</span>              :  </span>
<span class="lineNum">  693</span>              :       &#047;&#047; LWG 2059 </span>
<span class="lineNum">  694</span>              :       _GLIBCXX_ABI_TAG_CXX11 </span>
<span class="lineNum">  695</span>              :       iterator </span>
<span class="lineNum">  696</span>              :       erase(iterator __position) </span>
<span class="lineNum">  697</span>              :       { return _M_t.erase(__position); } </span>
<span class="lineNum">  698</span>              : #else </span>
<span class="lineNum">  699</span>              :       &#047;** </span>
<span class="lineNum">  700</span>              :        *  @brief Erases an element from a %map. </span>
<span class="lineNum">  701</span>              :        *  @param  __position  An iterator pointing to the element to be erased. </span>
<span class="lineNum">  702</span>              :        * </span>
<span class="lineNum">  703</span>              :        *  This function erases an element, pointed to by the given </span>
<span class="lineNum">  704</span>              :        *  iterator, from a %map.  Note that this function only erases </span>
<span class="lineNum">  705</span>              :        *  the element, and that if the element is itself a pointer, </span>
<span class="lineNum">  706</span>              :        *  the pointed-to memory is not touched in any way.  Managing </span>
<span class="lineNum">  707</span>              :        *  the pointer is the user&#039;s responsibility. </span>
<span class="lineNum">  708</span>              :        *&#047; </span>
<span class="lineNum">  709</span>              :       void </span>
<span class="lineNum">  710</span>              :       erase(iterator __position) </span>
<span class="lineNum">  711</span>              :       { _M_t.erase(__position); } </span>
<span class="lineNum">  712</span>              : #endif </span>
<span class="lineNum">  713</span>              :  </span>
<span class="lineNum">  714</span>              :       &#047;** </span>
<span class="lineNum">  715</span>              :        *  @brief Erases elements according to the provided key. </span>
<span class="lineNum">  716</span>              :        *  @param  __x  Key of element to be erased. </span>
<span class="lineNum">  717</span>              :        *  @return  The number of elements erased. </span>
<span class="lineNum">  718</span>              :        * </span>
<span class="lineNum">  719</span>              :        *  This function erases all the elements located by the given key from </span>
<span class="lineNum">  720</span>              :        *  a %map. </span>
<span class="lineNum">  721</span>              :        *  Note that this function only erases the element, and that if </span>
<span class="lineNum">  722</span>              :        *  the element is itself a pointer, the pointed-to memory is not touched </span>
<span class="lineNum">  723</span>              :        *  in any way.  Managing the pointer is the user&#039;s responsibility. </span>
<span class="lineNum">  724</span>              :        *&#047; </span>
<span class="lineNum">  725</span>              :       size_type </span>
<span class="lineNum">  726</span>              :       erase(const key_type&amp; __x) </span>
<span class="lineNum">  727</span>              :       { return _M_t.erase(__x); } </span>
<span class="lineNum">  728</span>              :  </span>
<span class="lineNum">  729</span>              : #if __cplusplus &gt;= 201103L </span>
<span class="lineNum">  730</span>              :       &#047;&#047; _GLIBCXX_RESOLVE_LIB_DEFECTS </span>
<span class="lineNum">  731</span>              :       &#047;&#047; DR 130. Associative erase should return an iterator. </span>
<span class="lineNum">  732</span>              :       &#047;** </span>
<span class="lineNum">  733</span>              :        *  @brief Erases a [first,last) range of elements from a %map. </span>
<span class="lineNum">  734</span>              :        *  @param  __first  Iterator pointing to the start of the range to be </span>
<span class="lineNum">  735</span>              :        *                   erased. </span>
<span class="lineNum">  736</span>              :        *  @param __last Iterator pointing to the end of the range to </span>
<span class="lineNum">  737</span>              :        *                be erased. </span>
<span class="lineNum">  738</span>              :        *  @return The iterator @a __last. </span>
<span class="lineNum">  739</span>              :        * </span>
<span class="lineNum">  740</span>              :        *  This function erases a sequence of elements from a %map. </span>
<span class="lineNum">  741</span>              :        *  Note that this function only erases the element, and that if </span>
<span class="lineNum">  742</span>              :        *  the element is itself a pointer, the pointed-to memory is not touched </span>
<span class="lineNum">  743</span>              :        *  in any way.  Managing the pointer is the user&#039;s responsibility. </span>
<span class="lineNum">  744</span>              :        *&#047; </span>
<span class="lineNum">  745</span>              :       iterator </span>
<span class="lineNum">  746</span>              :       erase(const_iterator __first, const_iterator __last) </span>
<span class="lineNum">  747</span>              :       { return _M_t.erase(__first, __last); } </span>
<span class="lineNum">  748</span>              : #else </span>
<span class="lineNum">  749</span>              :       &#047;** </span>
<span class="lineNum">  750</span>              :        *  @brief Erases a [__first,__last) range of elements from a %map. </span>
<span class="lineNum">  751</span>              :        *  @param  __first  Iterator pointing to the start of the range to be </span>
<span class="lineNum">  752</span>              :        *                   erased. </span>
<span class="lineNum">  753</span>              :        *  @param __last Iterator pointing to the end of the range to </span>
<span class="lineNum">  754</span>              :        *                be erased. </span>
<span class="lineNum">  755</span>              :        * </span>
<span class="lineNum">  756</span>              :        *  This function erases a sequence of elements from a %map. </span>
<span class="lineNum">  757</span>              :        *  Note that this function only erases the element, and that if </span>
<span class="lineNum">  758</span>              :        *  the element is itself a pointer, the pointed-to memory is not touched </span>
<span class="lineNum">  759</span>              :        *  in any way.  Managing the pointer is the user&#039;s responsibility. </span>
<span class="lineNum">  760</span>              :        *&#047; </span>
<span class="lineNum">  761</span>              :       void </span>
<span class="lineNum">  762</span>              :       erase(iterator __first, iterator __last) </span>
<span class="lineNum">  763</span>              :       { _M_t.erase(__first, __last); } </span>
<span class="lineNum">  764</span>              : #endif </span>
<span class="lineNum">  765</span>              :  </span>
<span class="lineNum">  766</span>              :       &#047;** </span>
<span class="lineNum">  767</span>              :        *  @brief  Swaps data with another %map. </span>
<span class="lineNum">  768</span>              :        *  @param  __x  A %map of the same element and allocator types. </span>
<span class="lineNum">  769</span>              :        * </span>
<span class="lineNum">  770</span>              :        *  This exchanges the elements between two maps in constant </span>
<span class="lineNum">  771</span>              :        *  time.  (It is only swapping a pointer, an integer, and an </span>
<span class="lineNum">  772</span>              :        *  instance of the @c Compare type (which itself is often </span>
<span class="lineNum">  773</span>              :        *  stateless and empty), so it should be quite fast.)  Note </span>
<span class="lineNum">  774</span>              :        *  that the global std::swap() function is specialized such </span>
<span class="lineNum">  775</span>              :        *  that std::swap(m1,m2) will feed to this function. </span>
<span class="lineNum">  776</span>              :        *&#047; </span>
<span class="lineNum">  777</span>              :       void </span>
<span class="lineNum">  778</span><span class="lineNoCov">      0  /   1:       swap(map&amp; __x) </span>
<span class="lineNum">  779</span><span class="lineNoCov">      0  /   2:       { _M_t.swap(__x._M_t); } </span>
<span class="lineNum">  780</span>              :  </span>
<span class="lineNum">  781</span>              :       &#047;** </span>
<span class="lineNum">  782</span>              :        *  Erases all elements in a %map.  Note that this function only </span>
<span class="lineNum">  783</span>              :        *  erases the elements, and that if the elements themselves are </span>
<span class="lineNum">  784</span>              :        *  pointers, the pointed-to memory is not touched in any way. </span>
<span class="lineNum">  785</span>              :        *  Managing the pointer is the user&#039;s responsibility. </span>
<span class="lineNum">  786</span>              :        *&#047; </span>
<span class="lineNum">  787</span>              :       void </span>
<span class="lineNum">  788</span><span class="lineCov">      1  /   1:       clear() _GLIBCXX_NOEXCEPT </span>
<span class="lineNum">  789</span><span class="linePartCov">      1  /   2:       { _M_t.clear(); } </span>
<span class="lineNum">  790</span>              :  </span>
<span class="lineNum">  791</span>              :       &#047;&#047; observers </span>
<span class="lineNum">  792</span>              :       &#047;** </span>
<span class="lineNum">  793</span>              :        *  Returns the key comparison object out of which the %map was </span>
<span class="lineNum">  794</span>              :        *  constructed. </span>
<span class="lineNum">  795</span>              :        *&#047; </span>
<span class="lineNum">  796</span>              :       key_compare </span>
<span class="lineNum">  797</span><span class="linePartCov">      1  /   2:       key_comp() const </span>
<span class="lineNum">  798</span><span class="linePartCov">      1  /   4:       { return _M_t.key_comp(); } </span>
<span class="lineNum">  799</span>              :  </span>
<span class="lineNum">  800</span>              :       &#047;** </span>
<span class="lineNum">  801</span>              :        *  Returns a value comparison object, built from the key comparison </span>
<span class="lineNum">  802</span>              :        *  object out of which the %map was constructed. </span>
<span class="lineNum">  803</span>              :        *&#047; </span>
<span class="lineNum">  804</span>              :       value_compare </span>
<span class="lineNum">  805</span>              :       value_comp() const </span>
<span class="lineNum">  806</span>              :       { return value_compare(_M_t.key_comp()); } </span>
<span class="lineNum">  807</span>              :  </span>
<span class="lineNum">  808</span>              :       &#047;&#047; [23.3.1.3] map operations </span>
<span class="lineNum">  809</span>              :       &#047;** </span>
<span class="lineNum">  810</span>              :        *  @brief Tries to locate an element in a %map. </span>
<span class="lineNum">  811</span>              :        *  @param  __x  Key of (key, value) %pair to be located. </span>
<span class="lineNum">  812</span>              :        *  @return  Iterator pointing to sought-after element, or end() if not </span>
<span class="lineNum">  813</span>              :        *           found. </span>
<span class="lineNum">  814</span>              :        * </span>
<span class="lineNum">  815</span>              :        *  This function takes a key and tries to locate the element with which </span>
<span class="lineNum">  816</span>              :        *  the key matches.  If successful the function returns an iterator </span>
<span class="lineNum">  817</span>              :        *  pointing to the sought after %pair.  If unsuccessful it returns the </span>
<span class="lineNum">  818</span>              :        *  past-the-end ( @c end() ) iterator. </span>
<span class="lineNum">  819</span>              :        *&#047; </span>
<span class="lineNum">  820</span>              :       iterator </span>
<span class="lineNum">  821</span>              :       find(const key_type&amp; __x) </span>
<span class="lineNum">  822</span>              :       { return _M_t.find(__x); } </span>
<span class="lineNum">  823</span>              :  </span>
<span class="lineNum">  824</span>              :       &#047;** </span>
<span class="lineNum">  825</span>              :        *  @brief Tries to locate an element in a %map. </span>
<span class="lineNum">  826</span>              :        *  @param  __x  Key of (key, value) %pair to be located. </span>
<span class="lineNum">  827</span>              :        *  @return  Read-only (constant) iterator pointing to sought-after </span>
<span class="lineNum">  828</span>              :        *           element, or end() if not found. </span>
<span class="lineNum">  829</span>              :        * </span>
<span class="lineNum">  830</span>              :        *  This function takes a key and tries to locate the element with which </span>
<span class="lineNum">  831</span>              :        *  the key matches.  If successful the function returns a constant </span>
<span class="lineNum">  832</span>              :        *  iterator pointing to the sought after %pair. If unsuccessful it </span>
<span class="lineNum">  833</span>              :        *  returns the past-the-end ( @c end() ) iterator. </span>
<span class="lineNum">  834</span>              :        *&#047; </span>
<span class="lineNum">  835</span>              :       const_iterator </span>
<span class="lineNum">  836</span>              :       find(const key_type&amp; __x) const </span>
<span class="lineNum">  837</span>              :       { return _M_t.find(__x); } </span>
<span class="lineNum">  838</span>              :  </span>
<span class="lineNum">  839</span>              :       &#047;** </span>
<span class="lineNum">  840</span>              :        *  @brief  Finds the number of elements with given key. </span>
<span class="lineNum">  841</span>              :        *  @param  __x  Key of (key, value) pairs to be located. </span>
<span class="lineNum">  842</span>              :        *  @return  Number of elements with specified key. </span>
<span class="lineNum">  843</span>              :        * </span>
<span class="lineNum">  844</span>              :        *  This function only makes sense for multimaps; for map the result will </span>
<span class="lineNum">  845</span>              :        *  either be 0 (not present) or 1 (present). </span>
<span class="lineNum">  846</span>              :        *&#047; </span>
<span class="lineNum">  847</span>              :       size_type </span>
<span class="lineNum">  848</span>              :       count(const key_type&amp; __x) const </span>
<span class="lineNum">  849</span>              :       { return _M_t.find(__x) == _M_t.end() ? 0 : 1; } </span>
<span class="lineNum">  850</span>              :  </span>
<span class="lineNum">  851</span>              :       &#047;** </span>
<span class="lineNum">  852</span>              :        *  @brief Finds the beginning of a subsequence matching given key. </span>
<span class="lineNum">  853</span>              :        *  @param  __x  Key of (key, value) pair to be located. </span>
<span class="lineNum">  854</span>              :        *  @return  Iterator pointing to first element equal to or greater </span>
<span class="lineNum">  855</span>              :        *           than key, or end(). </span>
<span class="lineNum">  856</span>              :        * </span>
<span class="lineNum">  857</span>              :        *  This function returns the first element of a subsequence of elements </span>
<span class="lineNum">  858</span>              :        *  that matches the given key.  If unsuccessful it returns an iterator </span>
<span class="lineNum">  859</span>              :        *  pointing to the first element that has a greater value than given key </span>
<span class="lineNum">  860</span>              :        *  or end() if no such element exists. </span>
<span class="lineNum">  861</span>              :        *&#047; </span>
<span class="lineNum">  862</span>              :       iterator </span>
<span class="lineNum">  863</span><span class="linePartCov">      1  /   2:       lower_bound(const key_type&amp; __x) </span>
<span class="lineNum">  864</span><span class="linePartCov">      1  /   4:       { return _M_t.lower_bound(__x); } </span>
<span class="lineNum">  865</span>              :  </span>
<span class="lineNum">  866</span>              :       &#047;** </span>
<span class="lineNum">  867</span>              :        *  @brief Finds the beginning of a subsequence matching given key. </span>
<span class="lineNum">  868</span>              :        *  @param  __x  Key of (key, value) pair to be located. </span>
<span class="lineNum">  869</span>              :        *  @return  Read-only (constant) iterator pointing to first element </span>
<span class="lineNum">  870</span>              :        *           equal to or greater than key, or end(). </span>
<span class="lineNum">  871</span>              :        * </span>
<span class="lineNum">  872</span>              :        *  This function returns the first element of a subsequence of elements </span>
<span class="lineNum">  873</span>              :        *  that matches the given key.  If unsuccessful it returns an iterator </span>
<span class="lineNum">  874</span>              :        *  pointing to the first element that has a greater value than given key </span>
<span class="lineNum">  875</span>              :        *  or end() if no such element exists. </span>
<span class="lineNum">  876</span>              :        *&#047; </span>
<span class="lineNum">  877</span>              :       const_iterator </span>
<span class="lineNum">  878</span>              :       lower_bound(const key_type&amp; __x) const </span>
<span class="lineNum">  879</span>              :       { return _M_t.lower_bound(__x); } </span>
<span class="lineNum">  880</span>              :  </span>
<span class="lineNum">  881</span>              :       &#047;** </span>
<span class="lineNum">  882</span>              :        *  @brief Finds the end of a subsequence matching given key. </span>
<span class="lineNum">  883</span>              :        *  @param  __x  Key of (key, value) pair to be located. </span>
<span class="lineNum">  884</span>              :        *  @return Iterator pointing to the first element </span>
<span class="lineNum">  885</span>              :        *          greater than key, or end(). </span>
<span class="lineNum">  886</span>              :        *&#047; </span>
<span class="lineNum">  887</span>              :       iterator </span>
<span class="lineNum">  888</span>              :       upper_bound(const key_type&amp; __x) </span>
<span class="lineNum">  889</span>              :       { return _M_t.upper_bound(__x); } </span>
<span class="lineNum">  890</span>              :  </span>
<span class="lineNum">  891</span>              :       &#047;** </span>
<span class="lineNum">  892</span>              :        *  @brief Finds the end of a subsequence matching given key. </span>
<span class="lineNum">  893</span>              :        *  @param  __x  Key of (key, value) pair to be located. </span>
<span class="lineNum">  894</span>              :        *  @return  Read-only (constant) iterator pointing to first iterator </span>
<span class="lineNum">  895</span>              :        *           greater than key, or end(). </span>
<span class="lineNum">  896</span>              :        *&#047; </span>
<span class="lineNum">  897</span>              :       const_iterator </span>
<span class="lineNum">  898</span>              :       upper_bound(const key_type&amp; __x) const </span>
<span class="lineNum">  899</span>              :       { return _M_t.upper_bound(__x); } </span>
<span class="lineNum">  900</span>              :  </span>
<span class="lineNum">  901</span>              :       &#047;** </span>
<span class="lineNum">  902</span>              :        *  @brief Finds a subsequence matching given key. </span>
<span class="lineNum">  903</span>              :        *  @param  __x  Key of (key, value) pairs to be located. </span>
<span class="lineNum">  904</span>              :        *  @return  Pair of iterators that possibly points to the subsequence </span>
<span class="lineNum">  905</span>              :        *           matching given key. </span>
<span class="lineNum">  906</span>              :        * </span>
<span class="lineNum">  907</span>              :        *  This function is equivalent to </span>
<span class="lineNum">  908</span>              :        *  @code </span>
<span class="lineNum">  909</span>              :        *    std::make_pair(c.lower_bound(val), </span>
<span class="lineNum">  910</span>              :        *                   c.upper_bound(val)) </span>
<span class="lineNum">  911</span>              :        *  @endcode </span>
<span class="lineNum">  912</span>              :        *  (but is faster than making the calls separately). </span>
<span class="lineNum">  913</span>              :        * </span>
<span class="lineNum">  914</span>              :        *  This function probably only makes sense for multimaps. </span>
<span class="lineNum">  915</span>              :        *&#047; </span>
<span class="lineNum">  916</span>              :       std::pair&lt;iterator, iterator&gt; </span>
<span class="lineNum">  917</span>              :       equal_range(const key_type&amp; __x) </span>
<span class="lineNum">  918</span>              :       { return _M_t.equal_range(__x); } </span>
<span class="lineNum">  919</span>              :  </span>
<span class="lineNum">  920</span>              :       &#047;** </span>
<span class="lineNum">  921</span>              :        *  @brief Finds a subsequence matching given key. </span>
<span class="lineNum">  922</span>              :        *  @param  __x  Key of (key, value) pairs to be located. </span>
<span class="lineNum">  923</span>              :        *  @return  Pair of read-only (constant) iterators that possibly points </span>
<span class="lineNum">  924</span>              :        *           to the subsequence matching given key. </span>
<span class="lineNum">  925</span>              :        * </span>
<span class="lineNum">  926</span>              :        *  This function is equivalent to </span>
<span class="lineNum">  927</span>              :        *  @code </span>
<span class="lineNum">  928</span>              :        *    std::make_pair(c.lower_bound(val), </span>
<span class="lineNum">  929</span>              :        *                   c.upper_bound(val)) </span>
<span class="lineNum">  930</span>              :        *  @endcode </span>
<span class="lineNum">  931</span>              :        *  (but is faster than making the calls separately). </span>
<span class="lineNum">  932</span>              :        * </span>
<span class="lineNum">  933</span>              :        *  This function probably only makes sense for multimaps. </span>
<span class="lineNum">  934</span>              :        *&#047; </span>
<span class="lineNum">  935</span>              :       std::pair&lt;const_iterator, const_iterator&gt; </span>
<span class="lineNum">  936</span>              :       equal_range(const key_type&amp; __x) const </span>
<span class="lineNum">  937</span>              :       { return _M_t.equal_range(__x); } </span>
<span class="lineNum">  938</span>              :  </span>
<span class="lineNum">  939</span>              :       template&lt;typename _K1, typename _T1, typename _C1, typename _A1&gt; </span>
<span class="lineNum">  940</span>              :         friend bool </span>
<span class="lineNum">  941</span>              :         operator==(const map&lt;_K1, _T1, _C1, _A1&gt;&amp;, </span>
<span class="lineNum">  942</span>              : 		   const map&lt;_K1, _T1, _C1, _A1&gt;&amp;); </span>
<span class="lineNum">  943</span>              :  </span>
<span class="lineNum">  944</span>              :       template&lt;typename _K1, typename _T1, typename _C1, typename _A1&gt; </span>
<span class="lineNum">  945</span>              :         friend bool </span>
<span class="lineNum">  946</span>              :         operator&lt;(const map&lt;_K1, _T1, _C1, _A1&gt;&amp;, </span>
<span class="lineNum">  947</span>              : 		  const map&lt;_K1, _T1, _C1, _A1&gt;&amp;); </span>
<span class="lineNum">  948</span>              :     }; </span>
<span class="lineNum">  949</span>              :  </span>
<span class="lineNum">  950</span>              :   &#047;** </span>
<span class="lineNum">  951</span>              :    *  @brief  Map equality comparison. </span>
<span class="lineNum">  952</span>              :    *  @param  __x  A %map. </span>
<span class="lineNum">  953</span>              :    *  @param  __y  A %map of the same type as @a x. </span>
<span class="lineNum">  954</span>              :    *  @return  True iff the size and elements of the maps are equal. </span>
<span class="lineNum">  955</span>              :    * </span>
<span class="lineNum">  956</span>              :    *  This is an equivalence relation.  It is linear in the size of the </span>
<span class="lineNum">  957</span>              :    *  maps.  Maps are considered equivalent if their sizes are equal, </span>
<span class="lineNum">  958</span>              :    *  and if corresponding elements compare equal. </span>
<span class="lineNum">  959</span>              :   *&#047; </span>
<span class="lineNum">  960</span>              :   template&lt;typename _Key, typename _Tp, typename _Compare, typename _Alloc&gt; </span>
<span class="lineNum">  961</span>              :     inline bool </span>
<span class="lineNum">  962</span>              :     operator==(const map&lt;_Key, _Tp, _Compare, _Alloc&gt;&amp; __x, </span>
<span class="lineNum">  963</span>              :                const map&lt;_Key, _Tp, _Compare, _Alloc&gt;&amp; __y) </span>
<span class="lineNum">  964</span>              :     { return __x._M_t == __y._M_t; } </span>
<span class="lineNum">  965</span>              :  </span>
<span class="lineNum">  966</span>              :   &#047;** </span>
<span class="lineNum">  967</span>              :    *  @brief  Map ordering relation. </span>
<span class="lineNum">  968</span>              :    *  @param  __x  A %map. </span>
<span class="lineNum">  969</span>              :    *  @param  __y  A %map of the same type as @a x. </span>
<span class="lineNum">  970</span>              :    *  @return  True iff @a x is lexicographically less than @a y. </span>
<span class="lineNum">  971</span>              :    * </span>
<span class="lineNum">  972</span>              :    *  This is a total ordering relation.  It is linear in the size of the </span>
<span class="lineNum">  973</span>              :    *  maps.  The elements must be comparable with @c &lt;. </span>
<span class="lineNum">  974</span>              :    * </span>
<span class="lineNum">  975</span>              :    *  See std::lexicographical_compare() for how the determination is made. </span>
<span class="lineNum">  976</span>              :   *&#047; </span>
<span class="lineNum">  977</span>              :   template&lt;typename _Key, typename _Tp, typename _Compare, typename _Alloc&gt; </span>
<span class="lineNum">  978</span>              :     inline bool </span>
<span class="lineNum">  979</span>              :     operator&lt;(const map&lt;_Key, _Tp, _Compare, _Alloc&gt;&amp; __x, </span>
<span class="lineNum">  980</span>              :               const map&lt;_Key, _Tp, _Compare, _Alloc&gt;&amp; __y) </span>
<span class="lineNum">  981</span>              :     { return __x._M_t &lt; __y._M_t; } </span>
<span class="lineNum">  982</span>              :  </span>
<span class="lineNum">  983</span>              :   &#047;&#047;&#047; Based on operator== </span>
<span class="lineNum">  984</span>              :   template&lt;typename _Key, typename _Tp, typename _Compare, typename _Alloc&gt; </span>
<span class="lineNum">  985</span>              :     inline bool </span>
<span class="lineNum">  986</span>              :     operator!=(const map&lt;_Key, _Tp, _Compare, _Alloc&gt;&amp; __x, </span>
<span class="lineNum">  987</span>              :                const map&lt;_Key, _Tp, _Compare, _Alloc&gt;&amp; __y) </span>
<span class="lineNum">  988</span>              :     { return !(__x == __y); } </span>
<span class="lineNum">  989</span>              :  </span>
<span class="lineNum">  990</span>              :   &#047;&#047;&#047; Based on operator&lt; </span>
<span class="lineNum">  991</span>              :   template&lt;typename _Key, typename _Tp, typename _Compare, typename _Alloc&gt; </span>
<span class="lineNum">  992</span>              :     inline bool </span>
<span class="lineNum">  993</span>              :     operator&gt;(const map&lt;_Key, _Tp, _Compare, _Alloc&gt;&amp; __x, </span>
<span class="lineNum">  994</span>              :               const map&lt;_Key, _Tp, _Compare, _Alloc&gt;&amp; __y) </span>
<span class="lineNum">  995</span>              :     { return __y &lt; __x; } </span>
<span class="lineNum">  996</span>              :  </span>
<span class="lineNum">  997</span>              :   &#047;&#047;&#047; Based on operator&lt; </span>
<span class="lineNum">  998</span>              :   template&lt;typename _Key, typename _Tp, typename _Compare, typename _Alloc&gt; </span>
<span class="lineNum">  999</span>              :     inline bool </span>
<span class="lineNum"> 1000</span>              :     operator&lt;=(const map&lt;_Key, _Tp, _Compare, _Alloc&gt;&amp; __x, </span>
<span class="lineNum"> 1001</span>              :                const map&lt;_Key, _Tp, _Compare, _Alloc&gt;&amp; __y) </span>
<span class="lineNum"> 1002</span>              :     { return !(__y &lt; __x); } </span>
<span class="lineNum"> 1003</span>              :  </span>
<span class="lineNum"> 1004</span>              :   &#047;&#047;&#047; Based on operator&lt; </span>
<span class="lineNum"> 1005</span>              :   template&lt;typename _Key, typename _Tp, typename _Compare, typename _Alloc&gt; </span>
<span class="lineNum"> 1006</span>              :     inline bool </span>
<span class="lineNum"> 1007</span>              :     operator&gt;=(const map&lt;_Key, _Tp, _Compare, _Alloc&gt;&amp; __x, </span>
<span class="lineNum"> 1008</span>              :                const map&lt;_Key, _Tp, _Compare, _Alloc&gt;&amp; __y) </span>
<span class="lineNum"> 1009</span>              :     { return !(__x &lt; __y); } </span>
<span class="lineNum"> 1010</span>              :  </span>
<span class="lineNum"> 1011</span>              :   &#047;&#047;&#047; See std::map::swap(). </span>
<span class="lineNum"> 1012</span>              :   template&lt;typename _Key, typename _Tp, typename _Compare, typename _Alloc&gt; </span>
<span class="lineNum"> 1013</span>              :     inline void </span>
<span class="lineNum"> 1014</span>              :     swap(map&lt;_Key, _Tp, _Compare, _Alloc&gt;&amp; __x, </span>
<span class="lineNum"> 1015</span>              : 	 map&lt;_Key, _Tp, _Compare, _Alloc&gt;&amp; __y) </span>
<span class="lineNum"> 1016</span>              :     { __x.swap(__y); } </span>
<span class="lineNum"> 1017</span>              :  </span>
<span class="lineNum"> 1018</span>              : _GLIBCXX_END_NAMESPACE_CONTAINER </span>
<span class="lineNum"> 1019</span>              : } &#047;&#047; namespace std </span>
<span class="lineNum"> 1020</span>              :  </span>
<span class="lineNum"> 1021</span>              : #endif &#047;* _STL_MAP_H *&#047; </span>
</pre>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr><td class="versionInfo">Generated by: <a href="http://simonkagstrom.github.com/kcov/index.html">Kcov</a></td></tr>
</table>
<br/>
</body>
</html>
