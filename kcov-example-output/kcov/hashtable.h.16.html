<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Coverage - kcov</title>
  <link rel="stylesheet" type="text/css" href="bcov.css"/>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="title">Coverage Report</td></tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr>
    <td width="100%">
      <table cellpadding="1" border="0" width="100%">
        <tr>
          <td class="headerItem" width="20%">Command:</td>
          <td class="headerValue" width="80%" colspan=6>kcov</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Date:</td>
          <td class="headerValue" width="15%">2014-03-01 10:11:51</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Instrumented&nbsp;lines:</td>
          <td class="headerValue" width="10%">175</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Code&nbsp;covered:</td>
          <td class="coverPerLeftMed" width="15%">74.3%</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Executed&nbsp;lines:</td>
          <td class="headerValue" width="10%">130</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
</table>
<pre class="source">
<span class="lineNum">    1</span>              : &#047;&#047; hashtable.h header -*- C++ -*- </span>
<span class="lineNum">    2</span>              :  </span>
<span class="lineNum">    3</span>              : &#047;&#047; Copyright (C) 2007-2013 Free Software Foundation, Inc. </span>
<span class="lineNum">    4</span>              : &#047;&#047; </span>
<span class="lineNum">    5</span>              : &#047;&#047; This file is part of the GNU ISO C++ Library.  This library is free </span>
<span class="lineNum">    6</span>              : &#047;&#047; software; you can redistribute it and&#047;or modify it under the </span>
<span class="lineNum">    7</span>              : &#047;&#047; terms of the GNU General Public License as published by the </span>
<span class="lineNum">    8</span>              : &#047;&#047; Free Software Foundation; either version 3, or (at your option) </span>
<span class="lineNum">    9</span>              : &#047;&#047; any later version. </span>
<span class="lineNum">   10</span>              :  </span>
<span class="lineNum">   11</span>              : &#047;&#047; This library is distributed in the hope that it will be useful, </span>
<span class="lineNum">   12</span>              : &#047;&#047; but WITHOUT ANY WARRANTY; without even the implied warranty of </span>
<span class="lineNum">   13</span>              : &#047;&#047; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the </span>
<span class="lineNum">   14</span>              : &#047;&#047; GNU General Public License for more details. </span>
<span class="lineNum">   15</span>              :  </span>
<span class="lineNum">   16</span>              : &#047;&#047; Under Section 7 of GPL version 3, you are granted additional </span>
<span class="lineNum">   17</span>              : &#047;&#047; permissions described in the GCC Runtime Library Exception, version </span>
<span class="lineNum">   18</span>              : &#047;&#047; 3.1, as published by the Free Software Foundation. </span>
<span class="lineNum">   19</span>              :  </span>
<span class="lineNum">   20</span>              : &#047;&#047; You should have received a copy of the GNU General Public License and </span>
<span class="lineNum">   21</span>              : &#047;&#047; a copy of the GCC Runtime Library Exception along with this program; </span>
<span class="lineNum">   22</span>              : &#047;&#047; see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see </span>
<span class="lineNum">   23</span>              : &#047;&#047; &lt;http:&#047;&#047;www.gnu.org&#047;licenses&#047;&gt;. </span>
<span class="lineNum">   24</span>              :  </span>
<span class="lineNum">   25</span>              : &#047;** @file bits&#047;hashtable.h </span>
<span class="lineNum">   26</span>              :  *  This is an internal header file, included by other library headers. </span>
<span class="lineNum">   27</span>              :  *  Do not attempt to use it directly. @headername{unordered_map, unordered_set} </span>
<span class="lineNum">   28</span>              :  *&#047; </span>
<span class="lineNum">   29</span>              :  </span>
<span class="lineNum">   30</span>              : #ifndef _HASHTABLE_H </span>
<span class="lineNum">   31</span>              : #define _HASHTABLE_H 1 </span>
<span class="lineNum">   32</span>              :  </span>
<span class="lineNum">   33</span>              : #pragma GCC system_header </span>
<span class="lineNum">   34</span>              :  </span>
<span class="lineNum">   35</span>              : #include &lt;bits&#047;hashtable_policy.h&gt; </span>
<span class="lineNum">   36</span>              :  </span>
<span class="lineNum">   37</span>              : namespace std _GLIBCXX_VISIBILITY(default) </span>
<span class="lineNum">   38</span>              : { </span>
<span class="lineNum">   39</span>              : _GLIBCXX_BEGIN_NAMESPACE_VERSION </span>
<span class="lineNum">   40</span>              :  </span>
<span class="lineNum">   41</span>              :   template&lt;typename _Tp, typename _Hash&gt; </span>
<span class="lineNum">   42</span>              :     using __cache_default </span>
<span class="lineNum">   43</span>              :       =  __not_&lt;__and_&lt;&#047;&#047; Do not cache for fast hasher. </span>
<span class="lineNum">   44</span>              : 		       __is_fast_hash&lt;_Hash&gt;, </span>
<span class="lineNum">   45</span>              : 		       &#047;&#047; Mandatory to make local_iterator default </span>
<span class="lineNum">   46</span>              : 		       &#047;&#047; constructible and assignable. </span>
<span class="lineNum">   47</span>              : 		       is_default_constructible&lt;_Hash&gt;, </span>
<span class="lineNum">   48</span>              : 		       is_copy_assignable&lt;_Hash&gt;, </span>
<span class="lineNum">   49</span>              : 		       &#047;&#047; Mandatory to have erase not throwing. </span>
<span class="lineNum">   50</span>              : 		       __detail::__is_noexcept_hash&lt;_Tp, _Hash&gt;&gt;&gt;; </span>
<span class="lineNum">   51</span>              :  </span>
<span class="lineNum">   52</span>              :   &#047;** </span>
<span class="lineNum">   53</span>              :    *  Primary class template _Hashtable. </span>
<span class="lineNum">   54</span>              :    * </span>
<span class="lineNum">   55</span>              :    *  @ingroup hashtable-detail </span>
<span class="lineNum">   56</span>              :    * </span>
<span class="lineNum">   57</span>              :    *  @tparam _Value  CopyConstructible type. </span>
<span class="lineNum">   58</span>              :    * </span>
<span class="lineNum">   59</span>              :    *  @tparam _Key    CopyConstructible type. </span>
<span class="lineNum">   60</span>              :    * </span>
<span class="lineNum">   61</span>              :    *  @tparam _Alloc  An allocator type </span>
<span class="lineNum">   62</span>              :    *  ([lib.allocator.requirements]) whose _Alloc::value_type is </span>
<span class="lineNum">   63</span>              :    *  _Value.  As a conforming extension, we allow for </span>
<span class="lineNum">   64</span>              :    *  _Alloc::value_type != _Value. </span>
<span class="lineNum">   65</span>              :    * </span>
<span class="lineNum">   66</span>              :    *  @tparam _ExtractKey  Function object that takes an object of type </span>
<span class="lineNum">   67</span>              :    *  _Value and returns a value of type _Key. </span>
<span class="lineNum">   68</span>              :    * </span>
<span class="lineNum">   69</span>              :    *  @tparam _Equal  Function object that takes two objects of type k </span>
<span class="lineNum">   70</span>              :    *  and returns a bool-like value that is true if the two objects </span>
<span class="lineNum">   71</span>              :    *  are considered equal. </span>
<span class="lineNum">   72</span>              :    * </span>
<span class="lineNum">   73</span>              :    *  @tparam _H1  The hash function. A unary function object with </span>
<span class="lineNum">   74</span>              :    *  argument type _Key and result type size_t. Return values should </span>
<span class="lineNum">   75</span>              :    *  be distributed over the entire range [0, numeric_limits&lt;size_t&gt;:::max()]. </span>
<span class="lineNum">   76</span>              :    * </span>
<span class="lineNum">   77</span>              :    *  @tparam _H2  The range-hashing function (in the terminology of </span>
<span class="lineNum">   78</span>              :    *  Tavori and Dreizin).  A binary function object whose argument </span>
<span class="lineNum">   79</span>              :    *  types and result type are all size_t.  Given arguments r and N, </span>
<span class="lineNum">   80</span>              :    *  the return value is in the range [0, N). </span>
<span class="lineNum">   81</span>              :    * </span>
<span class="lineNum">   82</span>              :    *  @tparam _Hash  The ranged hash function (Tavori and Dreizin). A </span>
<span class="lineNum">   83</span>              :    *  binary function whose argument types are _Key and size_t and </span>
<span class="lineNum">   84</span>              :    *  whose result type is size_t.  Given arguments k and N, the </span>
<span class="lineNum">   85</span>              :    *  return value is in the range [0, N).  Default: hash(k, N) = </span>
<span class="lineNum">   86</span>              :    *  h2(h1(k), N).  If _Hash is anything other than the default, _H1 </span>
<span class="lineNum">   87</span>              :    *  and _H2 are ignored. </span>
<span class="lineNum">   88</span>              :    * </span>
<span class="lineNum">   89</span>              :    *  @tparam _RehashPolicy  Policy class with three members, all of </span>
<span class="lineNum">   90</span>              :    *  which govern the bucket count. _M_next_bkt(n) returns a bucket </span>
<span class="lineNum">   91</span>              :    *  count no smaller than n.  _M_bkt_for_elements(n) returns a </span>
<span class="lineNum">   92</span>              :    *  bucket count appropriate for an element count of n. </span>
<span class="lineNum">   93</span>              :    *  _M_need_rehash(n_bkt, n_elt, n_ins) determines whether, if the </span>
<span class="lineNum">   94</span>              :    *  current bucket count is n_bkt and the current element count is </span>
<span class="lineNum">   95</span>              :    *  n_elt, we need to increase the bucket count.  If so, returns </span>
<span class="lineNum">   96</span>              :    *  make_pair(true, n), where n is the new bucket count.  If not, </span>
<span class="lineNum">   97</span>              :    *  returns make_pair(false, &lt;anything&gt;) </span>
<span class="lineNum">   98</span>              :    * </span>
<span class="lineNum">   99</span>              :    *  @tparam _Traits  Compile-time class with three boolean </span>
<span class="lineNum">  100</span>              :    *  std::integral_constant members:  __cache_hash_code, __constant_iterators, </span>
<span class="lineNum">  101</span>              :    *   __unique_keys. </span>
<span class="lineNum">  102</span>              :    * </span>
<span class="lineNum">  103</span>              :    *  Each _Hashtable data structure has: </span>
<span class="lineNum">  104</span>              :    * </span>
<span class="lineNum">  105</span>              :    *  - _Bucket[]       _M_buckets </span>
<span class="lineNum">  106</span>              :    *  - _Hash_node_base _M_bbegin </span>
<span class="lineNum">  107</span>              :    *  - size_type       _M_bucket_count </span>
<span class="lineNum">  108</span>              :    *  - size_type       _M_element_count </span>
<span class="lineNum">  109</span>              :    * </span>
<span class="lineNum">  110</span>              :    *  with _Bucket being _Hash_node* and _Hash_node containing: </span>
<span class="lineNum">  111</span>              :    * </span>
<span class="lineNum">  112</span>              :    *  - _Hash_node*   _M_next </span>
<span class="lineNum">  113</span>              :    *  - Tp            _M_value </span>
<span class="lineNum">  114</span>              :    *  - size_t        _M_hash_code if cache_hash_code is true </span>
<span class="lineNum">  115</span>              :    * </span>
<span class="lineNum">  116</span>              :    *  In terms of Standard containers the hashtable is like the aggregation of: </span>
<span class="lineNum">  117</span>              :    * </span>
<span class="lineNum">  118</span>              :    *  - std::forward_list&lt;_Node&gt; containing the elements </span>
<span class="lineNum">  119</span>              :    *  - std::vector&lt;std::forward_list&lt;_Node&gt;::iterator&gt; representing the buckets </span>
<span class="lineNum">  120</span>              :    * </span>
<span class="lineNum">  121</span>              :    *  The non-empty buckets contain the node before the first node in the </span>
<span class="lineNum">  122</span>              :    *  bucket. This design makes it possible to implement something like a </span>
<span class="lineNum">  123</span>              :    *  std::forward_list::insert_after on container insertion and </span>
<span class="lineNum">  124</span>              :    *  std::forward_list::erase_after on container erase </span>
<span class="lineNum">  125</span>              :    *  calls. _M_before_begin is equivalent to </span>
<span class="lineNum">  126</span>              :    *  std::forward_list::before_begin. Empty buckets contain </span>
<span class="lineNum">  127</span>              :    *  nullptr.  Note that one of the non-empty buckets contains </span>
<span class="lineNum">  128</span>              :    *  &amp;_M_before_begin which is not a dereferenceable node so the </span>
<span class="lineNum">  129</span>              :    *  node pointer in a bucket shall never be dereferenced, only its </span>
<span class="lineNum">  130</span>              :    *  next node can be. </span>
<span class="lineNum">  131</span>              :    * </span>
<span class="lineNum">  132</span>              :    *  Walking through a bucket&#039;s nodes requires a check on the hash code to </span>
<span class="lineNum">  133</span>              :    *  see if each node is still in the bucket. Such a design assumes a </span>
<span class="lineNum">  134</span>              :    *  quite efficient hash functor and is one of the reasons it is </span>
<span class="lineNum">  135</span>              :    *  highly advisable to set __cache_hash_code to true. </span>
<span class="lineNum">  136</span>              :    * </span>
<span class="lineNum">  137</span>              :    *  The container iterators are simply built from nodes. This way </span>
<span class="lineNum">  138</span>              :    *  incrementing the iterator is perfectly efficient independent of </span>
<span class="lineNum">  139</span>              :    *  how many empty buckets there are in the container. </span>
<span class="lineNum">  140</span>              :    * </span>
<span class="lineNum">  141</span>              :    *  On insert we compute the element&#039;s hash code and use it to find the </span>
<span class="lineNum">  142</span>              :    *  bucket index. If the element must be inserted in an empty bucket </span>
<span class="lineNum">  143</span>              :    *  we add it at the beginning of the singly linked list and make the </span>
<span class="lineNum">  144</span>              :    *  bucket point to _M_before_begin. The bucket that used to point to </span>
<span class="lineNum">  145</span>              :    *  _M_before_begin, if any, is updated to point to its new before </span>
<span class="lineNum">  146</span>              :    *  begin node. </span>
<span class="lineNum">  147</span>              :    * </span>
<span class="lineNum">  148</span>              :    *  On erase, the simple iterator design requires using the hash </span>
<span class="lineNum">  149</span>              :    *  functor to get the index of the bucket to update. For this </span>
<span class="lineNum">  150</span>              :    *  reason, when __cache_hash_code is set to false the hash functor must </span>
<span class="lineNum">  151</span>              :    *  not throw and this is enforced by a static assertion. </span>
<span class="lineNum">  152</span>              :    * </span>
<span class="lineNum">  153</span>              :    *  Functionality is implemented by decomposition into base classes, </span>
<span class="lineNum">  154</span>              :    *  where the derived _Hashtable class is used in _Map_base, </span>
<span class="lineNum">  155</span>              :    *  _Insert, _Rehash_base, and _Equality base classes to access the </span>
<span class="lineNum">  156</span>              :    *  &quot;this&quot; pointer. _Hashtable_base is used in the base classes as a </span>
<span class="lineNum">  157</span>              :    *  non-recursive, fully-completed-type so that detailed nested type </span>
<span class="lineNum">  158</span>              :    *  information, such as iterator type and node type, can be </span>
<span class="lineNum">  159</span>              :    *  used. This is similar to the &quot;Curiously Recurring Template </span>
<span class="lineNum">  160</span>              :    *  Pattern&quot; (CRTP) technique, but uses a reconstructed, not </span>
<span class="lineNum">  161</span>              :    *  explicitly passed, template pattern. </span>
<span class="lineNum">  162</span>              :    * </span>
<span class="lineNum">  163</span>              :    *  Base class templates are:  </span>
<span class="lineNum">  164</span>              :    *    - __detail::_Hashtable_base </span>
<span class="lineNum">  165</span>              :    *    - __detail::_Map_base </span>
<span class="lineNum">  166</span>              :    *    - __detail::_Insert </span>
<span class="lineNum">  167</span>              :    *    - __detail::_Rehash_base </span>
<span class="lineNum">  168</span>              :    *    - __detail::_Equality </span>
<span class="lineNum">  169</span>              :    *&#047; </span>
<span class="lineNum">  170</span>              :   template&lt;typename _Key, typename _Value, typename _Alloc, </span>
<span class="lineNum">  171</span>              : 	   typename _ExtractKey, typename _Equal, </span>
<span class="lineNum">  172</span>              : 	   typename _H1, typename _H2, typename _Hash, </span>
<span class="lineNum">  173</span>              : 	   typename _RehashPolicy, typename _Traits&gt; </span>
<span class="lineNum">  174</span>              :     class _Hashtable </span>
<span class="lineNum">  175</span>              :     : public __detail::_Hashtable_base&lt;_Key, _Value, _ExtractKey, _Equal, </span>
<span class="lineNum">  176</span>              : 				       _H1, _H2, _Hash, _Traits&gt;, </span>
<span class="lineNum">  177</span>              :       public __detail::_Map_base&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum">  178</span>              : 				 _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;, </span>
<span class="lineNum">  179</span>              :       public __detail::_Insert&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum">  180</span>              : 			       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;, </span>
<span class="lineNum">  181</span>              :       public __detail::_Rehash_base&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum">  182</span>              : 				    _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;, </span>
<span class="lineNum">  183</span>              :       public __detail::_Equality&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum">  184</span>              : 				 _H1, _H2, _Hash, _RehashPolicy, _Traits&gt; </span>
<span class="lineNum">  185</span>              :     { </span>
<span class="lineNum">  186</span>              :     public: </span>
<span class="lineNum">  187</span>              :       typedef _Key                                    key_type; </span>
<span class="lineNum">  188</span>              :       typedef _Value                                  value_type; </span>
<span class="lineNum">  189</span>              :       typedef _Alloc                                  allocator_type; </span>
<span class="lineNum">  190</span>              :       typedef _Equal                                  key_equal; </span>
<span class="lineNum">  191</span>              :  </span>
<span class="lineNum">  192</span>              :       &#047;&#047; mapped_type, if present, comes from _Map_base. </span>
<span class="lineNum">  193</span>              :       &#047;&#047; hasher, if present, comes from _Hash_code_base&#047;_Hashtable_base. </span>
<span class="lineNum">  194</span>              :       typedef typename _Alloc::pointer		      pointer; </span>
<span class="lineNum">  195</span>              :       typedef typename _Alloc::const_pointer          const_pointer; </span>
<span class="lineNum">  196</span>              :       typedef typename _Alloc::reference              reference; </span>
<span class="lineNum">  197</span>              :       typedef typename _Alloc::const_reference        const_reference; </span>
<span class="lineNum">  198</span>              :  </span>
<span class="lineNum">  199</span>              :     private: </span>
<span class="lineNum">  200</span>              :       using __rehash_type = _RehashPolicy; </span>
<span class="lineNum">  201</span>              :       using __rehash_state = typename __rehash_type::_State; </span>
<span class="lineNum">  202</span>              :  </span>
<span class="lineNum">  203</span>              :       using __traits_type = _Traits; </span>
<span class="lineNum">  204</span>              :       using __hash_cached = typename __traits_type::__hash_cached; </span>
<span class="lineNum">  205</span>              :       using __constant_iterators = typename __traits_type::__constant_iterators; </span>
<span class="lineNum">  206</span>              :       using __unique_keys = typename __traits_type::__unique_keys; </span>
<span class="lineNum">  207</span>              :  </span>
<span class="lineNum">  208</span>              :       using __key_extract = typename std::conditional&lt; </span>
<span class="lineNum">  209</span>              : 					     __constant_iterators::value, </span>
<span class="lineNum">  210</span>              : 				       	     __detail::_Identity, </span>
<span class="lineNum">  211</span>              : 					     __detail::_Select1st&gt;::type; </span>
<span class="lineNum">  212</span>              :  </span>
<span class="lineNum">  213</span>              :       using __hashtable_base = __detail:: </span>
<span class="lineNum">  214</span>              : 			       _Hashtable_base&lt;_Key, _Value, _ExtractKey, </span>
<span class="lineNum">  215</span>              : 					      _Equal, _H1, _H2, _Hash, _Traits&gt;; </span>
<span class="lineNum">  216</span>              :  </span>
<span class="lineNum">  217</span>              :       using __hash_code_base =  typename __hashtable_base::__hash_code_base; </span>
<span class="lineNum">  218</span>              :       using __hash_code =  typename __hashtable_base::__hash_code; </span>
<span class="lineNum">  219</span>              :       using __node_type = typename __hashtable_base::__node_type; </span>
<span class="lineNum">  220</span>              :       using __node_base = typename __hashtable_base::__node_base; </span>
<span class="lineNum">  221</span>              :       using __bucket_type = typename __hashtable_base::__bucket_type; </span>
<span class="lineNum">  222</span>              :       using __ireturn_type = typename __hashtable_base::__ireturn_type; </span>
<span class="lineNum">  223</span>              :       using __iconv_type = typename __hashtable_base::__iconv_type; </span>
<span class="lineNum">  224</span>              :  </span>
<span class="lineNum">  225</span>              :       using __map_base = __detail::_Map_base&lt;_Key, _Value, _Alloc, _ExtractKey, </span>
<span class="lineNum">  226</span>              : 					     _Equal, _H1, _H2, _Hash, </span>
<span class="lineNum">  227</span>              : 					     _RehashPolicy, _Traits&gt;; </span>
<span class="lineNum">  228</span>              :  </span>
<span class="lineNum">  229</span>              :       using __rehash_base = __detail::_Rehash_base&lt;_Key, _Value, _Alloc, </span>
<span class="lineNum">  230</span>              : 						   _ExtractKey, _Equal, </span>
<span class="lineNum">  231</span>              : 						   _H1, _H2, _Hash, </span>
<span class="lineNum">  232</span>              : 						   _RehashPolicy, _Traits&gt;; </span>
<span class="lineNum">  233</span>              :  </span>
<span class="lineNum">  234</span>              :       using __eq_base = __detail::_Equality&lt;_Key, _Value, _Alloc, _ExtractKey, </span>
<span class="lineNum">  235</span>              : 					    _Equal, _H1, _H2, _Hash, </span>
<span class="lineNum">  236</span>              : 					    _RehashPolicy, _Traits&gt;; </span>
<span class="lineNum">  237</span>              :  </span>
<span class="lineNum">  238</span>              :       &#047;&#047; Metaprogramming for picking apart hash caching. </span>
<span class="lineNum">  239</span>              :       using __hash_noexcept = __detail::__is_noexcept_hash&lt;_Key, _H1&gt;; </span>
<span class="lineNum">  240</span>              :  </span>
<span class="lineNum">  241</span>              :       template&lt;typename _Cond&gt; </span>
<span class="lineNum">  242</span>              : 	using __if_hash_cached = __or_&lt;__not_&lt;__hash_cached&gt;, _Cond&gt;; </span>
<span class="lineNum">  243</span>              :  </span>
<span class="lineNum">  244</span>              :       template&lt;typename _Cond&gt; </span>
<span class="lineNum">  245</span>              : 	using __if_hash_not_cached = __or_&lt;__hash_cached, _Cond&gt;; </span>
<span class="lineNum">  246</span>              :  </span>
<span class="lineNum">  247</span>              :       &#047;&#047; Compile-time diagnostics. </span>
<span class="lineNum">  248</span>              :  </span>
<span class="lineNum">  249</span>              :       &#047;&#047; When hash codes are not cached the hash functor shall not </span>
<span class="lineNum">  250</span>              :       &#047;&#047; throw because it is used in methods (erase, swap...) that </span>
<span class="lineNum">  251</span>              :       &#047;&#047; shall not throw. </span>
<span class="lineNum">  252</span>              :       static_assert(__if_hash_not_cached&lt;__hash_noexcept&gt;::value, </span>
<span class="lineNum">  253</span>              : 		    &quot;Cache the hash code&quot; </span>
<span class="lineNum">  254</span>              : 		    &quot; or qualify your hash functor with noexcept&quot;); </span>
<span class="lineNum">  255</span>              :  </span>
<span class="lineNum">  256</span>              :       &#047;&#047; Following two static assertions are necessary to guarantee </span>
<span class="lineNum">  257</span>              :       &#047;&#047; that local_iterator will be default constructible. </span>
<span class="lineNum">  258</span>              :  </span>
<span class="lineNum">  259</span>              :       &#047;&#047; When hash codes are cached local iterator inherits from H2 functor </span>
<span class="lineNum">  260</span>              :       &#047;&#047; which must then be default constructible. </span>
<span class="lineNum">  261</span>              :       static_assert(__if_hash_cached&lt;is_default_constructible&lt;_H2&gt;&gt;::value, </span>
<span class="lineNum">  262</span>              : 		    &quot;Functor used to map hash code to bucket index&quot; </span>
<span class="lineNum">  263</span>              : 		    &quot; must be default constructible&quot;); </span>
<span class="lineNum">  264</span>              :  </span>
<span class="lineNum">  265</span>              :       &#047;&#047; When hash codes are not cached local iterator inherits from </span>
<span class="lineNum">  266</span>              :       &#047;&#047; __hash_code_base above to compute node bucket index so it has to be </span>
<span class="lineNum">  267</span>              :       &#047;&#047; default constructible. </span>
<span class="lineNum">  268</span>              :       static_assert(__if_hash_not_cached&lt; </span>
<span class="lineNum">  269</span>              : 		    is_default_constructible&lt; </span>
<span class="lineNum">  270</span>              : 		      &#047;&#047; We use _Hashtable_ebo_helper to access the protected </span>
<span class="lineNum">  271</span>              : 		      &#047;&#047; default constructor. </span>
<span class="lineNum">  272</span>              : 		      __detail::_Hashtable_ebo_helper&lt;0, __hash_code_base&gt;&gt;&gt;::value, </span>
<span class="lineNum">  273</span>              : 		    &quot;Cache the hash code or make functors involved in hash code&quot; </span>
<span class="lineNum">  274</span>              : 		    &quot; and bucket index computation default constructible&quot;); </span>
<span class="lineNum">  275</span>              :  </span>
<span class="lineNum">  276</span>              :       &#047;&#047; When hash codes are not cached local iterator inherits from </span>
<span class="lineNum">  277</span>              :       &#047;&#047; __hash_code_base above to compute node bucket index so it has to be </span>
<span class="lineNum">  278</span>              :       &#047;&#047; assignable. </span>
<span class="lineNum">  279</span>              :       static_assert(__if_hash_not_cached&lt; </span>
<span class="lineNum">  280</span>              : 		      is_copy_assignable&lt;__hash_code_base&gt;&gt;::value, </span>
<span class="lineNum">  281</span>              : 		    &quot;Cache the hash code or make functors involved in hash code&quot; </span>
<span class="lineNum">  282</span>              : 		    &quot; and bucket index computation copy assignable&quot;); </span>
<span class="lineNum">  283</span>              :  </span>
<span class="lineNum">  284</span>              :     public: </span>
<span class="lineNum">  285</span>              :       template&lt;typename _Keya, typename _Valuea, typename _Alloca, </span>
<span class="lineNum">  286</span>              : 	       typename _ExtractKeya, typename _Equala, </span>
<span class="lineNum">  287</span>              : 	       typename _H1a, typename _H2a, typename _Hasha, </span>
<span class="lineNum">  288</span>              : 	       typename _RehashPolicya, typename _Traitsa, </span>
<span class="lineNum">  289</span>              : 	       bool _Unique_keysa&gt; </span>
<span class="lineNum">  290</span>              : 	friend struct __detail::_Map_base; </span>
<span class="lineNum">  291</span>              :  </span>
<span class="lineNum">  292</span>              :       template&lt;typename _Keya, typename _Valuea, typename _Alloca, </span>
<span class="lineNum">  293</span>              : 	       typename _ExtractKeya, typename _Equala, </span>
<span class="lineNum">  294</span>              : 	       typename _H1a, typename _H2a, typename _Hasha, </span>
<span class="lineNum">  295</span>              : 	       typename _RehashPolicya, typename _Traitsa&gt; </span>
<span class="lineNum">  296</span>              : 	friend struct __detail::_Insert_base; </span>
<span class="lineNum">  297</span>              :  </span>
<span class="lineNum">  298</span>              :       template&lt;typename _Keya, typename _Valuea, typename _Alloca, </span>
<span class="lineNum">  299</span>              : 	       typename _ExtractKeya, typename _Equala, </span>
<span class="lineNum">  300</span>              : 	       typename _H1a, typename _H2a, typename _Hasha, </span>
<span class="lineNum">  301</span>              : 	       typename _RehashPolicya, typename _Traitsa, </span>
<span class="lineNum">  302</span>              : 	       bool _Constant_iteratorsa, bool _Unique_keysa&gt; </span>
<span class="lineNum">  303</span>              : 	friend struct __detail::_Insert; </span>
<span class="lineNum">  304</span>              :  </span>
<span class="lineNum">  305</span>              :       using size_type = typename __hashtable_base::size_type; </span>
<span class="lineNum">  306</span>              :       using difference_type = typename __hashtable_base::difference_type; </span>
<span class="lineNum">  307</span>              :  </span>
<span class="lineNum">  308</span>              :       using iterator = typename __hashtable_base::iterator; </span>
<span class="lineNum">  309</span>              :       using const_iterator = typename __hashtable_base::const_iterator; </span>
<span class="lineNum">  310</span>              :  </span>
<span class="lineNum">  311</span>              :       using local_iterator = typename __hashtable_base::local_iterator; </span>
<span class="lineNum">  312</span>              :       using const_local_iterator = typename __hashtable_base:: </span>
<span class="lineNum">  313</span>              : 				   const_local_iterator; </span>
<span class="lineNum">  314</span>              :  </span>
<span class="lineNum">  315</span>              :     private: </span>
<span class="lineNum">  316</span>              :       typedef typename _Alloc::template rebind&lt;__node_type&gt;::other </span>
<span class="lineNum">  317</span>              : 							_Node_allocator_type; </span>
<span class="lineNum">  318</span>              :       typedef typename _Alloc::template rebind&lt;__bucket_type&gt;::other </span>
<span class="lineNum">  319</span>              : 							_Bucket_allocator_type; </span>
<span class="lineNum">  320</span>              :  </span>
<span class="lineNum">  321</span>              :       using __before_begin = __detail::_Before_begin&lt;_Node_allocator_type&gt;; </span>
<span class="lineNum">  322</span>              :  </span>
<span class="lineNum">  323</span>              :       __bucket_type*		_M_buckets; </span>
<span class="lineNum">  324</span>              :       size_type			_M_bucket_count; </span>
<span class="lineNum">  325</span>              :       __before_begin		_M_bbegin; </span>
<span class="lineNum">  326</span>              :       size_type			_M_element_count; </span>
<span class="lineNum">  327</span>              :       _RehashPolicy		_M_rehash_policy; </span>
<span class="lineNum">  328</span>              :  </span>
<span class="lineNum">  329</span>              :       _Node_allocator_type&amp; </span>
<span class="lineNum">  330</span><span class="lineCov">     10  /  10:       _M_node_allocator() </span>
<span class="lineNum">  331</span><span class="linePartCov">     10  /  20:       { return _M_bbegin; } </span>
<span class="lineNum">  332</span>              :  </span>
<span class="lineNum">  333</span>              :       const _Node_allocator_type&amp; </span>
<span class="lineNum">  334</span>              :       _M_node_allocator() const </span>
<span class="lineNum">  335</span>              :       { return _M_bbegin; } </span>
<span class="lineNum">  336</span>              :  </span>
<span class="lineNum">  337</span>              :       __node_base&amp; </span>
<span class="lineNum">  338</span><span class="lineCov">     10  /  10:       _M_before_begin() </span>
<span class="lineNum">  339</span><span class="linePartCov">     10  /  20:       { return _M_bbegin._M_node; } </span>
<span class="lineNum">  340</span>              :  </span>
<span class="lineNum">  341</span>              :       const __node_base&amp; </span>
<span class="lineNum">  342</span><span class="lineCov">     10  /  10:       _M_before_begin() const </span>
<span class="lineNum">  343</span><span class="linePartCov">     11  /  20:       { return _M_bbegin._M_node; } </span>
<span class="lineNum">  344</span>              :  </span>
<span class="lineNum">  345</span>              :       template&lt;typename... _Args&gt; </span>
<span class="lineNum">  346</span>              : 	__node_type* </span>
<span class="lineNum">  347</span>              : 	_M_allocate_node(_Args&amp;&amp;... __args); </span>
<span class="lineNum">  348</span>              :  </span>
<span class="lineNum">  349</span>              :       void </span>
<span class="lineNum">  350</span>              :       _M_deallocate_node(__node_type* __n); </span>
<span class="lineNum">  351</span>              :  </span>
<span class="lineNum">  352</span>              :       &#047;&#047; Deallocate the linked list of nodes pointed to by __n </span>
<span class="lineNum">  353</span>              :       void </span>
<span class="lineNum">  354</span>              :       _M_deallocate_nodes(__node_type* __n); </span>
<span class="lineNum">  355</span>              :  </span>
<span class="lineNum">  356</span>              :       __bucket_type* </span>
<span class="lineNum">  357</span>              :       _M_allocate_buckets(size_type __n); </span>
<span class="lineNum">  358</span>              :  </span>
<span class="lineNum">  359</span>              :       void </span>
<span class="lineNum">  360</span>              :       _M_deallocate_buckets(__bucket_type*, size_type __n); </span>
<span class="lineNum">  361</span>              :  </span>
<span class="lineNum">  362</span>              :       &#047;&#047; Gets bucket begin, deals with the fact that non-empty buckets contain </span>
<span class="lineNum">  363</span>              :       &#047;&#047; their before begin node. </span>
<span class="lineNum">  364</span>              :       __node_type* </span>
<span class="lineNum">  365</span>              :       _M_bucket_begin(size_type __bkt) const; </span>
<span class="lineNum">  366</span>              :  </span>
<span class="lineNum">  367</span>              :       __node_type* </span>
<span class="lineNum">  368</span><span class="lineCov">     10  /  10:       _M_begin() const </span>
<span class="lineNum">  369</span><span class="linePartCov">     10  /  20:       { return static_cast&lt;__node_type*&gt;(_M_before_begin()._M_nxt); } </span>
<span class="lineNum">  370</span>              :  </span>
<span class="lineNum">  371</span>              :     public: </span>
<span class="lineNum">  372</span>              :       &#047;&#047; Constructor, destructor, assignment, swap </span>
<span class="lineNum">  373</span>              :       _Hashtable(size_type __bucket_hint, </span>
<span class="lineNum">  374</span>              : 		 const _H1&amp;, const _H2&amp;, const _Hash&amp;, </span>
<span class="lineNum">  375</span>              : 		 const _Equal&amp;, const _ExtractKey&amp;, </span>
<span class="lineNum">  376</span>              : 		 const allocator_type&amp;); </span>
<span class="lineNum">  377</span>              :  </span>
<span class="lineNum">  378</span>              :       template&lt;typename _InputIterator&gt; </span>
<span class="lineNum">  379</span>              : 	_Hashtable(_InputIterator __first, _InputIterator __last, </span>
<span class="lineNum">  380</span>              : 		   size_type __bucket_hint, </span>
<span class="lineNum">  381</span>              : 		   const _H1&amp;, const _H2&amp;, const _Hash&amp;, </span>
<span class="lineNum">  382</span>              : 		   const _Equal&amp;, const _ExtractKey&amp;, </span>
<span class="lineNum">  383</span>              : 		   const allocator_type&amp;); </span>
<span class="lineNum">  384</span>              :  </span>
<span class="lineNum">  385</span>              :       _Hashtable(const _Hashtable&amp;); </span>
<span class="lineNum">  386</span>              :  </span>
<span class="lineNum">  387</span>              :       _Hashtable(_Hashtable&amp;&amp;); </span>
<span class="lineNum">  388</span>              :  </span>
<span class="lineNum">  389</span>              :       &#047;&#047; Use delegating constructors. </span>
<span class="lineNum">  390</span>              :       explicit </span>
<span class="lineNum">  391</span><span class="lineCov">     10  /  10:       _Hashtable(size_type __n = 10, </span>
<span class="lineNum">  392</span>              : 		 const _H1&amp; __hf = _H1(), </span>
<span class="lineNum">  393</span>              : 		 const key_equal&amp; __eql = key_equal(), </span>
<span class="lineNum">  394</span>              : 		 const allocator_type&amp; __a = allocator_type()) </span>
<span class="lineNum">  395</span>              :       : _Hashtable(__n, __hf, __detail::_Mod_range_hashing(), </span>
<span class="lineNum">  396</span>              : 		   __detail::_Default_ranged_hash(), __eql, </span>
<span class="lineNum">  397</span><span class="lineCov">     10  /  10: 		   __key_extract(), __a) </span>
<span class="lineNum">  398</span><span class="linePartCov">     10  /  20:       { } </span>
<span class="lineNum">  399</span>              :  </span>
<span class="lineNum">  400</span>              :       template&lt;typename _InputIterator&gt; </span>
<span class="lineNum">  401</span>              : 	_Hashtable(_InputIterator __f, _InputIterator __l, </span>
<span class="lineNum">  402</span>              : 		   size_type __n = 0, </span>
<span class="lineNum">  403</span>              : 		   const _H1&amp; __hf = _H1(), </span>
<span class="lineNum">  404</span>              : 		   const key_equal&amp; __eql = key_equal(), </span>
<span class="lineNum">  405</span>              : 		   const allocator_type&amp; __a = allocator_type()) </span>
<span class="lineNum">  406</span>              : 	: _Hashtable(__f, __l, __n, __hf, __detail::_Mod_range_hashing(), </span>
<span class="lineNum">  407</span>              : 		     __detail::_Default_ranged_hash(), __eql, </span>
<span class="lineNum">  408</span>              : 		     __key_extract(), __a) </span>
<span class="lineNum">  409</span>              : 	{ } </span>
<span class="lineNum">  410</span>              :  </span>
<span class="lineNum">  411</span>              :       _Hashtable(initializer_list&lt;value_type&gt; __l, </span>
<span class="lineNum">  412</span>              : 		 size_type __n = 0, </span>
<span class="lineNum">  413</span>              : 		 const _H1&amp; __hf = _H1(), </span>
<span class="lineNum">  414</span>              : 		 const key_equal&amp; __eql = key_equal(), </span>
<span class="lineNum">  415</span>              : 		 const allocator_type&amp; __a = allocator_type()) </span>
<span class="lineNum">  416</span>              :       : _Hashtable(__l.begin(), __l.end(), __n, __hf, </span>
<span class="lineNum">  417</span>              : 		   __detail::_Mod_range_hashing(), </span>
<span class="lineNum">  418</span>              : 		   __detail::_Default_ranged_hash(), __eql, </span>
<span class="lineNum">  419</span>              : 		   __key_extract(), __a) </span>
<span class="lineNum">  420</span>              :       { } </span>
<span class="lineNum">  421</span>              :  </span>
<span class="lineNum">  422</span>              :       _Hashtable&amp; </span>
<span class="lineNum">  423</span>              :       operator=(const _Hashtable&amp; __ht) </span>
<span class="lineNum">  424</span>              :       { </span>
<span class="lineNum">  425</span>              : 	_Hashtable __tmp(__ht); </span>
<span class="lineNum">  426</span>              : 	this-&gt;swap(__tmp); </span>
<span class="lineNum">  427</span>              : 	return *this; </span>
<span class="lineNum">  428</span>              :       } </span>
<span class="lineNum">  429</span>              :  </span>
<span class="lineNum">  430</span>              :       _Hashtable&amp; </span>
<span class="lineNum">  431</span>              :       operator=(_Hashtable&amp;&amp; __ht) </span>
<span class="lineNum">  432</span>              :       { </span>
<span class="lineNum">  433</span>              : 	&#047;&#047; NB: DR 1204. </span>
<span class="lineNum">  434</span>              : 	&#047;&#047; NB: DR 675. </span>
<span class="lineNum">  435</span>              : 	this-&gt;clear(); </span>
<span class="lineNum">  436</span>              : 	this-&gt;swap(__ht); </span>
<span class="lineNum">  437</span>              : 	return *this; </span>
<span class="lineNum">  438</span>              :       } </span>
<span class="lineNum">  439</span>              :  </span>
<span class="lineNum">  440</span>              :       _Hashtable&amp; </span>
<span class="lineNum">  441</span>              :       operator=(initializer_list&lt;value_type&gt; __l) </span>
<span class="lineNum">  442</span>              :       { </span>
<span class="lineNum">  443</span>              : 	this-&gt;clear(); </span>
<span class="lineNum">  444</span>              : 	this-&gt;insert(__l.begin(), __l.end()); </span>
<span class="lineNum">  445</span>              : 	return *this; </span>
<span class="lineNum">  446</span>              :       } </span>
<span class="lineNum">  447</span>              :  </span>
<span class="lineNum">  448</span>              :       ~_Hashtable() noexcept; </span>
<span class="lineNum">  449</span>              :  </span>
<span class="lineNum">  450</span>              :       void swap(_Hashtable&amp;); </span>
<span class="lineNum">  451</span>              :  </span>
<span class="lineNum">  452</span>              :       &#047;&#047; Basic container operations </span>
<span class="lineNum">  453</span>              :       iterator </span>
<span class="lineNum">  454</span><span class="linePartCov">      3  /   4:       begin() noexcept </span>
<span class="lineNum">  455</span><span class="linePartCov">      3  /   8:       { return iterator(_M_begin()); } </span>
<span class="lineNum">  456</span>              :  </span>
<span class="lineNum">  457</span>              :       const_iterator </span>
<span class="lineNum">  458</span>              :       begin() const noexcept </span>
<span class="lineNum">  459</span>              :       { return const_iterator(_M_begin()); } </span>
<span class="lineNum">  460</span>              :  </span>
<span class="lineNum">  461</span>              :       iterator </span>
<span class="lineNum">  462</span><span class="linePartCov">      5  /   8:       end() noexcept </span>
<span class="lineNum">  463</span><span class="linePartCov">      5  /  16:       { return iterator(nullptr); } </span>
<span class="lineNum">  464</span>              :  </span>
<span class="lineNum">  465</span>              :       const_iterator </span>
<span class="lineNum">  466</span>              :       end() const noexcept </span>
<span class="lineNum">  467</span>              :       { return const_iterator(nullptr); } </span>
<span class="lineNum">  468</span>              :  </span>
<span class="lineNum">  469</span>              :       const_iterator </span>
<span class="lineNum">  470</span>              :       cbegin() const noexcept </span>
<span class="lineNum">  471</span>              :       { return const_iterator(_M_begin()); } </span>
<span class="lineNum">  472</span>              :  </span>
<span class="lineNum">  473</span>              :       const_iterator </span>
<span class="lineNum">  474</span>              :       cend() const noexcept </span>
<span class="lineNum">  475</span>              :       { return const_iterator(nullptr); } </span>
<span class="lineNum">  476</span>              :  </span>
<span class="lineNum">  477</span>              :       size_type </span>
<span class="lineNum">  478</span><span class="linePartCov">      1  /   2:       size() const noexcept </span>
<span class="lineNum">  479</span><span class="linePartCov">      1  /   4:       { return _M_element_count; } </span>
<span class="lineNum">  480</span>              :  </span>
<span class="lineNum">  481</span>              :       bool </span>
<span class="lineNum">  482</span>              :       empty() const noexcept </span>
<span class="lineNum">  483</span>              :       { return size() == 0; } </span>
<span class="lineNum">  484</span>              :  </span>
<span class="lineNum">  485</span>              :       allocator_type </span>
<span class="lineNum">  486</span>              :       get_allocator() const noexcept </span>
<span class="lineNum">  487</span>              :       { return allocator_type(_M_node_allocator()); } </span>
<span class="lineNum">  488</span>              :  </span>
<span class="lineNum">  489</span>              :       size_type </span>
<span class="lineNum">  490</span>              :       max_size() const noexcept </span>
<span class="lineNum">  491</span>              :       { return _M_node_allocator().max_size(); } </span>
<span class="lineNum">  492</span>              :  </span>
<span class="lineNum">  493</span>              :       &#047;&#047; Observers </span>
<span class="lineNum">  494</span>              :       key_equal </span>
<span class="lineNum">  495</span>              :       key_eq() const </span>
<span class="lineNum">  496</span>              :       { return this-&gt;_M_eq(); } </span>
<span class="lineNum">  497</span>              :  </span>
<span class="lineNum">  498</span>              :       &#047;&#047; hash_function, if present, comes from _Hash_code_base. </span>
<span class="lineNum">  499</span>              :  </span>
<span class="lineNum">  500</span>              :       &#047;&#047; Bucket operations </span>
<span class="lineNum">  501</span>              :       size_type </span>
<span class="lineNum">  502</span>              :       bucket_count() const noexcept </span>
<span class="lineNum">  503</span>              :       { return _M_bucket_count; } </span>
<span class="lineNum">  504</span>              :  </span>
<span class="lineNum">  505</span>              :       size_type </span>
<span class="lineNum">  506</span>              :       max_bucket_count() const noexcept </span>
<span class="lineNum">  507</span>              :       { return max_size(); } </span>
<span class="lineNum">  508</span>              :  </span>
<span class="lineNum">  509</span>              :       size_type </span>
<span class="lineNum">  510</span>              :       bucket_size(size_type __n) const </span>
<span class="lineNum">  511</span>              :       { return std::distance(begin(__n), end(__n)); } </span>
<span class="lineNum">  512</span>              :  </span>
<span class="lineNum">  513</span>              :       size_type </span>
<span class="lineNum">  514</span>              :       bucket(const key_type&amp; __k) const </span>
<span class="lineNum">  515</span>              :       { return _M_bucket_index(__k, this-&gt;_M_hash_code(__k)); } </span>
<span class="lineNum">  516</span>              :  </span>
<span class="lineNum">  517</span>              :       local_iterator </span>
<span class="lineNum">  518</span>              :       begin(size_type __n) </span>
<span class="lineNum">  519</span>              :       { </span>
<span class="lineNum">  520</span>              : 	return local_iterator(*this, _M_bucket_begin(__n), </span>
<span class="lineNum">  521</span>              : 			      __n, _M_bucket_count); </span>
<span class="lineNum">  522</span>              :       } </span>
<span class="lineNum">  523</span>              :  </span>
<span class="lineNum">  524</span>              :       local_iterator </span>
<span class="lineNum">  525</span>              :       end(size_type __n) </span>
<span class="lineNum">  526</span>              :       { return local_iterator(*this, nullptr, __n, _M_bucket_count); } </span>
<span class="lineNum">  527</span>              :  </span>
<span class="lineNum">  528</span>              :       const_local_iterator </span>
<span class="lineNum">  529</span>              :       begin(size_type __n) const </span>
<span class="lineNum">  530</span>              :       { </span>
<span class="lineNum">  531</span>              : 	return const_local_iterator(*this, _M_bucket_begin(__n), </span>
<span class="lineNum">  532</span>              : 				    __n, _M_bucket_count); </span>
<span class="lineNum">  533</span>              :       } </span>
<span class="lineNum">  534</span>              :  </span>
<span class="lineNum">  535</span>              :       const_local_iterator </span>
<span class="lineNum">  536</span>              :       end(size_type __n) const </span>
<span class="lineNum">  537</span>              :       { return const_local_iterator(*this, nullptr, __n, _M_bucket_count); } </span>
<span class="lineNum">  538</span>              :  </span>
<span class="lineNum">  539</span>              :       &#047;&#047; DR 691. </span>
<span class="lineNum">  540</span>              :       const_local_iterator </span>
<span class="lineNum">  541</span>              :       cbegin(size_type __n) const </span>
<span class="lineNum">  542</span>              :       { </span>
<span class="lineNum">  543</span>              : 	return const_local_iterator(*this, _M_bucket_begin(__n), </span>
<span class="lineNum">  544</span>              : 				    __n, _M_bucket_count); </span>
<span class="lineNum">  545</span>              :       } </span>
<span class="lineNum">  546</span>              :  </span>
<span class="lineNum">  547</span>              :       const_local_iterator </span>
<span class="lineNum">  548</span>              :       cend(size_type __n) const </span>
<span class="lineNum">  549</span>              :       { return const_local_iterator(*this, nullptr, __n, _M_bucket_count); } </span>
<span class="lineNum">  550</span>              :  </span>
<span class="lineNum">  551</span>              :       float </span>
<span class="lineNum">  552</span>              :       load_factor() const noexcept </span>
<span class="lineNum">  553</span>              :       { </span>
<span class="lineNum">  554</span>              : 	return static_cast&lt;float&gt;(size()) &#047; static_cast&lt;float&gt;(bucket_count()); </span>
<span class="lineNum">  555</span>              :       } </span>
<span class="lineNum">  556</span>              :  </span>
<span class="lineNum">  557</span>              :       &#047;&#047; max_load_factor, if present, comes from _Rehash_base. </span>
<span class="lineNum">  558</span>              :  </span>
<span class="lineNum">  559</span>              :       &#047;&#047; Generalization of max_load_factor.  Extension, not found in </span>
<span class="lineNum">  560</span>              :       &#047;&#047; TR1.  Only useful if _RehashPolicy is something other than </span>
<span class="lineNum">  561</span>              :       &#047;&#047; the default. </span>
<span class="lineNum">  562</span>              :       const _RehashPolicy&amp; </span>
<span class="lineNum">  563</span>              :       __rehash_policy() const </span>
<span class="lineNum">  564</span>              :       { return _M_rehash_policy; } </span>
<span class="lineNum">  565</span>              :  </span>
<span class="lineNum">  566</span>              :       void </span>
<span class="lineNum">  567</span>              :       __rehash_policy(const _RehashPolicy&amp;); </span>
<span class="lineNum">  568</span>              :  </span>
<span class="lineNum">  569</span>              :       &#047;&#047; Lookup. </span>
<span class="lineNum">  570</span>              :       iterator </span>
<span class="lineNum">  571</span>              :       find(const key_type&amp; __k); </span>
<span class="lineNum">  572</span>              :  </span>
<span class="lineNum">  573</span>              :       const_iterator </span>
<span class="lineNum">  574</span>              :       find(const key_type&amp; __k) const; </span>
<span class="lineNum">  575</span>              :  </span>
<span class="lineNum">  576</span>              :       size_type </span>
<span class="lineNum">  577</span>              :       count(const key_type&amp; __k) const; </span>
<span class="lineNum">  578</span>              :  </span>
<span class="lineNum">  579</span>              :       std::pair&lt;iterator, iterator&gt; </span>
<span class="lineNum">  580</span>              :       equal_range(const key_type&amp; __k); </span>
<span class="lineNum">  581</span>              :  </span>
<span class="lineNum">  582</span>              :       std::pair&lt;const_iterator, const_iterator&gt; </span>
<span class="lineNum">  583</span>              :       equal_range(const key_type&amp; __k) const; </span>
<span class="lineNum">  584</span>              :  </span>
<span class="lineNum">  585</span>              :     protected: </span>
<span class="lineNum">  586</span>              :       &#047;&#047; Bucket index computation helpers. </span>
<span class="lineNum">  587</span>              :       size_type </span>
<span class="lineNum">  588</span><span class="linePartCov">      7  /  10:       _M_bucket_index(__node_type* __n) const </span>
<span class="lineNum">  589</span><span class="linePartCov">      7  /  20:       { return __hash_code_base::_M_bucket_index(__n, _M_bucket_count); } </span>
<span class="lineNum">  590</span>              :  </span>
<span class="lineNum">  591</span>              :       size_type </span>
<span class="lineNum">  592</span><span class="linePartCov">      7  /  10:       _M_bucket_index(const key_type&amp; __k, __hash_code __c) const </span>
<span class="lineNum">  593</span><span class="linePartCov">      7  /  20:       { return __hash_code_base::_M_bucket_index(__k, __c, _M_bucket_count); } </span>
<span class="lineNum">  594</span>              :  </span>
<span class="lineNum">  595</span>              :       &#047;&#047; Find and insert helper functions and types </span>
<span class="lineNum">  596</span>              :       &#047;&#047; Find the node before the one matching the criteria. </span>
<span class="lineNum">  597</span>              :       __node_base* </span>
<span class="lineNum">  598</span>              :       _M_find_before_node(size_type, const key_type&amp;, __hash_code) const; </span>
<span class="lineNum">  599</span>              :  </span>
<span class="lineNum">  600</span>              :       __node_type* </span>
<span class="lineNum">  601</span><span class="linePartCov">      7  /  10:       _M_find_node(size_type __bkt, const key_type&amp; __key, </span>
<span class="lineNum">  602</span>              : 		   __hash_code __c) const </span>
<span class="lineNum">  603</span>              :       { </span>
<span class="lineNum">  604</span><span class="linePartCov">      7  /  10: 	__node_base* __before_n = _M_find_before_node(__bkt, __key, __c); </span>
<span class="lineNum">  605</span><span class="linePartCov">      7  /  10: 	if (__before_n) </span>
<span class="lineNum">  606</span><span class="linePartCov">      7  /  10: 	  return static_cast&lt;__node_type*&gt;(__before_n-&gt;_M_nxt); </span>
<span class="lineNum">  607</span><span class="linePartCov">      7  /  10: 	return nullptr; </span>
<span class="lineNum">  608</span><span class="linePartCov">      7  /  20:       } </span>
<span class="lineNum">  609</span>              :  </span>
<span class="lineNum">  610</span>              :       &#047;&#047; Insert a node at the beginning of a bucket. </span>
<span class="lineNum">  611</span>              :       void </span>
<span class="lineNum">  612</span>              :       _M_insert_bucket_begin(size_type, __node_type*); </span>
<span class="lineNum">  613</span>              :  </span>
<span class="lineNum">  614</span>              :       &#047;&#047; Remove the bucket first node </span>
<span class="lineNum">  615</span>              :       void </span>
<span class="lineNum">  616</span>              :       _M_remove_bucket_begin(size_type __bkt, __node_type* __next_n, </span>
<span class="lineNum">  617</span>              : 			     size_type __next_bkt); </span>
<span class="lineNum">  618</span>              :  </span>
<span class="lineNum">  619</span>              :       &#047;&#047; Get the node before __n in the bucket __bkt </span>
<span class="lineNum">  620</span>              :       __node_base* </span>
<span class="lineNum">  621</span>              :       _M_get_previous_node(size_type __bkt, __node_base* __n); </span>
<span class="lineNum">  622</span>              :  </span>
<span class="lineNum">  623</span>              :       &#047;&#047; Insert node with hash code __code, in bucket bkt if no rehash (assumes </span>
<span class="lineNum">  624</span>              :       &#047;&#047; no element with its key already present). Take ownership of the node, </span>
<span class="lineNum">  625</span>              :       &#047;&#047; deallocate it on exception. </span>
<span class="lineNum">  626</span>              :       iterator </span>
<span class="lineNum">  627</span>              :       _M_insert_unique_node(size_type __bkt, __hash_code __code, </span>
<span class="lineNum">  628</span>              : 			    __node_type* __n); </span>
<span class="lineNum">  629</span>              :  </span>
<span class="lineNum">  630</span>              :       &#047;&#047; Insert node with hash code __code. Take ownership of the node, </span>
<span class="lineNum">  631</span>              :       &#047;&#047; deallocate it on exception. </span>
<span class="lineNum">  632</span>              :       iterator </span>
<span class="lineNum">  633</span>              :       _M_insert_multi_node(__hash_code __code, __node_type* __n); </span>
<span class="lineNum">  634</span>              :  </span>
<span class="lineNum">  635</span>              :       template&lt;typename... _Args&gt; </span>
<span class="lineNum">  636</span>              : 	std::pair&lt;iterator, bool&gt; </span>
<span class="lineNum">  637</span>              : 	_M_emplace(std::true_type, _Args&amp;&amp;... __args); </span>
<span class="lineNum">  638</span>              :  </span>
<span class="lineNum">  639</span>              :       template&lt;typename... _Args&gt; </span>
<span class="lineNum">  640</span>              : 	iterator </span>
<span class="lineNum">  641</span>              : 	_M_emplace(std::false_type, _Args&amp;&amp;... __args); </span>
<span class="lineNum">  642</span>              :  </span>
<span class="lineNum">  643</span>              :       template&lt;typename _Arg&gt; </span>
<span class="lineNum">  644</span>              : 	std::pair&lt;iterator, bool&gt; </span>
<span class="lineNum">  645</span>              : 	_M_insert(_Arg&amp;&amp;, std::true_type); </span>
<span class="lineNum">  646</span>              :  </span>
<span class="lineNum">  647</span>              :       template&lt;typename _Arg&gt; </span>
<span class="lineNum">  648</span>              : 	iterator </span>
<span class="lineNum">  649</span>              : 	_M_insert(_Arg&amp;&amp;, std::false_type); </span>
<span class="lineNum">  650</span>              :  </span>
<span class="lineNum">  651</span>              :       size_type </span>
<span class="lineNum">  652</span>              :       _M_erase(std::true_type, const key_type&amp;); </span>
<span class="lineNum">  653</span>              :  </span>
<span class="lineNum">  654</span>              :       size_type </span>
<span class="lineNum">  655</span>              :       _M_erase(std::false_type, const key_type&amp;); </span>
<span class="lineNum">  656</span>              :  </span>
<span class="lineNum">  657</span>              :       iterator </span>
<span class="lineNum">  658</span>              :       _M_erase(size_type __bkt, __node_base* __prev_n, __node_type* __n); </span>
<span class="lineNum">  659</span>              :  </span>
<span class="lineNum">  660</span>              :     public: </span>
<span class="lineNum">  661</span>              :       &#047;&#047; Emplace </span>
<span class="lineNum">  662</span>              :       template&lt;typename... _Args&gt; </span>
<span class="lineNum">  663</span>              : 	__ireturn_type </span>
<span class="lineNum">  664</span>              : 	emplace(_Args&amp;&amp;... __args) </span>
<span class="lineNum">  665</span>              : 	{ return _M_emplace(__unique_keys(), std::forward&lt;_Args&gt;(__args)...); } </span>
<span class="lineNum">  666</span>              :  </span>
<span class="lineNum">  667</span>              :       template&lt;typename... _Args&gt; </span>
<span class="lineNum">  668</span>              : 	iterator </span>
<span class="lineNum">  669</span>              : 	emplace_hint(const_iterator, _Args&amp;&amp;... __args) </span>
<span class="lineNum">  670</span>              : 	{ return __iconv_type()(emplace(std::forward&lt;_Args&gt;(__args)...)); } </span>
<span class="lineNum">  671</span>              :  </span>
<span class="lineNum">  672</span>              :       &#047;&#047; Insert member functions via inheritance. </span>
<span class="lineNum">  673</span>              :  </span>
<span class="lineNum">  674</span>              :       &#047;&#047; Erase </span>
<span class="lineNum">  675</span>              :       iterator </span>
<span class="lineNum">  676</span>              :       erase(const_iterator); </span>
<span class="lineNum">  677</span>              :  </span>
<span class="lineNum">  678</span>              :       &#047;&#047; LWG 2059. </span>
<span class="lineNum">  679</span>              :       iterator </span>
<span class="lineNum">  680</span>              :       erase(iterator __it) </span>
<span class="lineNum">  681</span>              :       { return erase(const_iterator(__it)); } </span>
<span class="lineNum">  682</span>              :  </span>
<span class="lineNum">  683</span>              :       size_type </span>
<span class="lineNum">  684</span><span class="lineNoCov">      0  /   1:       erase(const key_type&amp; __k) </span>
<span class="lineNum">  685</span><span class="lineNoCov">      0  /   2:       { return _M_erase(__unique_keys(), __k); } </span>
<span class="lineNum">  686</span>              :  </span>
<span class="lineNum">  687</span>              :       iterator </span>
<span class="lineNum">  688</span>              :       erase(const_iterator, const_iterator); </span>
<span class="lineNum">  689</span>              :  </span>
<span class="lineNum">  690</span>              :       void </span>
<span class="lineNum">  691</span>              :       clear() noexcept; </span>
<span class="lineNum">  692</span>              :  </span>
<span class="lineNum">  693</span>              :       &#047;&#047; Set number of buckets to be appropriate for container of n element. </span>
<span class="lineNum">  694</span>              :       void rehash(size_type __n); </span>
<span class="lineNum">  695</span>              :  </span>
<span class="lineNum">  696</span>              :       &#047;&#047; DR 1189. </span>
<span class="lineNum">  697</span>              :       &#047;&#047; reserve, if present, comes from _Rehash_base. </span>
<span class="lineNum">  698</span>              :  </span>
<span class="lineNum">  699</span>              :     private: </span>
<span class="lineNum">  700</span>              :       &#047;&#047; Helper rehash method used when keys are unique. </span>
<span class="lineNum">  701</span>              :       void _M_rehash_aux(size_type __n, std::true_type); </span>
<span class="lineNum">  702</span>              :  </span>
<span class="lineNum">  703</span>              :       &#047;&#047; Helper rehash method used when keys can be non-unique. </span>
<span class="lineNum">  704</span>              :       void _M_rehash_aux(size_type __n, std::false_type); </span>
<span class="lineNum">  705</span>              :  </span>
<span class="lineNum">  706</span>              :       &#047;&#047; Unconditionally change size of bucket array to n, restore </span>
<span class="lineNum">  707</span>              :       &#047;&#047; hash policy state to __state on exception. </span>
<span class="lineNum">  708</span>              :       void _M_rehash(size_type __n, const __rehash_state&amp; __state); </span>
<span class="lineNum">  709</span>              :     }; </span>
<span class="lineNum">  710</span>              :  </span>
<span class="lineNum">  711</span>              :  </span>
<span class="lineNum">  712</span>              :   &#047;&#047; Definitions of class template _Hashtable&#039;s out-of-line member functions. </span>
<span class="lineNum">  713</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum">  714</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum">  715</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum">  716</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum">  717</span>              :     template&lt;typename... _Args&gt; </span>
<span class="lineNum">  718</span>              :       typename _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum">  719</span>              : 			  _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;::__node_type* </span>
<span class="lineNum">  720</span><span class="linePartCov">      6  /  10:       _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum">  721</span>              : 		 _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum">  722</span>              :       _M_allocate_node(_Args&amp;&amp;... __args) </span>
<span class="lineNum">  723</span>              :       { </span>
<span class="lineNum">  724</span><span class="linePartCov">      7  /  10: 	__node_type* __n = _M_node_allocator().allocate(1); </span>
<span class="lineNum">  725</span>              : 	__try </span>
<span class="lineNum">  726</span>              : 	  { </span>
<span class="lineNum">  727</span><span class="linePartCov">      7  /  10: 	    _M_node_allocator().construct(__n, std::forward&lt;_Args&gt;(__args)...); </span>
<span class="lineNum">  728</span><span class="linePartCov">      7  /  10: 	    return __n; </span>
<span class="lineNum">  729</span>              : 	  } </span>
<span class="lineNum">  730</span><span class="lineNoCov">      0  /  10: 	__catch(...) </span>
<span class="lineNum">  731</span>              : 	  { </span>
<span class="lineNum">  732</span><span class="lineNoCov">      0  /  10: 	    _M_node_allocator().deallocate(__n, 1); </span>
<span class="lineNum">  733</span><span class="lineNoCov">      0  /  10: 	    __throw_exception_again; </span>
<span class="lineNum">  734</span>              : 	  } </span>
<span class="lineNum">  735</span><span class="linePartCov">      7  /  20:       } </span>
<span class="lineNum">  736</span>              :  </span>
<span class="lineNum">  737</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum">  738</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum">  739</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum">  740</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum">  741</span>              :     void </span>
<span class="lineNum">  742</span><span class="linePartCov">      2  /  10:     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum">  743</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum">  744</span>              :     _M_deallocate_node(__node_type* __n) </span>
<span class="lineNum">  745</span>              :     { </span>
<span class="lineNum">  746</span><span class="linePartCov">      2  /  10:       _M_node_allocator().destroy(__n); </span>
<span class="lineNum">  747</span><span class="linePartCov">      2  /  10:       _M_node_allocator().deallocate(__n, 1); </span>
<span class="lineNum">  748</span><span class="linePartCov">      2  /  20:     } </span>
<span class="lineNum">  749</span>              :  </span>
<span class="lineNum">  750</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum">  751</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum">  752</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum">  753</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum">  754</span>              :     void </span>
<span class="lineNum">  755</span><span class="linePartCov">      5  /  10:     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum">  756</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum">  757</span>              :     _M_deallocate_nodes(__node_type* __n) </span>
<span class="lineNum">  758</span>              :     { </span>
<span class="lineNum">  759</span><span class="linePartCov">     12  /  20:       while (__n) </span>
<span class="lineNum">  760</span>              : 	{ </span>
<span class="lineNum">  761</span><span class="linePartCov">      2  /  10: 	  __node_type* __tmp = __n; </span>
<span class="lineNum">  762</span><span class="linePartCov">      2  /  10: 	  __n = __n-&gt;_M_next(); </span>
<span class="lineNum">  763</span><span class="linePartCov">      2  /  10: 	  _M_deallocate_node(__tmp); </span>
<span class="lineNum">  764</span>              : 	} </span>
<span class="lineNum">  765</span><span class="linePartCov">      6  /  20:     } </span>
<span class="lineNum">  766</span>              :  </span>
<span class="lineNum">  767</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum">  768</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum">  769</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum">  770</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum">  771</span>              :     typename _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum">  772</span>              : 			_H1, _H2, _Hash, _RehashPolicy, _Traits&gt;::__bucket_type* </span>
<span class="lineNum">  773</span><span class="lineCov">     10  /  10:     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum">  774</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum">  775</span>              :     _M_allocate_buckets(size_type __n) </span>
<span class="lineNum">  776</span>              :     { </span>
<span class="lineNum">  777</span><span class="lineCov">     10  /  10:       _Bucket_allocator_type __alloc(_M_node_allocator()); </span>
<span class="lineNum">  778</span>              :  </span>
<span class="lineNum">  779</span><span class="lineCov">     10  /  10:       __bucket_type* __p = __alloc.allocate(__n); </span>
<span class="lineNum">  780</span><span class="lineCov">     10  /  10:       __builtin_memset(__p, 0, __n * sizeof(__bucket_type)); </span>
<span class="lineNum">  781</span><span class="lineCov">     10  /  10:       return __p; </span>
<span class="lineNum">  782</span><span class="linePartCov">     10  /  20:     } </span>
<span class="lineNum">  783</span>              :  </span>
<span class="lineNum">  784</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum">  785</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum">  786</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum">  787</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum">  788</span>              :     void </span>
<span class="lineNum">  789</span><span class="linePartCov">      9  /  10:     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum">  790</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum">  791</span>              :     _M_deallocate_buckets(__bucket_type* __p, size_type __n) </span>
<span class="lineNum">  792</span>              :     { </span>
<span class="lineNum">  793</span><span class="linePartCov">      9  /  10:       _Bucket_allocator_type __alloc(_M_node_allocator()); </span>
<span class="lineNum">  794</span><span class="linePartCov">      9  /  10:       __alloc.deallocate(__p, __n); </span>
<span class="lineNum">  795</span><span class="linePartCov">      9  /  20:     } </span>
<span class="lineNum">  796</span>              :  </span>
<span class="lineNum">  797</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum">  798</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum">  799</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum">  800</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum">  801</span>              :     typename _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, </span>
<span class="lineNum">  802</span>              : 			_Equal, _H1, _H2, _Hash, _RehashPolicy, </span>
<span class="lineNum">  803</span>              : 			_Traits&gt;::__node_type* </span>
<span class="lineNum">  804</span>              :     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum">  805</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum">  806</span>              :     _M_bucket_begin(size_type __bkt) const </span>
<span class="lineNum">  807</span>              :     { </span>
<span class="lineNum">  808</span>              :       __node_base* __n = _M_buckets[__bkt]; </span>
<span class="lineNum">  809</span>              :       return __n ? static_cast&lt;__node_type*&gt;(__n-&gt;_M_nxt) : nullptr; </span>
<span class="lineNum">  810</span>              :     } </span>
<span class="lineNum">  811</span>              :  </span>
<span class="lineNum">  812</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum">  813</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum">  814</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum">  815</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum">  816</span><span class="lineCov">     10  /  10:     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum">  817</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum">  818</span>              :     _Hashtable(size_type __bucket_hint, </span>
<span class="lineNum">  819</span>              : 	       const _H1&amp; __h1, const _H2&amp; __h2, const _Hash&amp; __h, </span>
<span class="lineNum">  820</span>              : 	       const _Equal&amp; __eq, const _ExtractKey&amp; __exk, </span>
<span class="lineNum">  821</span>              : 	       const allocator_type&amp; __a) </span>
<span class="lineNum">  822</span>              :     : __hashtable_base(__exk, __h1, __h2, __h, __eq), </span>
<span class="lineNum">  823</span>              :       __map_base(), </span>
<span class="lineNum">  824</span>              :       __rehash_base(), </span>
<span class="lineNum">  825</span>              :       _M_bucket_count(0), </span>
<span class="lineNum">  826</span>              :       _M_bbegin(__a), </span>
<span class="lineNum">  827</span>              :       _M_element_count(0), </span>
<span class="lineNum">  828</span><span class="linePartCov">     10  /  20:       _M_rehash_policy() </span>
<span class="lineNum">  829</span>              :     { </span>
<span class="lineNum">  830</span><span class="lineCov">     10  /  10:       _M_bucket_count = _M_rehash_policy._M_next_bkt(__bucket_hint); </span>
<span class="lineNum">  831</span><span class="lineCov">     10  /  10:       _M_buckets = _M_allocate_buckets(_M_bucket_count); </span>
<span class="lineNum">  832</span><span class="linePartCov">     10  /  20:     } </span>
<span class="lineNum">  833</span>              :  </span>
<span class="lineNum">  834</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum">  835</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum">  836</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum">  837</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum">  838</span>              :     template&lt;typename _InputIterator&gt; </span>
<span class="lineNum">  839</span>              :       _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum">  840</span>              : 		 _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum">  841</span>              :       _Hashtable(_InputIterator __f, _InputIterator __l, </span>
<span class="lineNum">  842</span>              : 		 size_type __bucket_hint, </span>
<span class="lineNum">  843</span>              : 		 const _H1&amp; __h1, const _H2&amp; __h2, const _Hash&amp; __h, </span>
<span class="lineNum">  844</span>              : 		 const _Equal&amp; __eq, const _ExtractKey&amp; __exk, </span>
<span class="lineNum">  845</span>              : 		 const allocator_type&amp; __a) </span>
<span class="lineNum">  846</span>              :       : __hashtable_base(__exk, __h1, __h2, __h, __eq), </span>
<span class="lineNum">  847</span>              : 	__map_base(), </span>
<span class="lineNum">  848</span>              : 	__rehash_base(), </span>
<span class="lineNum">  849</span>              : 	_M_bucket_count(0), </span>
<span class="lineNum">  850</span>              : 	_M_bbegin(__a), </span>
<span class="lineNum">  851</span>              : 	_M_element_count(0), </span>
<span class="lineNum">  852</span>              : 	_M_rehash_policy() </span>
<span class="lineNum">  853</span>              :       { </span>
<span class="lineNum">  854</span>              : 	auto __nb_elems = __detail::__distance_fw(__f, __l); </span>
<span class="lineNum">  855</span>              : 	_M_bucket_count = </span>
<span class="lineNum">  856</span>              : 	  _M_rehash_policy._M_next_bkt( </span>
<span class="lineNum">  857</span>              : 	    std::max(_M_rehash_policy._M_bkt_for_elements(__nb_elems), </span>
<span class="lineNum">  858</span>              : 		     __bucket_hint)); </span>
<span class="lineNum">  859</span>              :  </span>
<span class="lineNum">  860</span>              : 	_M_buckets = _M_allocate_buckets(_M_bucket_count); </span>
<span class="lineNum">  861</span>              : 	__try </span>
<span class="lineNum">  862</span>              : 	  { </span>
<span class="lineNum">  863</span>              : 	    for (; __f != __l; ++__f) </span>
<span class="lineNum">  864</span>              : 	      this-&gt;insert(*__f); </span>
<span class="lineNum">  865</span>              : 	  } </span>
<span class="lineNum">  866</span>              : 	__catch(...) </span>
<span class="lineNum">  867</span>              : 	  { </span>
<span class="lineNum">  868</span>              : 	    clear(); </span>
<span class="lineNum">  869</span>              : 	    _M_deallocate_buckets(_M_buckets, _M_bucket_count); </span>
<span class="lineNum">  870</span>              : 	    __throw_exception_again; </span>
<span class="lineNum">  871</span>              : 	  } </span>
<span class="lineNum">  872</span>              :       } </span>
<span class="lineNum">  873</span>              :  </span>
<span class="lineNum">  874</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum">  875</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum">  876</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum">  877</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum">  878</span>              :     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum">  879</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum">  880</span>              :     _Hashtable(const _Hashtable&amp; __ht) </span>
<span class="lineNum">  881</span>              :     : __hashtable_base(__ht), </span>
<span class="lineNum">  882</span>              :       __map_base(__ht), </span>
<span class="lineNum">  883</span>              :       __rehash_base(__ht), </span>
<span class="lineNum">  884</span>              :       _M_bucket_count(__ht._M_bucket_count), </span>
<span class="lineNum">  885</span>              :       _M_bbegin(__ht._M_bbegin), </span>
<span class="lineNum">  886</span>              :       _M_element_count(__ht._M_element_count), </span>
<span class="lineNum">  887</span>              :       _M_rehash_policy(__ht._M_rehash_policy) </span>
<span class="lineNum">  888</span>              :     { </span>
<span class="lineNum">  889</span>              :       _M_buckets = _M_allocate_buckets(_M_bucket_count); </span>
<span class="lineNum">  890</span>              :       __try </span>
<span class="lineNum">  891</span>              : 	{ </span>
<span class="lineNum">  892</span>              : 	  if (!__ht._M_before_begin()._M_nxt) </span>
<span class="lineNum">  893</span>              : 	    return; </span>
<span class="lineNum">  894</span>              :  </span>
<span class="lineNum">  895</span>              : 	  &#047;&#047; First deal with the special first node pointed to by </span>
<span class="lineNum">  896</span>              : 	  &#047;&#047; _M_before_begin. </span>
<span class="lineNum">  897</span>              : 	  const __node_type* __ht_n = __ht._M_begin(); </span>
<span class="lineNum">  898</span>              : 	  __node_type* __this_n = _M_allocate_node(__ht_n-&gt;_M_v); </span>
<span class="lineNum">  899</span>              : 	  this-&gt;_M_copy_code(__this_n, __ht_n); </span>
<span class="lineNum">  900</span>              : 	  _M_before_begin()._M_nxt = __this_n; </span>
<span class="lineNum">  901</span>              : 	  _M_buckets[_M_bucket_index(__this_n)] = &amp;_M_before_begin(); </span>
<span class="lineNum">  902</span>              :  </span>
<span class="lineNum">  903</span>              : 	  &#047;&#047; Then deal with other nodes. </span>
<span class="lineNum">  904</span>              : 	  __node_base* __prev_n = __this_n; </span>
<span class="lineNum">  905</span>              : 	  for (__ht_n = __ht_n-&gt;_M_next(); __ht_n; __ht_n = __ht_n-&gt;_M_next()) </span>
<span class="lineNum">  906</span>              : 	    { </span>
<span class="lineNum">  907</span>              : 	      __this_n = _M_allocate_node(__ht_n-&gt;_M_v); </span>
<span class="lineNum">  908</span>              : 	      __prev_n-&gt;_M_nxt = __this_n; </span>
<span class="lineNum">  909</span>              : 	      this-&gt;_M_copy_code(__this_n, __ht_n); </span>
<span class="lineNum">  910</span>              : 	      size_type __bkt = _M_bucket_index(__this_n); </span>
<span class="lineNum">  911</span>              : 	      if (!_M_buckets[__bkt]) </span>
<span class="lineNum">  912</span>              : 		_M_buckets[__bkt] = __prev_n; </span>
<span class="lineNum">  913</span>              : 	      __prev_n = __this_n; </span>
<span class="lineNum">  914</span>              : 	    } </span>
<span class="lineNum">  915</span>              : 	} </span>
<span class="lineNum">  916</span>              :       __catch(...) </span>
<span class="lineNum">  917</span>              : 	{ </span>
<span class="lineNum">  918</span>              : 	  clear(); </span>
<span class="lineNum">  919</span>              : 	  _M_deallocate_buckets(_M_buckets, _M_bucket_count); </span>
<span class="lineNum">  920</span>              : 	  __throw_exception_again; </span>
<span class="lineNum">  921</span>              : 	} </span>
<span class="lineNum">  922</span>              :     } </span>
<span class="lineNum">  923</span>              :  </span>
<span class="lineNum">  924</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum">  925</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum">  926</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum">  927</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum">  928</span>              :     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum">  929</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum">  930</span>              :     _Hashtable(_Hashtable&amp;&amp; __ht) </span>
<span class="lineNum">  931</span>              :     : __hashtable_base(__ht), </span>
<span class="lineNum">  932</span>              :       __map_base(__ht), </span>
<span class="lineNum">  933</span>              :       __rehash_base(__ht), </span>
<span class="lineNum">  934</span>              :       _M_buckets(__ht._M_buckets), </span>
<span class="lineNum">  935</span>              :       _M_bucket_count(__ht._M_bucket_count), </span>
<span class="lineNum">  936</span>              :       _M_bbegin(std::move(__ht._M_bbegin)), </span>
<span class="lineNum">  937</span>              :       _M_element_count(__ht._M_element_count), </span>
<span class="lineNum">  938</span>              :       _M_rehash_policy(__ht._M_rehash_policy) </span>
<span class="lineNum">  939</span>              :     { </span>
<span class="lineNum">  940</span>              :       &#047;&#047; Update, if necessary, bucket pointing to before begin that hasn&#039;t moved. </span>
<span class="lineNum">  941</span>              :       if (_M_begin()) </span>
<span class="lineNum">  942</span>              : 	_M_buckets[_M_bucket_index(_M_begin())] = &amp;_M_before_begin(); </span>
<span class="lineNum">  943</span>              :       __ht._M_rehash_policy = _RehashPolicy(); </span>
<span class="lineNum">  944</span>              :       __ht._M_bucket_count = __ht._M_rehash_policy._M_next_bkt(0); </span>
<span class="lineNum">  945</span>              :       __ht._M_buckets = __ht._M_allocate_buckets(__ht._M_bucket_count); </span>
<span class="lineNum">  946</span>              :       __ht._M_before_begin()._M_nxt = nullptr; </span>
<span class="lineNum">  947</span>              :       __ht._M_element_count = 0; </span>
<span class="lineNum">  948</span>              :     } </span>
<span class="lineNum">  949</span>              :  </span>
<span class="lineNum">  950</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum">  951</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum">  952</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum">  953</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum">  954</span><span class="linePartCov">      5  /  10:     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum">  955</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum">  956</span>              :     ~_Hashtable() noexcept </span>
<span class="lineNum">  957</span>              :     { </span>
<span class="lineNum">  958</span><span class="linePartCov">      6  /  10:       clear(); </span>
<span class="lineNum">  959</span><span class="linePartCov">      6  /  10:       _M_deallocate_buckets(_M_buckets, _M_bucket_count); </span>
<span class="lineNum">  960</span><span class="linePartCov">      7  /  20:     } </span>
<span class="lineNum">  961</span>              :  </span>
<span class="lineNum">  962</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum">  963</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum">  964</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum">  965</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum">  966</span>              :     void </span>
<span class="lineNum">  967</span>              :     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum">  968</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum">  969</span>              :     swap(_Hashtable&amp; __x) </span>
<span class="lineNum">  970</span>              :     { </span>
<span class="lineNum">  971</span>              :       &#047;&#047; The only base class with member variables is hash_code_base. </span>
<span class="lineNum">  972</span>              :       &#047;&#047; We define _Hash_code_base::_M_swap because different </span>
<span class="lineNum">  973</span>              :       &#047;&#047; specializations have different members. </span>
<span class="lineNum">  974</span>              :       this-&gt;_M_swap(__x); </span>
<span class="lineNum">  975</span>              :  </span>
<span class="lineNum">  976</span>              :       &#047;&#047; _GLIBCXX_RESOLVE_LIB_DEFECTS </span>
<span class="lineNum">  977</span>              :       &#047;&#047; 431. Swapping containers with unequal allocators. </span>
<span class="lineNum">  978</span>              :       std::__alloc_swap&lt;_Node_allocator_type&gt;::_S_do_it(_M_node_allocator(), </span>
<span class="lineNum">  979</span>              : 							__x._M_node_allocator()); </span>
<span class="lineNum">  980</span>              :  </span>
<span class="lineNum">  981</span>              :       std::swap(_M_rehash_policy, __x._M_rehash_policy); </span>
<span class="lineNum">  982</span>              :       std::swap(_M_buckets, __x._M_buckets); </span>
<span class="lineNum">  983</span>              :       std::swap(_M_bucket_count, __x._M_bucket_count); </span>
<span class="lineNum">  984</span>              :       std::swap(_M_before_begin()._M_nxt, __x._M_before_begin()._M_nxt); </span>
<span class="lineNum">  985</span>              :       std::swap(_M_element_count, __x._M_element_count); </span>
<span class="lineNum">  986</span>              :  </span>
<span class="lineNum">  987</span>              :       &#047;&#047; Fix buckets containing the _M_before_begin pointers that </span>
<span class="lineNum">  988</span>              :       &#047;&#047; can&#039;t be swapped. </span>
<span class="lineNum">  989</span>              :       if (_M_begin()) </span>
<span class="lineNum">  990</span>              : 	_M_buckets[_M_bucket_index(_M_begin())] = &amp;_M_before_begin(); </span>
<span class="lineNum">  991</span>              :       if (__x._M_begin()) </span>
<span class="lineNum">  992</span>              : 	__x._M_buckets[__x._M_bucket_index(__x._M_begin())] </span>
<span class="lineNum">  993</span>              : 	  = &amp;(__x._M_before_begin()); </span>
<span class="lineNum">  994</span>              :     } </span>
<span class="lineNum">  995</span>              :  </span>
<span class="lineNum">  996</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum">  997</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum">  998</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum">  999</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum"> 1000</span>              :     void </span>
<span class="lineNum"> 1001</span>              :     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1002</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum"> 1003</span>              :     __rehash_policy(const _RehashPolicy&amp; __pol) </span>
<span class="lineNum"> 1004</span>              :     { </span>
<span class="lineNum"> 1005</span>              :       size_type __n_bkt = __pol._M_bkt_for_elements(_M_element_count); </span>
<span class="lineNum"> 1006</span>              :       __n_bkt = __pol._M_next_bkt(__n_bkt); </span>
<span class="lineNum"> 1007</span>              :       if (__n_bkt != _M_bucket_count) </span>
<span class="lineNum"> 1008</span>              : 	_M_rehash(__n_bkt, _M_rehash_policy._M_state()); </span>
<span class="lineNum"> 1009</span>              :       _M_rehash_policy = __pol; </span>
<span class="lineNum"> 1010</span>              :     } </span>
<span class="lineNum"> 1011</span>              :  </span>
<span class="lineNum"> 1012</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum"> 1013</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum"> 1014</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum"> 1015</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum"> 1016</span>              :     typename _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1017</span>              : 			_H1, _H2, _Hash, _RehashPolicy, </span>
<span class="lineNum"> 1018</span>              : 			_Traits&gt;::iterator </span>
<span class="lineNum"> 1019</span><span class="linePartCov">      4  /   8:     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1020</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum"> 1021</span>              :     find(const key_type&amp; __k) </span>
<span class="lineNum"> 1022</span>              :     { </span>
<span class="lineNum"> 1023</span><span class="linePartCov">      4  /   8:       __hash_code __code = this-&gt;_M_hash_code(__k); </span>
<span class="lineNum"> 1024</span><span class="linePartCov">      4  /   8:       std::size_t __n = _M_bucket_index(__k, __code); </span>
<span class="lineNum"> 1025</span><span class="linePartCov">      4  /   8:       __node_type* __p = _M_find_node(__n, __k, __code); </span>
<span class="lineNum"> 1026</span><span class="linePartCov">      4  /   8:       return __p ? iterator(__p) : this-&gt;end(); </span>
<span class="lineNum"> 1027</span><span class="linePartCov">      4  /  16:     } </span>
<span class="lineNum"> 1028</span>              :  </span>
<span class="lineNum"> 1029</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum"> 1030</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum"> 1031</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum"> 1032</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum"> 1033</span>              :     typename _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1034</span>              : 			_H1, _H2, _Hash, _RehashPolicy, </span>
<span class="lineNum"> 1035</span>              : 			_Traits&gt;::const_iterator </span>
<span class="lineNum"> 1036</span>              :     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1037</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum"> 1038</span>              :     find(const key_type&amp; __k) const </span>
<span class="lineNum"> 1039</span>              :     { </span>
<span class="lineNum"> 1040</span>              :       __hash_code __code = this-&gt;_M_hash_code(__k); </span>
<span class="lineNum"> 1041</span>              :       std::size_t __n = _M_bucket_index(__k, __code); </span>
<span class="lineNum"> 1042</span>              :       __node_type* __p = _M_find_node(__n, __k, __code); </span>
<span class="lineNum"> 1043</span>              :       return __p ? const_iterator(__p) : this-&gt;end(); </span>
<span class="lineNum"> 1044</span>              :     } </span>
<span class="lineNum"> 1045</span>              :  </span>
<span class="lineNum"> 1046</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum"> 1047</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum"> 1048</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum"> 1049</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum"> 1050</span>              :     typename _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1051</span>              : 			_H1, _H2, _Hash, _RehashPolicy, </span>
<span class="lineNum"> 1052</span>              : 			_Traits&gt;::size_type </span>
<span class="lineNum"> 1053</span>              :     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1054</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum"> 1055</span>              :     count(const key_type&amp; __k) const </span>
<span class="lineNum"> 1056</span>              :     { </span>
<span class="lineNum"> 1057</span>              :       __hash_code __code = this-&gt;_M_hash_code(__k); </span>
<span class="lineNum"> 1058</span>              :       std::size_t __n = _M_bucket_index(__k, __code); </span>
<span class="lineNum"> 1059</span>              :       __node_type* __p = _M_bucket_begin(__n); </span>
<span class="lineNum"> 1060</span>              :       if (!__p) </span>
<span class="lineNum"> 1061</span>              : 	return 0; </span>
<span class="lineNum"> 1062</span>              :  </span>
<span class="lineNum"> 1063</span>              :       std::size_t __result = 0; </span>
<span class="lineNum"> 1064</span>              :       for (;; __p = __p-&gt;_M_next()) </span>
<span class="lineNum"> 1065</span>              : 	{ </span>
<span class="lineNum"> 1066</span>              : 	  if (this-&gt;_M_equals(__k, __code, __p)) </span>
<span class="lineNum"> 1067</span>              : 	    ++__result; </span>
<span class="lineNum"> 1068</span>              : 	  else if (__result) </span>
<span class="lineNum"> 1069</span>              : 	    &#047;&#047; All equivalent values are next to each other, if we </span>
<span class="lineNum"> 1070</span>              : 	    &#047;&#047; found a non-equivalent value after an equivalent one it </span>
<span class="lineNum"> 1071</span>              : 	    &#047;&#047; means that we won&#039;t find any more equivalent values. </span>
<span class="lineNum"> 1072</span>              : 	    break; </span>
<span class="lineNum"> 1073</span>              : 	  if (!__p-&gt;_M_nxt || _M_bucket_index(__p-&gt;_M_next()) != __n) </span>
<span class="lineNum"> 1074</span>              : 	    break; </span>
<span class="lineNum"> 1075</span>              : 	} </span>
<span class="lineNum"> 1076</span>              :       return __result; </span>
<span class="lineNum"> 1077</span>              :     } </span>
<span class="lineNum"> 1078</span>              :  </span>
<span class="lineNum"> 1079</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum"> 1080</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum"> 1081</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum"> 1082</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum"> 1083</span>              :     std::pair&lt;typename _Hashtable&lt;_Key, _Value, _Alloc, </span>
<span class="lineNum"> 1084</span>              : 				  _ExtractKey, _Equal, _H1, </span>
<span class="lineNum"> 1085</span>              : 				  _H2, _Hash, _RehashPolicy, </span>
<span class="lineNum"> 1086</span>              : 				  _Traits&gt;::iterator, </span>
<span class="lineNum"> 1087</span>              : 	      typename _Hashtable&lt;_Key, _Value, _Alloc, </span>
<span class="lineNum"> 1088</span>              : 				  _ExtractKey, _Equal, _H1, </span>
<span class="lineNum"> 1089</span>              : 				  _H2, _Hash, _RehashPolicy, </span>
<span class="lineNum"> 1090</span>              : 				  _Traits&gt;::iterator&gt; </span>
<span class="lineNum"> 1091</span>              :     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1092</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum"> 1093</span>              :     equal_range(const key_type&amp; __k) </span>
<span class="lineNum"> 1094</span>              :     { </span>
<span class="lineNum"> 1095</span>              :       __hash_code __code = this-&gt;_M_hash_code(__k); </span>
<span class="lineNum"> 1096</span>              :       std::size_t __n = _M_bucket_index(__k, __code); </span>
<span class="lineNum"> 1097</span>              :       __node_type* __p = _M_find_node(__n, __k, __code); </span>
<span class="lineNum"> 1098</span>              :  </span>
<span class="lineNum"> 1099</span>              :       if (__p) </span>
<span class="lineNum"> 1100</span>              : 	{ </span>
<span class="lineNum"> 1101</span>              : 	  __node_type* __p1 = __p-&gt;_M_next(); </span>
<span class="lineNum"> 1102</span>              : 	  while (__p1 &amp;&amp; _M_bucket_index(__p1) == __n </span>
<span class="lineNum"> 1103</span>              : 		 &amp;&amp; this-&gt;_M_equals(__k, __code, __p1)) </span>
<span class="lineNum"> 1104</span>              : 	    __p1 = __p1-&gt;_M_next(); </span>
<span class="lineNum"> 1105</span>              :  </span>
<span class="lineNum"> 1106</span>              : 	  return std::make_pair(iterator(__p), iterator(__p1)); </span>
<span class="lineNum"> 1107</span>              : 	} </span>
<span class="lineNum"> 1108</span>              :       else </span>
<span class="lineNum"> 1109</span>              : 	return std::make_pair(this-&gt;end(), this-&gt;end()); </span>
<span class="lineNum"> 1110</span>              :     } </span>
<span class="lineNum"> 1111</span>              :  </span>
<span class="lineNum"> 1112</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum"> 1113</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum"> 1114</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum"> 1115</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum"> 1116</span>              :     std::pair&lt;typename _Hashtable&lt;_Key, _Value, _Alloc, </span>
<span class="lineNum"> 1117</span>              : 				  _ExtractKey, _Equal, _H1, </span>
<span class="lineNum"> 1118</span>              : 				  _H2, _Hash, _RehashPolicy, </span>
<span class="lineNum"> 1119</span>              : 				  _Traits&gt;::const_iterator, </span>
<span class="lineNum"> 1120</span>              : 	      typename _Hashtable&lt;_Key, _Value, _Alloc, </span>
<span class="lineNum"> 1121</span>              : 				  _ExtractKey, _Equal, _H1, </span>
<span class="lineNum"> 1122</span>              : 				  _H2, _Hash, _RehashPolicy, </span>
<span class="lineNum"> 1123</span>              : 				  _Traits&gt;::const_iterator&gt; </span>
<span class="lineNum"> 1124</span>              :     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1125</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum"> 1126</span>              :     equal_range(const key_type&amp; __k) const </span>
<span class="lineNum"> 1127</span>              :     { </span>
<span class="lineNum"> 1128</span>              :       __hash_code __code = this-&gt;_M_hash_code(__k); </span>
<span class="lineNum"> 1129</span>              :       std::size_t __n = _M_bucket_index(__k, __code); </span>
<span class="lineNum"> 1130</span>              :       __node_type* __p = _M_find_node(__n, __k, __code); </span>
<span class="lineNum"> 1131</span>              :  </span>
<span class="lineNum"> 1132</span>              :       if (__p) </span>
<span class="lineNum"> 1133</span>              : 	{ </span>
<span class="lineNum"> 1134</span>              : 	  __node_type* __p1 = __p-&gt;_M_next(); </span>
<span class="lineNum"> 1135</span>              : 	  while (__p1 &amp;&amp; _M_bucket_index(__p1) == __n </span>
<span class="lineNum"> 1136</span>              : 		 &amp;&amp; this-&gt;_M_equals(__k, __code, __p1)) </span>
<span class="lineNum"> 1137</span>              : 	    __p1 = __p1-&gt;_M_next(); </span>
<span class="lineNum"> 1138</span>              :  </span>
<span class="lineNum"> 1139</span>              : 	  return std::make_pair(const_iterator(__p), const_iterator(__p1)); </span>
<span class="lineNum"> 1140</span>              : 	} </span>
<span class="lineNum"> 1141</span>              :       else </span>
<span class="lineNum"> 1142</span>              : 	return std::make_pair(this-&gt;end(), this-&gt;end()); </span>
<span class="lineNum"> 1143</span>              :     } </span>
<span class="lineNum"> 1144</span>              :  </span>
<span class="lineNum"> 1145</span>              :   &#047;&#047; Find the node whose key compares equal to k in the bucket n. </span>
<span class="lineNum"> 1146</span>              :   &#047;&#047; Return nullptr if no node is found. </span>
<span class="lineNum"> 1147</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum"> 1148</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum"> 1149</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum"> 1150</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum"> 1151</span>              :     typename _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, </span>
<span class="lineNum"> 1152</span>              : 			_Equal, _H1, _H2, _Hash, _RehashPolicy, </span>
<span class="lineNum"> 1153</span>              : 			_Traits&gt;::__node_base* </span>
<span class="lineNum"> 1154</span><span class="linePartCov">      7  /  10:     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1155</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum"> 1156</span>              :     _M_find_before_node(size_type __n, const key_type&amp; __k, </span>
<span class="lineNum"> 1157</span>              : 			__hash_code __code) const </span>
<span class="lineNum"> 1158</span>              :     { </span>
<span class="lineNum"> 1159</span><span class="linePartCov">      7  /  10:       __node_base* __prev_p = _M_buckets[__n]; </span>
<span class="lineNum"> 1160</span><span class="linePartCov">      7  /  10:       if (!__prev_p) </span>
<span class="lineNum"> 1161</span><span class="linePartCov">      7  /  10: 	return nullptr; </span>
<span class="lineNum"> 1162</span><span class="linePartCov">      7  /  10:       __node_type* __p = static_cast&lt;__node_type*&gt;(__prev_p-&gt;_M_nxt); </span>
<span class="lineNum"> 1163</span><span class="linePartCov">      4  /  10:       for (;; __p = __p-&gt;_M_next()) </span>
<span class="lineNum"> 1164</span>              : 	{ </span>
<span class="lineNum"> 1165</span><span class="linePartCov">      7  /  10: 	  if (this-&gt;_M_equals(__k, __code, __p)) </span>
<span class="lineNum"> 1166</span><span class="linePartCov">      7  /  10: 	    return __prev_p; </span>
<span class="lineNum"> 1167</span><span class="linePartCov">      4  /  10: 	  if (!__p-&gt;_M_nxt || _M_bucket_index(__p-&gt;_M_next()) != __n) </span>
<span class="lineNum"> 1168</span><span class="linePartCov">      4  /  10: 	    break; </span>
<span class="lineNum"> 1169</span><span class="linePartCov">      4  /  10: 	  __prev_p = __p; </span>
<span class="lineNum"> 1170</span>              : 	} </span>
<span class="lineNum"> 1171</span><span class="linePartCov">      8  /  20:       return nullptr; </span>
<span class="lineNum"> 1172</span><span class="linePartCov">      7  /  20:     } </span>
<span class="lineNum"> 1173</span>              :  </span>
<span class="lineNum"> 1174</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum"> 1175</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum"> 1176</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum"> 1177</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum"> 1178</span>              :     void </span>
<span class="lineNum"> 1179</span><span class="linePartCov">      7  /  10:     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1180</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum"> 1181</span>              :     _M_insert_bucket_begin(size_type __bkt, __node_type* __node) </span>
<span class="lineNum"> 1182</span>              :     { </span>
<span class="lineNum"> 1183</span><span class="linePartCov">      7  /  10:       if (_M_buckets[__bkt]) </span>
<span class="lineNum"> 1184</span>              : 	{ </span>
<span class="lineNum"> 1185</span>              : 	  &#047;&#047; Bucket is not empty, we just need to insert the new node </span>
<span class="lineNum"> 1186</span>              : 	  &#047;&#047; after the bucket before begin. </span>
<span class="lineNum"> 1187</span><span class="linePartCov">      4  /  10: 	  __node-&gt;_M_nxt = _M_buckets[__bkt]-&gt;_M_nxt; </span>
<span class="lineNum"> 1188</span><span class="linePartCov">      4  /  10: 	  _M_buckets[__bkt]-&gt;_M_nxt = __node; </span>
<span class="lineNum"> 1189</span>              : 	} </span>
<span class="lineNum"> 1190</span>              :       else </span>
<span class="lineNum"> 1191</span>              : 	{ </span>
<span class="lineNum"> 1192</span>              : 	  &#047;&#047; The bucket is empty, the new node is inserted at the </span>
<span class="lineNum"> 1193</span>              : 	  &#047;&#047; beginning of the singly-linked list and the bucket will </span>
<span class="lineNum"> 1194</span>              : 	  &#047;&#047; contain _M_before_begin pointer. </span>
<span class="lineNum"> 1195</span><span class="linePartCov">      7  /  10: 	  __node-&gt;_M_nxt = _M_before_begin()._M_nxt; </span>
<span class="lineNum"> 1196</span><span class="linePartCov">      7  /  10: 	  _M_before_begin()._M_nxt = __node; </span>
<span class="lineNum"> 1197</span><span class="linePartCov">      7  /  10: 	  if (__node-&gt;_M_nxt) </span>
<span class="lineNum"> 1198</span>              : 	    &#047;&#047; We must update former begin bucket that is pointing to </span>
<span class="lineNum"> 1199</span>              : 	    &#047;&#047; _M_before_begin. </span>
<span class="lineNum"> 1200</span><span class="linePartCov">      7  /  10: 	    _M_buckets[_M_bucket_index(__node-&gt;_M_next())] = __node; </span>
<span class="lineNum"> 1201</span><span class="linePartCov">      7  /  10: 	  _M_buckets[__bkt] = &amp;_M_before_begin(); </span>
<span class="lineNum"> 1202</span>              : 	} </span>
<span class="lineNum"> 1203</span><span class="linePartCov">      7  /  20:     } </span>
<span class="lineNum"> 1204</span>              :  </span>
<span class="lineNum"> 1205</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum"> 1206</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum"> 1207</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum"> 1208</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum"> 1209</span>              :     void </span>
<span class="lineNum"> 1210</span><span class="lineNoCov">      0  /   1:     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1211</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum"> 1212</span>              :     _M_remove_bucket_begin(size_type __bkt, __node_type* __next, </span>
<span class="lineNum"> 1213</span>              : 			   size_type __next_bkt) </span>
<span class="lineNum"> 1214</span>              :     { </span>
<span class="lineNum"> 1215</span><span class="lineNoCov">      0  /   1:       if (!__next || __next_bkt != __bkt) </span>
<span class="lineNum"> 1216</span>              : 	{ </span>
<span class="lineNum"> 1217</span>              : 	  &#047;&#047; Bucket is now empty </span>
<span class="lineNum"> 1218</span>              : 	  &#047;&#047; First update next bucket if any </span>
<span class="lineNum"> 1219</span><span class="lineNoCov">      0  /   1: 	  if (__next) </span>
<span class="lineNum"> 1220</span><span class="lineNoCov">      0  /   1: 	    _M_buckets[__next_bkt] = _M_buckets[__bkt]; </span>
<span class="lineNum"> 1221</span>              :  </span>
<span class="lineNum"> 1222</span>              : 	  &#047;&#047; Second update before begin node if necessary </span>
<span class="lineNum"> 1223</span><span class="lineNoCov">      0  /   1: 	  if (&amp;_M_before_begin() == _M_buckets[__bkt]) </span>
<span class="lineNum"> 1224</span><span class="lineNoCov">      0  /   1: 	    _M_before_begin()._M_nxt = __next; </span>
<span class="lineNum"> 1225</span><span class="lineNoCov">      0  /   1: 	  _M_buckets[__bkt] = nullptr; </span>
<span class="lineNum"> 1226</span>              : 	} </span>
<span class="lineNum"> 1227</span><span class="lineNoCov">      0  /   2:     } </span>
<span class="lineNum"> 1228</span>              :  </span>
<span class="lineNum"> 1229</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum"> 1230</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum"> 1231</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum"> 1232</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum"> 1233</span>              :     typename _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, </span>
<span class="lineNum"> 1234</span>              : 			_Equal, _H1, _H2, _Hash, _RehashPolicy, </span>
<span class="lineNum"> 1235</span>              : 			_Traits&gt;::__node_base* </span>
<span class="lineNum"> 1236</span>              :     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1237</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum"> 1238</span>              :     _M_get_previous_node(size_type __bkt, __node_base* __n) </span>
<span class="lineNum"> 1239</span>              :     { </span>
<span class="lineNum"> 1240</span>              :       __node_base* __prev_n = _M_buckets[__bkt]; </span>
<span class="lineNum"> 1241</span>              :       while (__prev_n-&gt;_M_nxt != __n) </span>
<span class="lineNum"> 1242</span>              : 	__prev_n = __prev_n-&gt;_M_nxt; </span>
<span class="lineNum"> 1243</span>              :       return __prev_n; </span>
<span class="lineNum"> 1244</span>              :     } </span>
<span class="lineNum"> 1245</span>              :  </span>
<span class="lineNum"> 1246</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum"> 1247</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum"> 1248</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum"> 1249</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum"> 1250</span>              :     template&lt;typename... _Args&gt; </span>
<span class="lineNum"> 1251</span>              :       std::pair&lt;typename _Hashtable&lt;_Key, _Value, _Alloc, </span>
<span class="lineNum"> 1252</span>              : 				    _ExtractKey, _Equal, _H1, </span>
<span class="lineNum"> 1253</span>              : 				    _H2, _Hash, _RehashPolicy, </span>
<span class="lineNum"> 1254</span>              : 				    _Traits&gt;::iterator, bool&gt; </span>
<span class="lineNum"> 1255</span>              :       _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1256</span>              : 		 _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum"> 1257</span>              :       _M_emplace(std::true_type, _Args&amp;&amp;... __args) </span>
<span class="lineNum"> 1258</span>              :       { </span>
<span class="lineNum"> 1259</span>              : 	&#047;&#047; First build the node to get access to the hash code </span>
<span class="lineNum"> 1260</span>              : 	__node_type* __node = _M_allocate_node(std::forward&lt;_Args&gt;(__args)...); </span>
<span class="lineNum"> 1261</span>              : 	const key_type&amp; __k = this-&gt;_M_extract()(__node-&gt;_M_v); </span>
<span class="lineNum"> 1262</span>              : 	__hash_code __code; </span>
<span class="lineNum"> 1263</span>              : 	__try </span>
<span class="lineNum"> 1264</span>              : 	  { </span>
<span class="lineNum"> 1265</span>              : 	    __code = this-&gt;_M_hash_code(__k); </span>
<span class="lineNum"> 1266</span>              : 	  } </span>
<span class="lineNum"> 1267</span>              : 	__catch(...) </span>
<span class="lineNum"> 1268</span>              : 	  { </span>
<span class="lineNum"> 1269</span>              : 	    _M_deallocate_node(__node); </span>
<span class="lineNum"> 1270</span>              : 	    __throw_exception_again; </span>
<span class="lineNum"> 1271</span>              : 	  } </span>
<span class="lineNum"> 1272</span>              :  </span>
<span class="lineNum"> 1273</span>              : 	size_type __bkt = _M_bucket_index(__k, __code); </span>
<span class="lineNum"> 1274</span>              : 	if (__node_type* __p = _M_find_node(__bkt, __k, __code)) </span>
<span class="lineNum"> 1275</span>              : 	  { </span>
<span class="lineNum"> 1276</span>              : 	    &#047;&#047; There is already an equivalent node, no insertion </span>
<span class="lineNum"> 1277</span>              : 	    _M_deallocate_node(__node); </span>
<span class="lineNum"> 1278</span>              : 	    return std::make_pair(iterator(__p), false); </span>
<span class="lineNum"> 1279</span>              : 	  } </span>
<span class="lineNum"> 1280</span>              :  </span>
<span class="lineNum"> 1281</span>              : 	&#047;&#047; Insert the node </span>
<span class="lineNum"> 1282</span>              : 	return std::make_pair(_M_insert_unique_node(__bkt, __code, __node), </span>
<span class="lineNum"> 1283</span>              : 			      true); </span>
<span class="lineNum"> 1284</span>              :       } </span>
<span class="lineNum"> 1285</span>              :  </span>
<span class="lineNum"> 1286</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum"> 1287</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum"> 1288</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum"> 1289</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum"> 1290</span>              :     template&lt;typename... _Args&gt; </span>
<span class="lineNum"> 1291</span>              :       typename _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1292</span>              : 			  _H1, _H2, _Hash, _RehashPolicy, </span>
<span class="lineNum"> 1293</span>              : 			  _Traits&gt;::iterator </span>
<span class="lineNum"> 1294</span>              :       _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1295</span>              : 		 _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum"> 1296</span>              :       _M_emplace(std::false_type, _Args&amp;&amp;... __args) </span>
<span class="lineNum"> 1297</span>              :       { </span>
<span class="lineNum"> 1298</span>              : 	&#047;&#047; First build the node to get its hash code. </span>
<span class="lineNum"> 1299</span>              : 	__node_type* __node = _M_allocate_node(std::forward&lt;_Args&gt;(__args)...); </span>
<span class="lineNum"> 1300</span>              :  </span>
<span class="lineNum"> 1301</span>              : 	__hash_code __code; </span>
<span class="lineNum"> 1302</span>              : 	__try </span>
<span class="lineNum"> 1303</span>              : 	  { </span>
<span class="lineNum"> 1304</span>              : 	    __code = this-&gt;_M_hash_code(this-&gt;_M_extract()(__node-&gt;_M_v)); </span>
<span class="lineNum"> 1305</span>              : 	  } </span>
<span class="lineNum"> 1306</span>              : 	__catch(...) </span>
<span class="lineNum"> 1307</span>              : 	  { </span>
<span class="lineNum"> 1308</span>              : 	    _M_deallocate_node(__node); </span>
<span class="lineNum"> 1309</span>              : 	    __throw_exception_again; </span>
<span class="lineNum"> 1310</span>              : 	  } </span>
<span class="lineNum"> 1311</span>              :  </span>
<span class="lineNum"> 1312</span>              : 	return _M_insert_multi_node(__code, __node); </span>
<span class="lineNum"> 1313</span>              :       } </span>
<span class="lineNum"> 1314</span>              :  </span>
<span class="lineNum"> 1315</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum"> 1316</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum"> 1317</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum"> 1318</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum"> 1319</span>              :     typename _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1320</span>              : 			_H1, _H2, _Hash, _RehashPolicy, </span>
<span class="lineNum"> 1321</span>              : 			_Traits&gt;::iterator </span>
<span class="lineNum"> 1322</span><span class="linePartCov">      7  /  10:     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1323</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum"> 1324</span>              :     _M_insert_unique_node(size_type __bkt, __hash_code __code, </span>
<span class="lineNum"> 1325</span>              : 			  __node_type* __node) </span>
<span class="lineNum"> 1326</span>              :     { </span>
<span class="lineNum"> 1327</span><span class="linePartCov">      7  /  10:       const __rehash_state&amp; __saved_state = _M_rehash_policy._M_state(); </span>
<span class="lineNum"> 1328</span>              :       std::pair&lt;bool, std::size_t&gt; __do_rehash </span>
<span class="lineNum"> 1329</span><span class="linePartCov">      7  /  10: 	= _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count, 1); </span>
<span class="lineNum"> 1330</span>              :  </span>
<span class="lineNum"> 1331</span>              :       __try </span>
<span class="lineNum"> 1332</span>              : 	{ </span>
<span class="lineNum"> 1333</span><span class="linePartCov">      7  /  10: 	  if (__do_rehash.first) </span>
<span class="lineNum"> 1334</span>              : 	    { </span>
<span class="lineNum"> 1335</span><span class="linePartCov">      5  /  10: 	      _M_rehash(__do_rehash.second, __saved_state); </span>
<span class="lineNum"> 1336</span><span class="linePartCov">      5  /  10: 	      __bkt = _M_bucket_index(this-&gt;_M_extract()(__node-&gt;_M_v), __code); </span>
<span class="lineNum"> 1337</span>              : 	    } </span>
<span class="lineNum"> 1338</span>              :  </span>
<span class="lineNum"> 1339</span><span class="linePartCov">      7  /  10: 	  this-&gt;_M_store_code(__node, __code); </span>
<span class="lineNum"> 1340</span>              :  </span>
<span class="lineNum"> 1341</span>              : 	  &#047;&#047; Always insert at the begining of the bucket. </span>
<span class="lineNum"> 1342</span><span class="linePartCov">      7  /  10: 	  _M_insert_bucket_begin(__bkt, __node); </span>
<span class="lineNum"> 1343</span><span class="linePartCov">      7  /  10: 	  ++_M_element_count; </span>
<span class="lineNum"> 1344</span><span class="linePartCov">      7  /  10: 	  return iterator(__node); </span>
<span class="lineNum"> 1345</span>              : 	} </span>
<span class="lineNum"> 1346</span><span class="lineNoCov">      0  /  10:       __catch(...) </span>
<span class="lineNum"> 1347</span>              : 	{ </span>
<span class="lineNum"> 1348</span><span class="lineNoCov">      0  /  10: 	  _M_deallocate_node(__node); </span>
<span class="lineNum"> 1349</span><span class="lineNoCov">      0  /  10: 	  __throw_exception_again; </span>
<span class="lineNum"> 1350</span>              : 	} </span>
<span class="lineNum"> 1351</span><span class="linePartCov">      7  /  20:     } </span>
<span class="lineNum"> 1352</span>              :  </span>
<span class="lineNum"> 1353</span>              :   &#047;&#047; Insert node, in bucket bkt if no rehash (assumes no element with its key </span>
<span class="lineNum"> 1354</span>              :   &#047;&#047; already present). Take ownership of the node, deallocate it on exception. </span>
<span class="lineNum"> 1355</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum"> 1356</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum"> 1357</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum"> 1358</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum"> 1359</span>              :     typename _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1360</span>              : 			_H1, _H2, _Hash, _RehashPolicy, </span>
<span class="lineNum"> 1361</span>              : 			_Traits&gt;::iterator </span>
<span class="lineNum"> 1362</span>              :     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1363</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum"> 1364</span>              :     _M_insert_multi_node(__hash_code __code, __node_type* __node) </span>
<span class="lineNum"> 1365</span>              :     { </span>
<span class="lineNum"> 1366</span>              :       const __rehash_state&amp; __saved_state = _M_rehash_policy._M_state(); </span>
<span class="lineNum"> 1367</span>              :       std::pair&lt;bool, std::size_t&gt; __do_rehash </span>
<span class="lineNum"> 1368</span>              : 	= _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count, 1); </span>
<span class="lineNum"> 1369</span>              :  </span>
<span class="lineNum"> 1370</span>              :       __try </span>
<span class="lineNum"> 1371</span>              : 	{ </span>
<span class="lineNum"> 1372</span>              : 	  if (__do_rehash.first) </span>
<span class="lineNum"> 1373</span>              : 	    _M_rehash(__do_rehash.second, __saved_state); </span>
<span class="lineNum"> 1374</span>              :  </span>
<span class="lineNum"> 1375</span>              : 	  this-&gt;_M_store_code(__node, __code); </span>
<span class="lineNum"> 1376</span>              : 	  const key_type&amp; __k = this-&gt;_M_extract()(__node-&gt;_M_v); </span>
<span class="lineNum"> 1377</span>              : 	  size_type __bkt = _M_bucket_index(__k, __code); </span>
<span class="lineNum"> 1378</span>              :  </span>
<span class="lineNum"> 1379</span>              : 	  &#047;&#047; Find the node before an equivalent one. </span>
<span class="lineNum"> 1380</span>              : 	  __node_base* __prev = _M_find_before_node(__bkt, __k, __code); </span>
<span class="lineNum"> 1381</span>              : 	  if (__prev) </span>
<span class="lineNum"> 1382</span>              : 	    { </span>
<span class="lineNum"> 1383</span>              : 	      &#047;&#047; Insert after the node before the equivalent one. </span>
<span class="lineNum"> 1384</span>              : 	      __node-&gt;_M_nxt = __prev-&gt;_M_nxt; </span>
<span class="lineNum"> 1385</span>              : 	      __prev-&gt;_M_nxt = __node; </span>
<span class="lineNum"> 1386</span>              : 	    } </span>
<span class="lineNum"> 1387</span>              : 	  else </span>
<span class="lineNum"> 1388</span>              : 	    &#047;&#047; The inserted node has no equivalent in the </span>
<span class="lineNum"> 1389</span>              : 	    &#047;&#047; hashtable. We must insert the new node at the </span>
<span class="lineNum"> 1390</span>              : 	    &#047;&#047; beginning of the bucket to preserve equivalent </span>
<span class="lineNum"> 1391</span>              : 	    &#047;&#047; elements&#039; relative positions. </span>
<span class="lineNum"> 1392</span>              : 	    _M_insert_bucket_begin(__bkt, __node); </span>
<span class="lineNum"> 1393</span>              : 	  ++_M_element_count; </span>
<span class="lineNum"> 1394</span>              : 	  return iterator(__node); </span>
<span class="lineNum"> 1395</span>              : 	} </span>
<span class="lineNum"> 1396</span>              :       __catch(...) </span>
<span class="lineNum"> 1397</span>              : 	{ </span>
<span class="lineNum"> 1398</span>              : 	  _M_deallocate_node(__node); </span>
<span class="lineNum"> 1399</span>              : 	  __throw_exception_again; </span>
<span class="lineNum"> 1400</span>              : 	} </span>
<span class="lineNum"> 1401</span>              :     } </span>
<span class="lineNum"> 1402</span>              :  </span>
<span class="lineNum"> 1403</span>              :   &#047;&#047; Insert v if no element with its key is already present. </span>
<span class="lineNum"> 1404</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum"> 1405</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum"> 1406</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum"> 1407</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum"> 1408</span>              :     template&lt;typename _Arg&gt; </span>
<span class="lineNum"> 1409</span>              :       std::pair&lt;typename _Hashtable&lt;_Key, _Value, _Alloc, </span>
<span class="lineNum"> 1410</span>              : 				    _ExtractKey, _Equal, _H1, </span>
<span class="lineNum"> 1411</span>              : 				    _H2, _Hash, _RehashPolicy, </span>
<span class="lineNum"> 1412</span>              : 				    _Traits&gt;::iterator, bool&gt; </span>
<span class="lineNum"> 1413</span>              :       _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1414</span>              : 		 _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum"> 1415</span>              :       _M_insert(_Arg&amp;&amp; __v, std::true_type) </span>
<span class="lineNum"> 1416</span>              :       { </span>
<span class="lineNum"> 1417</span>              : 	const key_type&amp; __k = this-&gt;_M_extract()(__v); </span>
<span class="lineNum"> 1418</span>              : 	__hash_code __code = this-&gt;_M_hash_code(__k); </span>
<span class="lineNum"> 1419</span>              : 	size_type __bkt = _M_bucket_index(__k, __code); </span>
<span class="lineNum"> 1420</span>              :  </span>
<span class="lineNum"> 1421</span>              : 	__node_type* __n = _M_find_node(__bkt, __k, __code); </span>
<span class="lineNum"> 1422</span>              : 	if (__n) </span>
<span class="lineNum"> 1423</span>              : 	  return std::make_pair(iterator(__n), false); </span>
<span class="lineNum"> 1424</span>              :  </span>
<span class="lineNum"> 1425</span>              : 	__n = _M_allocate_node(std::forward&lt;_Arg&gt;(__v)); </span>
<span class="lineNum"> 1426</span>              : 	return std::make_pair(_M_insert_unique_node(__bkt, __code, __n), true); </span>
<span class="lineNum"> 1427</span>              :       } </span>
<span class="lineNum"> 1428</span>              :  </span>
<span class="lineNum"> 1429</span>              :   &#047;&#047; Insert v unconditionally. </span>
<span class="lineNum"> 1430</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum"> 1431</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum"> 1432</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum"> 1433</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum"> 1434</span>              :     template&lt;typename _Arg&gt; </span>
<span class="lineNum"> 1435</span>              :       typename _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1436</span>              : 			  _H1, _H2, _Hash, _RehashPolicy, </span>
<span class="lineNum"> 1437</span>              : 			  _Traits&gt;::iterator </span>
<span class="lineNum"> 1438</span>              :       _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1439</span>              : 		 _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum"> 1440</span>              :       _M_insert(_Arg&amp;&amp; __v, std::false_type) </span>
<span class="lineNum"> 1441</span>              :       { </span>
<span class="lineNum"> 1442</span>              : 	&#047;&#047; First compute the hash code so that we don&#039;t do anything if it </span>
<span class="lineNum"> 1443</span>              : 	&#047;&#047; throws. </span>
<span class="lineNum"> 1444</span>              : 	__hash_code __code = this-&gt;_M_hash_code(this-&gt;_M_extract()(__v)); </span>
<span class="lineNum"> 1445</span>              :  </span>
<span class="lineNum"> 1446</span>              : 	&#047;&#047; Second allocate new node so that we don&#039;t rehash if it throws. </span>
<span class="lineNum"> 1447</span>              : 	__node_type* __node = _M_allocate_node(std::forward&lt;_Arg&gt;(__v)); </span>
<span class="lineNum"> 1448</span>              :  </span>
<span class="lineNum"> 1449</span>              : 	return _M_insert_multi_node(__code, __node); </span>
<span class="lineNum"> 1450</span>              :       } </span>
<span class="lineNum"> 1451</span>              :  </span>
<span class="lineNum"> 1452</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum"> 1453</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum"> 1454</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum"> 1455</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum"> 1456</span>              :     typename _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1457</span>              : 			_H1, _H2, _Hash, _RehashPolicy, </span>
<span class="lineNum"> 1458</span>              : 			_Traits&gt;::iterator </span>
<span class="lineNum"> 1459</span>              :     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1460</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum"> 1461</span>              :     erase(const_iterator __it) </span>
<span class="lineNum"> 1462</span>              :     { </span>
<span class="lineNum"> 1463</span>              :       __node_type* __n = __it._M_cur; </span>
<span class="lineNum"> 1464</span>              :       std::size_t __bkt = _M_bucket_index(__n); </span>
<span class="lineNum"> 1465</span>              :  </span>
<span class="lineNum"> 1466</span>              :       &#047;&#047; Look for previous node to unlink it from the erased one, this </span>
<span class="lineNum"> 1467</span>              :       &#047;&#047; is why we need buckets to contain the before begin to make </span>
<span class="lineNum"> 1468</span>              :       &#047;&#047; this search fast. </span>
<span class="lineNum"> 1469</span>              :       __node_base* __prev_n = _M_get_previous_node(__bkt, __n); </span>
<span class="lineNum"> 1470</span>              :       return _M_erase(__bkt, __prev_n, __n); </span>
<span class="lineNum"> 1471</span>              :     } </span>
<span class="lineNum"> 1472</span>              :  </span>
<span class="lineNum"> 1473</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum"> 1474</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum"> 1475</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum"> 1476</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum"> 1477</span>              :     typename _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1478</span>              : 			_H1, _H2, _Hash, _RehashPolicy, </span>
<span class="lineNum"> 1479</span>              : 			_Traits&gt;::iterator </span>
<span class="lineNum"> 1480</span><span class="lineNoCov">      0  /   1:     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1481</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum"> 1482</span>              :     _M_erase(size_type __bkt, __node_base* __prev_n, __node_type* __n) </span>
<span class="lineNum"> 1483</span>              :     { </span>
<span class="lineNum"> 1484</span><span class="lineNoCov">      0  /   1:       if (__prev_n == _M_buckets[__bkt]) </span>
<span class="lineNum"> 1485</span><span class="lineNoCov">      0  /   1: 	_M_remove_bucket_begin(__bkt, __n-&gt;_M_next(), </span>
<span class="lineNum"> 1486</span><span class="lineNoCov">      0  /   1: 	   __n-&gt;_M_nxt ? _M_bucket_index(__n-&gt;_M_next()) : 0); </span>
<span class="lineNum"> 1487</span><span class="lineNoCov">      0  /   1:       else if (__n-&gt;_M_nxt) </span>
<span class="lineNum"> 1488</span>              : 	{ </span>
<span class="lineNum"> 1489</span><span class="lineNoCov">      0  /   1: 	  size_type __next_bkt = _M_bucket_index(__n-&gt;_M_next()); </span>
<span class="lineNum"> 1490</span><span class="lineNoCov">      0  /   1: 	  if (__next_bkt != __bkt) </span>
<span class="lineNum"> 1491</span><span class="lineNoCov">      0  /   1: 	    _M_buckets[__next_bkt] = __prev_n; </span>
<span class="lineNum"> 1492</span>              : 	} </span>
<span class="lineNum"> 1493</span>              :  </span>
<span class="lineNum"> 1494</span><span class="lineNoCov">      0  /   1:       __prev_n-&gt;_M_nxt = __n-&gt;_M_nxt; </span>
<span class="lineNum"> 1495</span><span class="lineNoCov">      0  /   1:       iterator __result(__n-&gt;_M_next()); </span>
<span class="lineNum"> 1496</span><span class="lineNoCov">      0  /   1:       _M_deallocate_node(__n); </span>
<span class="lineNum"> 1497</span><span class="lineNoCov">      0  /   1:       --_M_element_count; </span>
<span class="lineNum"> 1498</span>              :  </span>
<span class="lineNum"> 1499</span><span class="lineNoCov">      0  /   1:       return __result; </span>
<span class="lineNum"> 1500</span><span class="lineNoCov">      0  /   2:     } </span>
<span class="lineNum"> 1501</span>              :  </span>
<span class="lineNum"> 1502</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum"> 1503</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum"> 1504</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum"> 1505</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum"> 1506</span>              :     typename _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1507</span>              : 			_H1, _H2, _Hash, _RehashPolicy, </span>
<span class="lineNum"> 1508</span>              : 			_Traits&gt;::size_type </span>
<span class="lineNum"> 1509</span><span class="lineNoCov">      0  /   1:     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1510</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum"> 1511</span>              :     _M_erase(std::true_type, const key_type&amp; __k) </span>
<span class="lineNum"> 1512</span>              :     { </span>
<span class="lineNum"> 1513</span><span class="lineNoCov">      0  /   1:       __hash_code __code = this-&gt;_M_hash_code(__k); </span>
<span class="lineNum"> 1514</span><span class="lineNoCov">      0  /   1:       std::size_t __bkt = _M_bucket_index(__k, __code); </span>
<span class="lineNum"> 1515</span>              :  </span>
<span class="lineNum"> 1516</span>              :       &#047;&#047; Look for the node before the first matching node. </span>
<span class="lineNum"> 1517</span><span class="lineNoCov">      0  /   1:       __node_base* __prev_n = _M_find_before_node(__bkt, __k, __code); </span>
<span class="lineNum"> 1518</span><span class="lineNoCov">      0  /   1:       if (!__prev_n) </span>
<span class="lineNum"> 1519</span><span class="lineNoCov">      0  /   1: 	return 0; </span>
<span class="lineNum"> 1520</span>              :  </span>
<span class="lineNum"> 1521</span>              :       &#047;&#047; We found a matching node, erase it. </span>
<span class="lineNum"> 1522</span><span class="lineNoCov">      0  /   1:       __node_type* __n = static_cast&lt;__node_type*&gt;(__prev_n-&gt;_M_nxt); </span>
<span class="lineNum"> 1523</span><span class="lineNoCov">      0  /   1:       _M_erase(__bkt, __prev_n, __n); </span>
<span class="lineNum"> 1524</span><span class="lineNoCov">      0  /   1:       return 1; </span>
<span class="lineNum"> 1525</span><span class="lineNoCov">      0  /   2:     } </span>
<span class="lineNum"> 1526</span>              :  </span>
<span class="lineNum"> 1527</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum"> 1528</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum"> 1529</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum"> 1530</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum"> 1531</span>              :     typename _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1532</span>              : 			_H1, _H2, _Hash, _RehashPolicy, </span>
<span class="lineNum"> 1533</span>              : 			_Traits&gt;::size_type </span>
<span class="lineNum"> 1534</span>              :     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1535</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum"> 1536</span>              :     _M_erase(std::false_type, const key_type&amp; __k) </span>
<span class="lineNum"> 1537</span>              :     { </span>
<span class="lineNum"> 1538</span>              :       __hash_code __code = this-&gt;_M_hash_code(__k); </span>
<span class="lineNum"> 1539</span>              :       std::size_t __bkt = _M_bucket_index(__k, __code); </span>
<span class="lineNum"> 1540</span>              :  </span>
<span class="lineNum"> 1541</span>              :       &#047;&#047; Look for the node before the first matching node. </span>
<span class="lineNum"> 1542</span>              :       __node_base* __prev_n = _M_find_before_node(__bkt, __k, __code); </span>
<span class="lineNum"> 1543</span>              :       if (!__prev_n) </span>
<span class="lineNum"> 1544</span>              : 	return 0; </span>
<span class="lineNum"> 1545</span>              :  </span>
<span class="lineNum"> 1546</span>              :       &#047;&#047; _GLIBCXX_RESOLVE_LIB_DEFECTS </span>
<span class="lineNum"> 1547</span>              :       &#047;&#047; 526. Is it undefined if a function in the standard changes </span>
<span class="lineNum"> 1548</span>              :       &#047;&#047; in parameters? </span>
<span class="lineNum"> 1549</span>              :       &#047;&#047; We use one loop to find all matching nodes and another to deallocate </span>
<span class="lineNum"> 1550</span>              :       &#047;&#047; them so that the key stays valid during the first loop. It might be </span>
<span class="lineNum"> 1551</span>              :       &#047;&#047; invalidated indirectly when destroying nodes. </span>
<span class="lineNum"> 1552</span>              :       __node_type* __n = static_cast&lt;__node_type*&gt;(__prev_n-&gt;_M_nxt); </span>
<span class="lineNum"> 1553</span>              :       __node_type* __n_last = __n; </span>
<span class="lineNum"> 1554</span>              :       std::size_t __n_last_bkt = __bkt; </span>
<span class="lineNum"> 1555</span>              :       do </span>
<span class="lineNum"> 1556</span>              : 	{ </span>
<span class="lineNum"> 1557</span>              : 	  __n_last = __n_last-&gt;_M_next(); </span>
<span class="lineNum"> 1558</span>              : 	  if (!__n_last) </span>
<span class="lineNum"> 1559</span>              : 	    break; </span>
<span class="lineNum"> 1560</span>              : 	  __n_last_bkt = _M_bucket_index(__n_last); </span>
<span class="lineNum"> 1561</span>              : 	} </span>
<span class="lineNum"> 1562</span>              :       while (__n_last_bkt == __bkt &amp;&amp; this-&gt;_M_equals(__k, __code, __n_last)); </span>
<span class="lineNum"> 1563</span>              :  </span>
<span class="lineNum"> 1564</span>              :       &#047;&#047; Deallocate nodes. </span>
<span class="lineNum"> 1565</span>              :       size_type __result = 0; </span>
<span class="lineNum"> 1566</span>              :       do </span>
<span class="lineNum"> 1567</span>              : 	{ </span>
<span class="lineNum"> 1568</span>              : 	  __node_type* __p = __n-&gt;_M_next(); </span>
<span class="lineNum"> 1569</span>              : 	  _M_deallocate_node(__n); </span>
<span class="lineNum"> 1570</span>              : 	  __n = __p; </span>
<span class="lineNum"> 1571</span>              : 	  ++__result; </span>
<span class="lineNum"> 1572</span>              : 	  --_M_element_count; </span>
<span class="lineNum"> 1573</span>              : 	} </span>
<span class="lineNum"> 1574</span>              :       while (__n != __n_last); </span>
<span class="lineNum"> 1575</span>              :  </span>
<span class="lineNum"> 1576</span>              :       if (__prev_n == _M_buckets[__bkt]) </span>
<span class="lineNum"> 1577</span>              : 	_M_remove_bucket_begin(__bkt, __n_last, __n_last_bkt); </span>
<span class="lineNum"> 1578</span>              :       else if (__n_last &amp;&amp; __n_last_bkt != __bkt) </span>
<span class="lineNum"> 1579</span>              : 	_M_buckets[__n_last_bkt] = __prev_n; </span>
<span class="lineNum"> 1580</span>              :       __prev_n-&gt;_M_nxt = __n_last; </span>
<span class="lineNum"> 1581</span>              :       return __result; </span>
<span class="lineNum"> 1582</span>              :     } </span>
<span class="lineNum"> 1583</span>              :  </span>
<span class="lineNum"> 1584</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum"> 1585</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum"> 1586</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum"> 1587</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum"> 1588</span>              :     typename _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1589</span>              : 			_H1, _H2, _Hash, _RehashPolicy, </span>
<span class="lineNum"> 1590</span>              : 			_Traits&gt;::iterator </span>
<span class="lineNum"> 1591</span>              :     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1592</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum"> 1593</span>              :     erase(const_iterator __first, const_iterator __last) </span>
<span class="lineNum"> 1594</span>              :     { </span>
<span class="lineNum"> 1595</span>              :       __node_type* __n = __first._M_cur; </span>
<span class="lineNum"> 1596</span>              :       __node_type* __last_n = __last._M_cur; </span>
<span class="lineNum"> 1597</span>              :       if (__n == __last_n) </span>
<span class="lineNum"> 1598</span>              : 	return iterator(__n); </span>
<span class="lineNum"> 1599</span>              :  </span>
<span class="lineNum"> 1600</span>              :       std::size_t __bkt = _M_bucket_index(__n); </span>
<span class="lineNum"> 1601</span>              :  </span>
<span class="lineNum"> 1602</span>              :       __node_base* __prev_n = _M_get_previous_node(__bkt, __n); </span>
<span class="lineNum"> 1603</span>              :       bool __is_bucket_begin = __n == _M_bucket_begin(__bkt); </span>
<span class="lineNum"> 1604</span>              :       std::size_t __n_bkt = __bkt; </span>
<span class="lineNum"> 1605</span>              :       for (;;) </span>
<span class="lineNum"> 1606</span>              : 	{ </span>
<span class="lineNum"> 1607</span>              : 	  do </span>
<span class="lineNum"> 1608</span>              : 	    { </span>
<span class="lineNum"> 1609</span>              : 	      __node_type* __tmp = __n; </span>
<span class="lineNum"> 1610</span>              : 	      __n = __n-&gt;_M_next(); </span>
<span class="lineNum"> 1611</span>              : 	      _M_deallocate_node(__tmp); </span>
<span class="lineNum"> 1612</span>              : 	      --_M_element_count; </span>
<span class="lineNum"> 1613</span>              : 	      if (!__n) </span>
<span class="lineNum"> 1614</span>              : 		break; </span>
<span class="lineNum"> 1615</span>              : 	      __n_bkt = _M_bucket_index(__n); </span>
<span class="lineNum"> 1616</span>              : 	    } </span>
<span class="lineNum"> 1617</span>              : 	  while (__n != __last_n &amp;&amp; __n_bkt == __bkt); </span>
<span class="lineNum"> 1618</span>              : 	  if (__is_bucket_begin) </span>
<span class="lineNum"> 1619</span>              : 	    _M_remove_bucket_begin(__bkt, __n, __n_bkt); </span>
<span class="lineNum"> 1620</span>              : 	  if (__n == __last_n) </span>
<span class="lineNum"> 1621</span>              : 	    break; </span>
<span class="lineNum"> 1622</span>              : 	  __is_bucket_begin = true; </span>
<span class="lineNum"> 1623</span>              : 	  __bkt = __n_bkt; </span>
<span class="lineNum"> 1624</span>              : 	} </span>
<span class="lineNum"> 1625</span>              :  </span>
<span class="lineNum"> 1626</span>              :       if (__n &amp;&amp; (__n_bkt != __bkt || __is_bucket_begin)) </span>
<span class="lineNum"> 1627</span>              : 	_M_buckets[__n_bkt] = __prev_n; </span>
<span class="lineNum"> 1628</span>              :       __prev_n-&gt;_M_nxt = __n; </span>
<span class="lineNum"> 1629</span>              :       return iterator(__n); </span>
<span class="lineNum"> 1630</span>              :     } </span>
<span class="lineNum"> 1631</span>              :  </span>
<span class="lineNum"> 1632</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum"> 1633</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum"> 1634</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum"> 1635</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum"> 1636</span>              :     void </span>
<span class="lineNum"> 1637</span><span class="linePartCov">      5  /  10:     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1638</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum"> 1639</span>              :     clear() noexcept </span>
<span class="lineNum"> 1640</span>              :     { </span>
<span class="lineNum"> 1641</span><span class="linePartCov">      6  /  10:       _M_deallocate_nodes(_M_begin()); </span>
<span class="lineNum"> 1642</span><span class="linePartCov">      6  /  10:       __builtin_memset(_M_buckets, 0, _M_bucket_count * sizeof(__bucket_type)); </span>
<span class="lineNum"> 1643</span><span class="linePartCov">      6  /  10:       _M_element_count = 0; </span>
<span class="lineNum"> 1644</span><span class="linePartCov">      6  /  10:       _M_before_begin()._M_nxt = nullptr; </span>
<span class="lineNum"> 1645</span><span class="linePartCov">      6  /  20:     } </span>
<span class="lineNum"> 1646</span>              :  </span>
<span class="lineNum"> 1647</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum"> 1648</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum"> 1649</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum"> 1650</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum"> 1651</span>              :     void </span>
<span class="lineNum"> 1652</span>              :     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1653</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum"> 1654</span>              :     rehash(size_type __n) </span>
<span class="lineNum"> 1655</span>              :     { </span>
<span class="lineNum"> 1656</span>              :       const __rehash_state&amp; __saved_state = _M_rehash_policy._M_state(); </span>
<span class="lineNum"> 1657</span>              :       std::size_t __buckets </span>
<span class="lineNum"> 1658</span>              : 	= std::max(_M_rehash_policy._M_bkt_for_elements(_M_element_count + 1), </span>
<span class="lineNum"> 1659</span>              : 		   __n); </span>
<span class="lineNum"> 1660</span>              :       __buckets = _M_rehash_policy._M_next_bkt(__buckets); </span>
<span class="lineNum"> 1661</span>              :  </span>
<span class="lineNum"> 1662</span>              :       if (__buckets != _M_bucket_count) </span>
<span class="lineNum"> 1663</span>              : 	_M_rehash(__buckets, __saved_state); </span>
<span class="lineNum"> 1664</span>              :       else </span>
<span class="lineNum"> 1665</span>              : 	&#047;&#047; No rehash, restore previous state to keep a consistent state. </span>
<span class="lineNum"> 1666</span>              : 	_M_rehash_policy._M_reset(__saved_state); </span>
<span class="lineNum"> 1667</span>              :     } </span>
<span class="lineNum"> 1668</span>              :  </span>
<span class="lineNum"> 1669</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum"> 1670</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum"> 1671</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum"> 1672</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum"> 1673</span>              :     void </span>
<span class="lineNum"> 1674</span><span class="linePartCov">      5  /  10:     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1675</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum"> 1676</span>              :     _M_rehash(size_type __n, const __rehash_state&amp; __state) </span>
<span class="lineNum"> 1677</span>              :     { </span>
<span class="lineNum"> 1678</span>              :       __try </span>
<span class="lineNum"> 1679</span>              : 	{ </span>
<span class="lineNum"> 1680</span><span class="linePartCov">      5  /  10: 	  _M_rehash_aux(__n, __unique_keys()); </span>
<span class="lineNum"> 1681</span>              : 	} </span>
<span class="lineNum"> 1682</span><span class="lineNoCov">      0  /  20:       __catch(...) </span>
<span class="lineNum"> 1683</span>              : 	{ </span>
<span class="lineNum"> 1684</span>              : 	  &#047;&#047; A failure here means that buckets allocation failed.  We only </span>
<span class="lineNum"> 1685</span>              : 	  &#047;&#047; have to restore hash policy previous state. </span>
<span class="lineNum"> 1686</span><span class="lineNoCov">      0  /  10: 	  _M_rehash_policy._M_reset(__state); </span>
<span class="lineNum"> 1687</span><span class="lineNoCov">      0  /  10: 	  __throw_exception_again; </span>
<span class="lineNum"> 1688</span>              : 	} </span>
<span class="lineNum"> 1689</span><span class="linePartCov">     10  /  30:     } </span>
<span class="lineNum"> 1690</span>              :  </span>
<span class="lineNum"> 1691</span>              :   &#047;&#047; Rehash when there is no equivalent elements. </span>
<span class="lineNum"> 1692</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum"> 1693</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum"> 1694</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum"> 1695</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum"> 1696</span>              :     void </span>
<span class="lineNum"> 1697</span><span class="linePartCov">      5  /  10:     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1698</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum"> 1699</span>              :     _M_rehash_aux(size_type __n, std::true_type) </span>
<span class="lineNum"> 1700</span>              :     { </span>
<span class="lineNum"> 1701</span><span class="linePartCov">      5  /  10:       __bucket_type* __new_buckets = _M_allocate_buckets(__n); </span>
<span class="lineNum"> 1702</span><span class="linePartCov">      5  /  10:       __node_type* __p = _M_begin(); </span>
<span class="lineNum"> 1703</span><span class="linePartCov">      5  /  10:       _M_before_begin()._M_nxt = nullptr; </span>
<span class="lineNum"> 1704</span><span class="linePartCov">      5  /  10:       std::size_t __bbegin_bkt = 0; </span>
<span class="lineNum"> 1705</span><span class="linePartCov">     10  /  20:       while (__p) </span>
<span class="lineNum"> 1706</span>              : 	{ </span>
<span class="lineNum"> 1707</span><span class="linePartCov">      5  /  10: 	  __node_type* __next = __p-&gt;_M_next(); </span>
<span class="lineNum"> 1708</span><span class="linePartCov">      5  /  10: 	  std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __n); </span>
<span class="lineNum"> 1709</span><span class="linePartCov">      5  /  10: 	  if (!__new_buckets[__bkt]) </span>
<span class="lineNum"> 1710</span>              : 	    { </span>
<span class="lineNum"> 1711</span><span class="linePartCov">      5  /  10: 	      __p-&gt;_M_nxt = _M_before_begin()._M_nxt; </span>
<span class="lineNum"> 1712</span><span class="linePartCov">      5  /  10: 	      _M_before_begin()._M_nxt = __p; </span>
<span class="lineNum"> 1713</span><span class="linePartCov">      5  /  10: 	      __new_buckets[__bkt] = &amp;_M_before_begin(); </span>
<span class="lineNum"> 1714</span><span class="linePartCov">      5  /  10: 	      if (__p-&gt;_M_nxt) </span>
<span class="lineNum"> 1715</span><span class="linePartCov">      5  /  10: 		__new_buckets[__bbegin_bkt] = __p; </span>
<span class="lineNum"> 1716</span><span class="linePartCov">      5  /  10: 	      __bbegin_bkt = __bkt; </span>
<span class="lineNum"> 1717</span>              : 	    } </span>
<span class="lineNum"> 1718</span>              : 	  else </span>
<span class="lineNum"> 1719</span>              : 	    { </span>
<span class="lineNum"> 1720</span><span class="lineNoCov">      0  /  10: 	      __p-&gt;_M_nxt = __new_buckets[__bkt]-&gt;_M_nxt; </span>
<span class="lineNum"> 1721</span><span class="lineNoCov">      0  /  10: 	      __new_buckets[__bkt]-&gt;_M_nxt = __p; </span>
<span class="lineNum"> 1722</span>              : 	    } </span>
<span class="lineNum"> 1723</span><span class="linePartCov">      5  /  10: 	  __p = __next; </span>
<span class="lineNum"> 1724</span>              : 	} </span>
<span class="lineNum"> 1725</span><span class="linePartCov">      5  /  10:       _M_deallocate_buckets(_M_buckets, _M_bucket_count); </span>
<span class="lineNum"> 1726</span><span class="linePartCov">      5  /  10:       _M_bucket_count = __n; </span>
<span class="lineNum"> 1727</span><span class="linePartCov">      5  /  10:       _M_buckets = __new_buckets; </span>
<span class="lineNum"> 1728</span><span class="linePartCov">      5  /  20:     } </span>
<span class="lineNum"> 1729</span>              :  </span>
<span class="lineNum"> 1730</span>              :   &#047;&#047; Rehash when there can be equivalent elements, preserve their relative </span>
<span class="lineNum"> 1731</span>              :   &#047;&#047; order. </span>
<span class="lineNum"> 1732</span>              :   template&lt;typename _Key, typename _Value, </span>
<span class="lineNum"> 1733</span>              : 	   typename _Alloc, typename _ExtractKey, typename _Equal, </span>
<span class="lineNum"> 1734</span>              : 	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, </span>
<span class="lineNum"> 1735</span>              : 	   typename _Traits&gt; </span>
<span class="lineNum"> 1736</span>              :     void </span>
<span class="lineNum"> 1737</span>              :     _Hashtable&lt;_Key, _Value, _Alloc, _ExtractKey, _Equal, </span>
<span class="lineNum"> 1738</span>              : 	       _H1, _H2, _Hash, _RehashPolicy, _Traits&gt;:: </span>
<span class="lineNum"> 1739</span>              :     _M_rehash_aux(size_type __n, std::false_type) </span>
<span class="lineNum"> 1740</span>              :     { </span>
<span class="lineNum"> 1741</span>              :       __bucket_type* __new_buckets = _M_allocate_buckets(__n); </span>
<span class="lineNum"> 1742</span>              :  </span>
<span class="lineNum"> 1743</span>              :       __node_type* __p = _M_begin(); </span>
<span class="lineNum"> 1744</span>              :       _M_before_begin()._M_nxt = nullptr; </span>
<span class="lineNum"> 1745</span>              :       std::size_t __bbegin_bkt = 0; </span>
<span class="lineNum"> 1746</span>              :       std::size_t __prev_bkt = 0; </span>
<span class="lineNum"> 1747</span>              :       __node_type* __prev_p = nullptr; </span>
<span class="lineNum"> 1748</span>              :       bool __check_bucket = false; </span>
<span class="lineNum"> 1749</span>              :  </span>
<span class="lineNum"> 1750</span>              :       while (__p) </span>
<span class="lineNum"> 1751</span>              : 	{ </span>
<span class="lineNum"> 1752</span>              : 	  __node_type* __next = __p-&gt;_M_next(); </span>
<span class="lineNum"> 1753</span>              : 	  std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __n); </span>
<span class="lineNum"> 1754</span>              :  </span>
<span class="lineNum"> 1755</span>              : 	  if (__prev_p &amp;&amp; __prev_bkt == __bkt) </span>
<span class="lineNum"> 1756</span>              : 	    { </span>
<span class="lineNum"> 1757</span>              : 	      &#047;&#047; Previous insert was already in this bucket, we insert after </span>
<span class="lineNum"> 1758</span>              : 	      &#047;&#047; the previously inserted one to preserve equivalent elements </span>
<span class="lineNum"> 1759</span>              : 	      &#047;&#047; relative order. </span>
<span class="lineNum"> 1760</span>              : 	      __p-&gt;_M_nxt = __prev_p-&gt;_M_nxt; </span>
<span class="lineNum"> 1761</span>              : 	      __prev_p-&gt;_M_nxt = __p; </span>
<span class="lineNum"> 1762</span>              :  </span>
<span class="lineNum"> 1763</span>              : 	      &#047;&#047; Inserting after a node in a bucket require to check that we </span>
<span class="lineNum"> 1764</span>              : 	      &#047;&#047; haven&#039;t change the bucket last node, in this case next </span>
<span class="lineNum"> 1765</span>              : 	      &#047;&#047; bucket containing its before begin node must be updated. We </span>
<span class="lineNum"> 1766</span>              : 	      &#047;&#047; schedule a check as soon as we move out of the sequence of </span>
<span class="lineNum"> 1767</span>              : 	      &#047;&#047; equivalent nodes to limit the number of checks. </span>
<span class="lineNum"> 1768</span>              : 	      __check_bucket = true; </span>
<span class="lineNum"> 1769</span>              : 	    } </span>
<span class="lineNum"> 1770</span>              : 	  else </span>
<span class="lineNum"> 1771</span>              : 	    { </span>
<span class="lineNum"> 1772</span>              : 	      if (__check_bucket) </span>
<span class="lineNum"> 1773</span>              : 		{ </span>
<span class="lineNum"> 1774</span>              : 		  &#047;&#047; Check if we shall update the next bucket because of </span>
<span class="lineNum"> 1775</span>              : 		  &#047;&#047; insertions into __prev_bkt bucket. </span>
<span class="lineNum"> 1776</span>              : 		  if (__prev_p-&gt;_M_nxt) </span>
<span class="lineNum"> 1777</span>              : 		    { </span>
<span class="lineNum"> 1778</span>              : 		      std::size_t __next_bkt </span>
<span class="lineNum"> 1779</span>              : 			= __hash_code_base::_M_bucket_index(__prev_p-&gt;_M_next(), </span>
<span class="lineNum"> 1780</span>              : 							    __n); </span>
<span class="lineNum"> 1781</span>              : 		      if (__next_bkt != __prev_bkt) </span>
<span class="lineNum"> 1782</span>              : 			__new_buckets[__next_bkt] = __prev_p; </span>
<span class="lineNum"> 1783</span>              : 		    } </span>
<span class="lineNum"> 1784</span>              : 		  __check_bucket = false; </span>
<span class="lineNum"> 1785</span>              : 		} </span>
<span class="lineNum"> 1786</span>              :  </span>
<span class="lineNum"> 1787</span>              : 	      if (!__new_buckets[__bkt]) </span>
<span class="lineNum"> 1788</span>              : 		{ </span>
<span class="lineNum"> 1789</span>              : 		  __p-&gt;_M_nxt = _M_before_begin()._M_nxt; </span>
<span class="lineNum"> 1790</span>              : 		  _M_before_begin()._M_nxt = __p; </span>
<span class="lineNum"> 1791</span>              : 		  __new_buckets[__bkt] = &amp;_M_before_begin(); </span>
<span class="lineNum"> 1792</span>              : 		  if (__p-&gt;_M_nxt) </span>
<span class="lineNum"> 1793</span>              : 		    __new_buckets[__bbegin_bkt] = __p; </span>
<span class="lineNum"> 1794</span>              : 		  __bbegin_bkt = __bkt; </span>
<span class="lineNum"> 1795</span>              : 		} </span>
<span class="lineNum"> 1796</span>              : 	      else </span>
<span class="lineNum"> 1797</span>              : 		{ </span>
<span class="lineNum"> 1798</span>              : 		  __p-&gt;_M_nxt = __new_buckets[__bkt]-&gt;_M_nxt; </span>
<span class="lineNum"> 1799</span>              : 		  __new_buckets[__bkt]-&gt;_M_nxt = __p; </span>
<span class="lineNum"> 1800</span>              : 		} </span>
<span class="lineNum"> 1801</span>              : 	    } </span>
<span class="lineNum"> 1802</span>              : 	  __prev_p = __p; </span>
<span class="lineNum"> 1803</span>              : 	  __prev_bkt = __bkt; </span>
<span class="lineNum"> 1804</span>              : 	  __p = __next; </span>
<span class="lineNum"> 1805</span>              : 	} </span>
<span class="lineNum"> 1806</span>              :  </span>
<span class="lineNum"> 1807</span>              :       if (__check_bucket &amp;&amp; __prev_p-&gt;_M_nxt) </span>
<span class="lineNum"> 1808</span>              : 	{ </span>
<span class="lineNum"> 1809</span>              : 	  std::size_t __next_bkt </span>
<span class="lineNum"> 1810</span>              : 	    = __hash_code_base::_M_bucket_index(__prev_p-&gt;_M_next(), __n); </span>
<span class="lineNum"> 1811</span>              : 	  if (__next_bkt != __prev_bkt) </span>
<span class="lineNum"> 1812</span>              : 	    __new_buckets[__next_bkt] = __prev_p; </span>
<span class="lineNum"> 1813</span>              : 	} </span>
<span class="lineNum"> 1814</span>              :  </span>
<span class="lineNum"> 1815</span>              :       _M_deallocate_buckets(_M_buckets, _M_bucket_count); </span>
<span class="lineNum"> 1816</span>              :       _M_bucket_count = __n; </span>
<span class="lineNum"> 1817</span>              :       _M_buckets = __new_buckets; </span>
<span class="lineNum"> 1818</span>              :     } </span>
<span class="lineNum"> 1819</span>              :  </span>
<span class="lineNum"> 1820</span>              : _GLIBCXX_END_NAMESPACE_VERSION </span>
<span class="lineNum"> 1821</span>              : } &#047;&#047; namespace std </span>
<span class="lineNum"> 1822</span>              :  </span>
<span class="lineNum"> 1823</span>              : #endif &#047;&#047; _HASHTABLE_H </span>
</pre>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr><td class="versionInfo">Generated by: <a href="http://simonkagstrom.github.com/kcov/index.html">Kcov</a></td></tr>
</table>
<br/>
</body>
</html>
