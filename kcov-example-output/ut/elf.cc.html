<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Coverage - ut</title>
  <link rel="stylesheet" type="text/css" href="bcov.css"/>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="title">Coverage Report</td></tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr>
    <td width="100%">
      <table cellpadding="1" border="0" width="100%">
        <tr>
          <td class="headerItem" width="20%">Command:</td>
          <td class="headerValue" width="80%" colspan=6>ut</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Date:</td>
          <td class="headerValue" width="15%">2012-06-16 11:52:55</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Instrumented&nbsp;lines:</td>
          <td class="headerValue" width="10%">194</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Code&nbsp;covered:</td>
          <td class="coverPerLeftHi" width="15%">78.4%</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Executed&nbsp;lines:</td>
          <td class="headerValue" width="10%">152</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
</table>
<pre class="source">
<span class="lineNum">    1</span>              : #include &lt;elf.hh&gt; </span>
<span class="lineNum">    2</span>              : #include &lt;engine.hh&gt; </span>
<span class="lineNum">    3</span>              : #include &lt;utils.hh&gt; </span>
<span class="lineNum">    4</span>              : #include &lt;filter.hh&gt; </span>
<span class="lineNum">    5</span>              : #include &lt;phdr_data.h&gt; </span>
<span class="lineNum">    6</span>              :  </span>
<span class="lineNum">    7</span>              : #include &lt;sys&#047;types.h&gt; </span>
<span class="lineNum">    8</span>              : #include &lt;sys&#047;stat.h&gt; </span>
<span class="lineNum">    9</span>              : #include &lt;fcntl.h&gt; </span>
<span class="lineNum">   10</span>              : #include &lt;libelf.h&gt; </span>
<span class="lineNum">   11</span>              : #include &lt;dwarf.h&gt; </span>
<span class="lineNum">   12</span>              : #include &lt;elfutils&#047;libdw.h&gt; </span>
<span class="lineNum">   13</span>              : #include &lt;map&gt; </span>
<span class="lineNum">   14</span>              : #include &lt;list&gt; </span>
<span class="lineNum">   15</span>              : #include &lt;string&gt; </span>
<span class="lineNum">   16</span>              :  </span>
<span class="lineNum">   17</span>              : #ifndef _GNU_SOURCE </span>
<span class="lineNum">   18</span>              : # define _GNU_SOURCE </span>
<span class="lineNum">   19</span>              : #endif </span>
<span class="lineNum">   20</span>              : #include &lt;link.h&gt; </span>
<span class="lineNum">   21</span>              :  </span>
<span class="lineNum">   22</span>              : using namespace kcov; </span>
<span class="lineNum">   23</span>              :  </span>
<span class="lineNum">   24</span>              : enum SymbolType </span>
<span class="lineNum">   25</span>              : { </span>
<span class="lineNum">   26</span>              : 	SYM_NORMAL = 0, </span>
<span class="lineNum">   27</span>              : 	SYM_DYNAMIC = 1, </span>
<span class="lineNum">   28</span>              : }; </span>
<span class="lineNum">   29</span>              :  </span>
<span class="lineNum">   30</span>              : class Elf : public IElf </span>
<span class="lineNum">   31</span>              : { </span>
<span class="lineNum">   32</span>              : public: </span>
<span class="lineNum">   33</span><span class="linePartCov">      2  /   4: 	Elf() : m_filter(IFilter::getInstance()) </span>
<span class="lineNum">   34</span>              : 	{ </span>
<span class="lineNum">   35</span><span class="lineCov">      1  /   1: 		m_elf = NULL; </span>
<span class="lineNum">   36</span><span class="lineCov">      1  /   1: 		m_filename = NULL; </span>
<span class="lineNum">   37</span><span class="lineCov">      1  /   1: 		m_checksum = 0; </span>
<span class="lineNum">   38</span><span class="lineCov">      1  /   1: 		m_elfIs32Bit = true; </span>
<span class="lineNum">   39</span><span class="lineCov">      1  /   1: 	} </span>
<span class="lineNum">   40</span><span class="lineCov">      2  /   2: 	virtual ~Elf() </span>
<span class="lineNum">   41</span><span class="linePartCov">      2  /   3: 	{ </span>
<span class="lineNum">   42</span><span class="lineCov">      1  /   1: 		free((void *)m_filename); </span>
<span class="lineNum">   43</span><span class="linePartCov">      3  /   5: 	} </span>
<span class="lineNum">   44</span>              :  </span>
<span class="lineNum">   45</span><span class="lineCov">      1  /   1: 	const char *getFilename() </span>
<span class="lineNum">   46</span>              : 	{ </span>
<span class="lineNum">   47</span><span class="lineCov">      1  /   1: 		return m_filename; </span>
<span class="lineNum">   48</span><span class="linePartCov">      1  /   2: 	} </span>
<span class="lineNum">   49</span>              :  </span>
<span class="lineNum">   50</span><span class="lineCov">      1  /   1: 	uint64_t getChecksum() </span>
<span class="lineNum">   51</span>              : 	{ </span>
<span class="lineNum">   52</span><span class="lineCov">      1  /   1: 		return m_checksum; </span>
<span class="lineNum">   53</span><span class="linePartCov">      1  /   2: 	} </span>
<span class="lineNum">   54</span>              :  </span>
<span class="lineNum">   55</span><span class="lineCov">      1  /   1: 	bool addFile(const char *filename, struct phdr_data_entry *data = 0) </span>
<span class="lineNum">   56</span>              : 	{ </span>
<span class="lineNum">   57</span><span class="lineCov">      1  /   1: 		free((void *)m_filename); </span>
<span class="lineNum">   58</span><span class="lineCov">      1  /   1: 		m_filename = strdup(filename); </span>
<span class="lineNum">   59</span>              :  </span>
<span class="lineNum">   60</span><span class="lineCov">      1  /   1: 		m_curSegments.clear(); </span>
<span class="lineNum">   61</span><span class="linePartCov">      1  /   2: 		for (uint32_t i = 0; data &amp;&amp; i &lt; data-&gt;n_segments; i++) { </span>
<span class="lineNum">   62</span><span class="lineNoCov">      0  /   1: 			struct phdr_data_segment *seg = &amp;data-&gt;segments[i]; </span>
<span class="lineNum">   63</span>              :  </span>
<span class="lineNum">   64</span><span class="lineNoCov">      0  /   1: 			m_curSegments.push_back(Segment(seg-&gt;paddr, seg-&gt;vaddr, seg-&gt;size)); </span>
<span class="lineNum">   65</span>              : 		} </span>
<span class="lineNum">   66</span>              :  </span>
<span class="lineNum">   67</span><span class="lineCov">      1  /   1: 		return checkFile(); </span>
<span class="lineNum">   68</span><span class="linePartCov">      1  /   2: 	} </span>
<span class="lineNum">   69</span>              :  </span>
<span class="lineNum">   70</span><span class="lineCov">      1  /   1: 	bool checkFile() </span>
<span class="lineNum">   71</span>              : 	{ </span>
<span class="lineNum">   72</span>              : 		Elf *elf; </span>
<span class="lineNum">   73</span><span class="lineCov">      1  /   1: 		bool out = true; </span>
<span class="lineNum">   74</span>              : 		int fd; </span>
<span class="lineNum">   75</span>              :  </span>
<span class="lineNum">   76</span><span class="lineCov">      1  /   1: 		fd = ::open(m_filename, O_RDONLY, 0); </span>
<span class="lineNum">   77</span><span class="lineCov">      1  /   1: 		if (fd &lt; 0) { </span>
<span class="lineNum">   78</span><span class="lineCov">      1  /   1: 				error(&quot;Cannot open %s&#092;n&quot;, m_filename); </span>
<span class="lineNum">   79</span><span class="lineCov">      1  /   1: 				return false; </span>
<span class="lineNum">   80</span>              : 		} </span>
<span class="lineNum">   81</span>              :  </span>
<span class="lineNum">   82</span><span class="lineCov">      1  /   1: 		if (!(elf = elf_begin(fd, ELF_C_READ, NULL)) ) { </span>
<span class="lineNum">   83</span><span class="lineNoCov">      0  /   1: 				error(&quot;elf_begin failed on %s&#092;n&quot;, m_filename); </span>
<span class="lineNum">   84</span><span class="lineNoCov">      0  /   1: 				out = false; </span>
<span class="lineNum">   85</span><span class="lineNoCov">      0  /   1: 				goto out_open; </span>
<span class="lineNum">   86</span>              : 		} </span>
<span class="lineNum">   87</span><span class="lineCov">      1  /   1: 		if (elf_kind(elf) == ELF_K_NONE) </span>
<span class="lineNum">   88</span><span class="lineCov">      1  /   1: 			out = false; </span>
<span class="lineNum">   89</span>              :  </span>
<span class="lineNum">   90</span><span class="lineCov">      1  /   1: 		elf_end(elf); </span>
<span class="lineNum">   91</span>              :  </span>
<span class="lineNum">   92</span>              : out_open: </span>
<span class="lineNum">   93</span><span class="lineCov">      1  /   1: 		close(fd); </span>
<span class="lineNum">   94</span>              :  </span>
<span class="lineNum">   95</span><span class="lineCov">      1  /   1: 		return out; </span>
<span class="lineNum">   96</span><span class="linePartCov">      1  /   2: 	} </span>
<span class="lineNum">   97</span>              :  </span>
<span class="lineNum">   98</span><span class="lineCov">      1  /   1: 	bool parse() </span>
<span class="lineNum">   99</span>              : 	{ </span>
<span class="lineNum">  100</span>              : 		struct stat st; </span>
<span class="lineNum">  101</span>              :  </span>
<span class="lineNum">  102</span><span class="lineCov">      1  /   1: 		if (lstat(m_filename, &amp;st) &lt; 0) </span>
<span class="lineNum">  103</span><span class="lineNoCov">      0  /   1: 			return 0; </span>
<span class="lineNum">  104</span>              :  </span>
<span class="lineNum">  105</span><span class="lineCov">      1  /   1: 		m_checksum = ((uint64_t)st.st_mtim.tv_sec &lt;&lt; 32) | ((uint64_t)st.st_mtim.tv_nsec); </span>
<span class="lineNum">  106</span>              :  </span>
<span class="lineNum">  107</span><span class="lineCov">      1  /   1: 		parseOneElf(); </span>
<span class="lineNum">  108</span><span class="lineCov">      1  /   1: 		parseOneDwarf(); </span>
<span class="lineNum">  109</span>              :  </span>
<span class="lineNum">  110</span><span class="lineCov">      1  /   1: 		return true; </span>
<span class="lineNum">  111</span><span class="linePartCov">      1  /   2: 	} </span>
<span class="lineNum">  112</span>              :  </span>
<span class="lineNum">  113</span><span class="lineCov">      1  /   1: 	bool parseOneDwarf() </span>
<span class="lineNum">  114</span>              : 	{ </span>
<span class="lineNum">  115</span><span class="lineCov">      1  /   1: 		Dwarf_Off offset = 0; </span>
<span class="lineNum">  116</span><span class="lineCov">      1  /   1: 		Dwarf_Off last_offset = 0; </span>
<span class="lineNum">  117</span>              : 		size_t hdr_size; </span>
<span class="lineNum">  118</span>              : 		Dwarf *dbg; </span>
<span class="lineNum">  119</span>              : 		int fd; </span>
<span class="lineNum">  120</span>              :  </span>
<span class="lineNum">  121</span><span class="lineCov">      1  /   1: 		fd = ::open(m_filename, O_RDONLY, 0); </span>
<span class="lineNum">  122</span><span class="lineCov">      1  /   1: 		if (fd &lt; 0) { </span>
<span class="lineNum">  123</span><span class="lineNoCov">      0  /   1: 				error(&quot;Cannot open %s&#092;n&quot;, m_filename); </span>
<span class="lineNum">  124</span><span class="lineNoCov">      0  /   1: 				return false; </span>
<span class="lineNum">  125</span>              : 		} </span>
<span class="lineNum">  126</span>              :  </span>
<span class="lineNum">  127</span>              : 		&#047;* Initialize libdwarf *&#047; </span>
<span class="lineNum">  128</span><span class="lineCov">      1  /   1: 		dbg = dwarf_begin(fd, DWARF_C_READ); </span>
<span class="lineNum">  129</span><span class="lineCov">      1  /   1: 		if (!dbg) { </span>
<span class="lineNum">  130</span><span class="lineNoCov">      0  /   1: 			kcov_debug(ELF_MSG, &quot;No debug symbols in %s.&#092;n&quot;, m_filename); </span>
<span class="lineNum">  131</span><span class="lineNoCov">      0  /   1: 			close(fd); </span>
<span class="lineNum">  132</span><span class="lineNoCov">      0  /   1: 			return false; </span>
<span class="lineNum">  133</span>              : 		} </span>
<span class="lineNum">  134</span>              :  </span>
<span class="lineNum">  135</span>              : 		&#047;* Iterate over the headers *&#047; </span>
<span class="lineNum">  136</span><span class="lineCov">      2  /   2: 		while (dwarf_nextcu(dbg, offset, &amp;offset, &amp;hdr_size, 0, 0, 0) == 0) { </span>
<span class="lineNum">  137</span>              : 			Dwarf_Lines* line_buffer; </span>
<span class="lineNum">  138</span>              : 			Dwarf_Files *file_buffer; </span>
<span class="lineNum">  139</span>              : 			size_t line_count; </span>
<span class="lineNum">  140</span>              : 			size_t file_count; </span>
<span class="lineNum">  141</span>              : 			Dwarf_Die die; </span>
<span class="lineNum">  142</span>              : 			unsigned int i; </span>
<span class="lineNum">  143</span>              :  </span>
<span class="lineNum">  144</span><span class="lineCov">      1  /   1: 			if (dwarf_offdie(dbg, last_offset + hdr_size, &amp;die) == NULL) </span>
<span class="lineNum">  145</span><span class="lineNoCov">      0  /   1: 				goto out_err; </span>
<span class="lineNum">  146</span>              :  </span>
<span class="lineNum">  147</span><span class="lineCov">      1  /   1: 			last_offset = offset; </span>
<span class="lineNum">  148</span>              :  </span>
<span class="lineNum">  149</span>              : 			&#047;* Get the source lines *&#047; </span>
<span class="lineNum">  150</span><span class="lineCov">      1  /   1: 			if (dwarf_getsrclines(&amp;die, &amp;line_buffer, &amp;line_count) != 0) </span>
<span class="lineNum">  151</span><span class="lineNoCov">      0  /   1: 				continue; </span>
<span class="lineNum">  152</span>              :  </span>
<span class="lineNum">  153</span>              : 			&#047;* And the files *&#047; </span>
<span class="lineNum">  154</span><span class="lineCov">      1  /   1: 			if (dwarf_getsrcfiles(&amp;die, &amp;file_buffer, &amp;file_count) != 0) </span>
<span class="lineNum">  155</span><span class="lineNoCov">      0  /   1: 				continue; </span>
<span class="lineNum">  156</span>              :  </span>
<span class="lineNum">  157</span>              : 			&#047;* Store them *&#047; </span>
<span class="lineNum">  158</span><span class="lineCov">      2  /   2: 			for (i = 0; i &lt; line_count; i++) { </span>
<span class="lineNum">  159</span>              : 				Dwarf_Line *line; </span>
<span class="lineNum">  160</span>              : 				int line_nr; </span>
<span class="lineNum">  161</span>              : 				const char* line_source; </span>
<span class="lineNum">  162</span>              : 				Dwarf_Word mtime, len; </span>
<span class="lineNum">  163</span>              : 				bool is_code; </span>
<span class="lineNum">  164</span>              : 				Dwarf_Addr addr; </span>
<span class="lineNum">  165</span>              :  </span>
<span class="lineNum">  166</span><span class="lineCov">      1  /   1: 				if ( !(line = dwarf_onesrcline(line_buffer, i)) ) </span>
<span class="lineNum">  167</span><span class="lineNoCov">      0  /   1: 					goto out_err; </span>
<span class="lineNum">  168</span><span class="lineCov">      1  /   1: 				if (dwarf_lineno(line, &amp;line_nr) != 0) </span>
<span class="lineNum">  169</span><span class="lineNoCov">      0  /   1: 					goto out_err; </span>
<span class="lineNum">  170</span><span class="lineCov">      1  /   1: 				if (!(line_source = dwarf_linesrc(line, &amp;mtime, &amp;len)) ) </span>
<span class="lineNum">  171</span><span class="lineNoCov">      0  /   1: 					goto out_err; </span>
<span class="lineNum">  172</span><span class="lineCov">      1  /   1: 				if (dwarf_linebeginstatement(line, &amp;is_code) != 0) </span>
<span class="lineNum">  173</span><span class="lineNoCov">      0  /   1: 					goto out_err; </span>
<span class="lineNum">  174</span>              :  </span>
<span class="lineNum">  175</span><span class="lineCov">      1  /   1: 				if (dwarf_lineaddr(line, &amp;addr) != 0) </span>
<span class="lineNum">  176</span><span class="lineNoCov">      0  /   1: 					goto out_err; </span>
<span class="lineNum">  177</span>              :  </span>
<span class="lineNum">  178</span><span class="lineCov">      1  /   1: 				if (line_nr &amp;&amp; is_code) { </span>
<span class="lineNum">  179</span>              : 					const char *const *src_dirs; </span>
<span class="lineNum">  180</span>              : 					const char *full_file_path; </span>
<span class="lineNum">  181</span><span class="lineCov">      1  /   1: 					const char *file_path = line_source; </span>
<span class="lineNum">  182</span><span class="lineCov">      1  /   1: 					size_t ndirs = 0; </span>
<span class="lineNum">  183</span>              :  </span>
<span class="lineNum">  184</span>              : 					&#047;* Lookup the compilation path *&#047; </span>
<span class="lineNum">  185</span><span class="lineCov">      1  /   1: 					if (dwarf_getsrcdirs(file_buffer, &amp;src_dirs, &amp;ndirs) != 0) </span>
<span class="lineNum">  186</span><span class="lineNoCov">      0  /   1: 						continue; </span>
<span class="lineNum">  187</span>              :  </span>
<span class="lineNum">  188</span><span class="lineCov">      1  /   1: 					if (ndirs == 0) </span>
<span class="lineNum">  189</span><span class="lineNoCov">      0  /   1: 						continue; </span>
<span class="lineNum">  190</span>              :  </span>
<span class="lineNum">  191</span><span class="lineCov">      1  /   1: 					if (!addressIsValid(addr)) </span>
<span class="lineNum">  192</span><span class="lineCov">      1  /   1: 						continue; </span>
<span class="lineNum">  193</span>              :  </span>
<span class="lineNum">  194</span>              : 					&#047;* Use the full compilation path unless the source already </span>
<span class="lineNum">  195</span>              : 					 * has an absolute path *&#047; </span>
<span class="lineNum">  196</span><span class="lineCov">      1  /   1: 					full_file_path = dir_concat(src_dirs[0], line_source); </span>
<span class="lineNum">  197</span><span class="lineCov">      1  /   1: 					if (line_source[0] != &#039;&#047;&#039;) </span>
<span class="lineNum">  198</span><span class="lineNoCov">      0  /   1: 						file_path = full_file_path; </span>
<span class="lineNum">  199</span>              :  </span>
<span class="lineNum">  200</span><span class="lineCov">      1  /   1: 					char *rp = ::realpath(file_path, NULL); </span>
<span class="lineNum">  201</span>              :  </span>
<span class="lineNum">  202</span><span class="lineCov">      1  /   1: 					if (rp) </span>
<span class="lineNum">  203</span>              : 					{ </span>
<span class="lineNum">  204</span><span class="lineCov">      1  /   1: 						free((void *)full_file_path); </span>
<span class="lineNum">  205</span><span class="lineCov">      1  /   1: 						file_path = full_file_path = rp; </span>
<span class="lineNum">  206</span>              : 					} </span>
<span class="lineNum">  207</span>              :  </span>
<span class="lineNum">  208</span><span class="linePartCov">      1  /   3: 					if (m_filter.runFilters(file_path) == true) </span>
<span class="lineNum">  209</span>              : 					{ </span>
<span class="lineNum">  210</span><span class="lineCov">      5  /   5: 						for (ListenerList_t::iterator it = m_listeners.begin(); </span>
<span class="lineNum">  211</span><span class="lineCov">      2  /   2: 								it != m_listeners.end(); </span>
<span class="lineNum">  212</span><span class="lineCov">      1  /   1: 								it++) </span>
<span class="lineNum">  213</span><span class="lineCov">      1  /   1: 							(*it)-&gt;onLine(file_path, line_nr, adjustAddressBySegment(addr)); </span>
<span class="lineNum">  214</span>              : 					} </span>
<span class="lineNum">  215</span>              :  </span>
<span class="lineNum">  216</span><span class="lineCov">      1  /   1: 					free((void *)full_file_path); </span>
<span class="lineNum">  217</span>              : 				} </span>
<span class="lineNum">  218</span>              : 			} </span>
<span class="lineNum">  219</span>              : 		} </span>
<span class="lineNum">  220</span>              :  </span>
<span class="lineNum">  221</span>              : out_err: </span>
<span class="lineNum">  222</span>              : 		&#047;* Shutdown libdwarf *&#047; </span>
<span class="lineNum">  223</span><span class="lineCov">      1  /   1: 		if (dwarf_end(dbg) != 0) </span>
<span class="lineNum">  224</span><span class="lineNoCov">      0  /   1: 			goto out_err; </span>
<span class="lineNum">  225</span>              :  </span>
<span class="lineNum">  226</span><span class="lineCov">      1  /   1: 		close(fd); </span>
<span class="lineNum">  227</span>              :  </span>
<span class="lineNum">  228</span><span class="lineCov">      1  /   1: 		return true; </span>
<span class="lineNum">  229</span><span class="lineCov">      1  /   1: 	} </span>
<span class="lineNum">  230</span>              :  </span>
<span class="lineNum">  231</span><span class="lineCov">      1  /   1: 	bool parseOneElf() </span>
<span class="lineNum">  232</span>              : 	{ </span>
<span class="lineNum">  233</span><span class="lineCov">      1  /   1: 		Elf_Scn *scn = NULL; </span>
<span class="lineNum">  234</span>              : 		size_t shstrndx; </span>
<span class="lineNum">  235</span><span class="lineCov">      1  /   1: 		bool ret = false; </span>
<span class="lineNum">  236</span><span class="lineCov">      1  /   1: 		bool setupSegments = false; </span>
<span class="lineNum">  237</span>              : 		size_t sz; </span>
<span class="lineNum">  238</span>              : 		char *raw; </span>
<span class="lineNum">  239</span>              : 		int fd; </span>
<span class="lineNum">  240</span>              :  </span>
<span class="lineNum">  241</span><span class="lineCov">      1  /   1: 		fd = ::open(m_filename, O_RDONLY, 0); </span>
<span class="lineNum">  242</span><span class="lineCov">      1  /   1: 		if (fd &lt; 0) { </span>
<span class="lineNum">  243</span><span class="lineNoCov">      0  /   1: 				error(&quot;Cannot open %s&#092;n&quot;, m_filename); </span>
<span class="lineNum">  244</span><span class="lineNoCov">      0  /   1: 				return false; </span>
<span class="lineNum">  245</span>              : 		} </span>
<span class="lineNum">  246</span>              :  </span>
<span class="lineNum">  247</span><span class="lineCov">      1  /   1: 		if (!(m_elf = elf_begin(fd, ELF_C_READ, NULL)) ) { </span>
<span class="lineNum">  248</span><span class="lineNoCov">      0  /   1: 				error(&quot;elf_begin failed on %s&#092;n&quot;, m_filename); </span>
<span class="lineNum">  249</span><span class="lineNoCov">      0  /   1: 				goto out_open; </span>
<span class="lineNum">  250</span>              : 		} </span>
<span class="lineNum">  251</span>              :  </span>
<span class="lineNum">  252</span><span class="lineCov">      1  /   1: 		raw = elf_getident(m_elf, &amp;sz); </span>
<span class="lineNum">  253</span>              :  </span>
<span class="lineNum">  254</span><span class="lineCov">      1  /   1: 		if (raw &amp;&amp; sz &gt; EI_CLASS) </span>
<span class="lineNum">  255</span><span class="lineCov">      1  /   1: 			m_elfIs32Bit = raw[EI_CLASS] == ELFCLASS32; </span>
<span class="lineNum">  256</span>              :  </span>
<span class="lineNum">  257</span><span class="lineCov">      1  /   1: 		if (elf_getshdrstrndx(m_elf, &amp;shstrndx) &lt; 0) { </span>
<span class="lineNum">  258</span><span class="lineNoCov">      0  /   1: 				error(&quot;elf_getshstrndx failed on %s&#092;n&quot;, m_filename); </span>
<span class="lineNum">  259</span><span class="lineNoCov">      0  /   1: 				goto out_elf_begin; </span>
<span class="lineNum">  260</span>              : 		} </span>
<span class="lineNum">  261</span>              :  </span>
<span class="lineNum">  262</span><span class="lineCov">      1  /   1: 		setupSegments = m_curSegments.size() == 0; </span>
<span class="lineNum">  263</span><span class="lineCov">      2  /   2: 		while ( (scn = elf_nextscn(m_elf, scn)) != NULL ) </span>
<span class="lineNum">  264</span>              : 		{ </span>
<span class="lineNum">  265</span>              : 			uint64_t sh_addr; </span>
<span class="lineNum">  266</span>              : 			uint64_t sh_size; </span>
<span class="lineNum">  267</span>              : 			uint64_t sh_flags; </span>
<span class="lineNum">  268</span>              : 			uint64_t sh_name; </span>
<span class="lineNum">  269</span>              : 			char *name; </span>
<span class="lineNum">  270</span>              :  </span>
<span class="lineNum">  271</span><span class="lineCov">      1  /   1: 			if (m_elfIs32Bit) { </span>
<span class="lineNum">  272</span><span class="lineCov">      1  /   1: 				Elf32_Shdr *shdr32 = elf32_getshdr(scn); </span>
<span class="lineNum">  273</span>              :  </span>
<span class="lineNum">  274</span><span class="lineCov">      1  /   1: 				sh_addr = shdr32-&gt;sh_addr; </span>
<span class="lineNum">  275</span><span class="lineCov">      1  /   1: 				sh_size = shdr32-&gt;sh_size; </span>
<span class="lineNum">  276</span><span class="lineCov">      1  /   1: 				sh_flags = shdr32-&gt;sh_flags; </span>
<span class="lineNum">  277</span><span class="lineCov">      1  /   1: 				sh_name = shdr32-&gt;sh_name; </span>
<span class="lineNum">  278</span>              : 			} else { </span>
<span class="lineNum">  279</span><span class="lineNoCov">      0  /   1: 				Elf64_Shdr *shdr64 = elf64_getshdr(scn); </span>
<span class="lineNum">  280</span>              :  </span>
<span class="lineNum">  281</span><span class="lineNoCov">      0  /   1: 				sh_addr = shdr64-&gt;sh_addr; </span>
<span class="lineNum">  282</span><span class="lineNoCov">      0  /   1: 				sh_size = shdr64-&gt;sh_size; </span>
<span class="lineNum">  283</span><span class="lineNoCov">      0  /   1: 				sh_flags = shdr64-&gt;sh_flags; </span>
<span class="lineNum">  284</span><span class="lineNoCov">      0  /   1: 				sh_name = shdr64-&gt;sh_name; </span>
<span class="lineNum">  285</span>              : 			} </span>
<span class="lineNum">  286</span>              :  </span>
<span class="lineNum">  287</span><span class="lineCov">      1  /   1: 			Elf_Data *data = elf_getdata(scn, NULL); </span>
<span class="lineNum">  288</span>              :  </span>
<span class="lineNum">  289</span><span class="lineCov">      1  /   1: 			name = elf_strptr(m_elf, shstrndx, sh_name); </span>
<span class="lineNum">  290</span><span class="lineCov">      1  /   1: 			if(!data) { </span>
<span class="lineNum">  291</span><span class="lineNoCov">      0  /   1: 					error(&quot;elf_getdata failed on section %s in %s&#092;n&quot;, </span>
<span class="lineNum">  292</span>              : 							name, m_filename); </span>
<span class="lineNum">  293</span><span class="lineNoCov">      0  /   1: 					goto out_elf_begin; </span>
<span class="lineNum">  294</span>              : 			} </span>
<span class="lineNum">  295</span>              :  </span>
<span class="lineNum">  296</span>              : 			&#047;&#047; If we have segments already, we can safely skip this </span>
<span class="lineNum">  297</span><span class="lineCov">      1  /   1: 			if (!setupSegments) </span>
<span class="lineNum">  298</span><span class="lineCov">      1  /   1: 				continue; </span>
<span class="lineNum">  299</span>              :  </span>
<span class="lineNum">  300</span><span class="lineCov">      1  /   1: 			if ((sh_flags &amp; (SHF_EXECINSTR | SHF_ALLOC)) == 0) </span>
<span class="lineNum">  301</span><span class="lineCov">      1  /   1: 				continue; </span>
<span class="lineNum">  302</span>              :  </span>
<span class="lineNum">  303</span><span class="lineCov">      1  /   1: 			m_curSegments.push_back(Segment(sh_addr, sh_addr, sh_size)); </span>
<span class="lineNum">  304</span>              : 		} </span>
<span class="lineNum">  305</span><span class="lineCov">      1  /   1: 		elf_end(m_elf); </span>
<span class="lineNum">  306</span><span class="lineCov">      1  /   1: 		if (!(m_elf = elf_begin(fd, ELF_C_READ, NULL)) ) { </span>
<span class="lineNum">  307</span><span class="lineNoCov">      0  /   1: 			error(&quot;elf_begin failed on %s&#092;n&quot;, m_filename); </span>
<span class="lineNum">  308</span><span class="lineNoCov">      0  /   1: 			goto out_open; </span>
<span class="lineNum">  309</span>              : 		} </span>
<span class="lineNum">  310</span>              :  </span>
<span class="lineNum">  311</span><span class="lineCov">      1  /   1: 		ret = true; </span>
<span class="lineNum">  312</span>              :  </span>
<span class="lineNum">  313</span>              : out_elf_begin: </span>
<span class="lineNum">  314</span><span class="lineCov">      1  /   1: 		elf_end(m_elf); </span>
<span class="lineNum">  315</span>              : out_open: </span>
<span class="lineNum">  316</span><span class="lineCov">      1  /   1: 		close(fd); </span>
<span class="lineNum">  317</span>              :  </span>
<span class="lineNum">  318</span><span class="lineCov">      1  /   1: 		return ret; </span>
<span class="lineNum">  319</span><span class="linePartCov">      1  /   2: 	} </span>
<span class="lineNum">  320</span>              :  </span>
<span class="lineNum">  321</span><span class="lineCov">      1  /   1: 	void registerListener(IListener &amp;listener) </span>
<span class="lineNum">  322</span>              : 	{ </span>
<span class="lineNum">  323</span><span class="lineCov">      1  /   1: 		m_listeners.push_back(&amp;listener); </span>
<span class="lineNum">  324</span><span class="linePartCov">      1  /   2: 	} </span>
<span class="lineNum">  325</span>              :  </span>
<span class="lineNum">  326</span>              : private: </span>
<span class="lineNum">  327</span>              : 	class Segment </span>
<span class="lineNum">  328</span>              : 	{ </span>
<span class="lineNum">  329</span>              : 	public: </span>
<span class="lineNum">  330</span><span class="lineCov">      1  /   1: 		Segment(uint64_t paddr, uint64_t vaddr, uint64_t size) : </span>
<span class="lineNum">  331</span><span class="lineCov">      1  /   1: 			m_paddr(paddr), m_vaddr(vaddr), m_size(size) </span>
<span class="lineNum">  332</span>              : 		{ </span>
<span class="lineNum">  333</span><span class="linePartCov">      1  /   2: 		} </span>
<span class="lineNum">  334</span>              :  </span>
<span class="lineNum">  335</span>              : 		uint64_t m_paddr; </span>
<span class="lineNum">  336</span>              : 		uint64_t m_vaddr; </span>
<span class="lineNum">  337</span>              : 		size_t m_size; </span>
<span class="lineNum">  338</span>              : 	}; </span>
<span class="lineNum">  339</span>              :  </span>
<span class="lineNum">  340</span>              : 	typedef std::list&lt;Segment&gt; SegmentList_t; </span>
<span class="lineNum">  341</span>              : 	typedef std::list&lt;IListener *&gt; ListenerList_t; </span>
<span class="lineNum">  342</span>              :  </span>
<span class="lineNum">  343</span><span class="lineCov">      1  /   1: 	bool addressIsValid(uint64_t addr) </span>
<span class="lineNum">  344</span>              : 	{ </span>
<span class="lineNum">  345</span><span class="lineCov">      5  /   5: 		for (SegmentList_t::iterator it = m_curSegments.begin(); </span>
<span class="lineNum">  346</span><span class="lineCov">      3  /   3: 				it != m_curSegments.end(); it++) { </span>
<span class="lineNum">  347</span><span class="lineCov">      1  /   1: 			Segment cur = *it; </span>
<span class="lineNum">  348</span>              :  </span>
<span class="lineNum">  349</span><span class="lineCov">      1  /   1: 			if (addr &gt;= cur.m_paddr &amp;&amp; addr &lt; cur.m_paddr + cur.m_size) { </span>
<span class="lineNum">  350</span><span class="lineCov">      1  /   1: 				return true; </span>
<span class="lineNum">  351</span>              : 			} </span>
<span class="lineNum">  352</span>              : 		} </span>
<span class="lineNum">  353</span>              :  </span>
<span class="lineNum">  354</span><span class="lineCov">      1  /   1: 		return false; </span>
<span class="lineNum">  355</span><span class="linePartCov">      1  /   2: 	} </span>
<span class="lineNum">  356</span>              :  </span>
<span class="lineNum">  357</span><span class="lineCov">      1  /   1: 	uint64_t adjustAddressBySegment(uint64_t addr) </span>
<span class="lineNum">  358</span>              : 	{ </span>
<span class="lineNum">  359</span><span class="lineCov">      5  /   5: 		for (SegmentList_t::iterator it = m_curSegments.begin(); </span>
<span class="lineNum">  360</span><span class="lineCov">      3  /   3: 				it != m_curSegments.end(); it++) { </span>
<span class="lineNum">  361</span><span class="lineCov">      1  /   1: 			Segment cur = *it; </span>
<span class="lineNum">  362</span>              :  </span>
<span class="lineNum">  363</span><span class="lineCov">      1  /   1: 			if (addr &gt;= cur.m_paddr &amp;&amp; addr &lt; cur.m_paddr + cur.m_size) { </span>
<span class="lineNum">  364</span><span class="lineCov">      1  /   1: 				addr = (addr - cur.m_paddr + cur.m_vaddr); </span>
<span class="lineNum">  365</span><span class="lineCov">      1  /   1: 				break; </span>
<span class="lineNum">  366</span>              : 			} </span>
<span class="lineNum">  367</span>              : 		} </span>
<span class="lineNum">  368</span>              :  </span>
<span class="lineNum">  369</span><span class="lineCov">      1  /   1: 		return addr; </span>
<span class="lineNum">  370</span><span class="linePartCov">      1  /   2: 	} </span>
<span class="lineNum">  371</span>              :  </span>
<span class="lineNum">  372</span>              : 	SegmentList_t m_curSegments; </span>
<span class="lineNum">  373</span>              : 	IFilter &amp;m_filter; </span>
<span class="lineNum">  374</span>              :  </span>
<span class="lineNum">  375</span>              : 	Elf *m_elf; </span>
<span class="lineNum">  376</span>              : 	bool m_elfIs32Bit; </span>
<span class="lineNum">  377</span>              : 	ListenerList_t m_listeners; </span>
<span class="lineNum">  378</span>              : 	IListener *m_listener; </span>
<span class="lineNum">  379</span>              : 	const char *m_filename; </span>
<span class="lineNum">  380</span>              : 	uint64_t m_checksum; </span>
<span class="lineNum">  381</span>              : }; </span>
<span class="lineNum">  382</span>              :  </span>
<span class="lineNum">  383</span>              : static Elf *g_instance; </span>
<span class="lineNum">  384</span>              : IElf *IElf::open(const char *filename) </span>
<span class="lineNum">  385</span><span class="lineCov">      1  /   1: { </span>
<span class="lineNum">  386</span>              : 	static bool initialized = false; </span>
<span class="lineNum">  387</span>              :  </span>
<span class="lineNum">  388</span><span class="lineCov">      1  /   1: 	if (!initialized) { </span>
<span class="lineNum">  389</span><span class="lineCov">      1  /   1: 		panic_if(elf_version(EV_CURRENT) == EV_NONE, </span>
<span class="lineNum">  390</span>              : 				&quot;ELF version failed&#092;n&quot;); </span>
<span class="lineNum">  391</span><span class="lineCov">      1  /   1: 		initialized = true; </span>
<span class="lineNum">  392</span>              : 	} </span>
<span class="lineNum">  393</span>              :  </span>
<span class="lineNum">  394</span><span class="linePartCov">      1  /   2: 	g_instance = new Elf(); </span>
<span class="lineNum">  395</span>              :  </span>
<span class="lineNum">  396</span><span class="lineCov">      1  /   1: 	if (g_instance-&gt;addFile(filename) == false) { </span>
<span class="lineNum">  397</span><span class="lineCov">      1  /   1: 		delete g_instance; </span>
<span class="lineNum">  398</span>              :  </span>
<span class="lineNum">  399</span><span class="lineCov">      1  /   1: 		g_instance = NULL; </span>
<span class="lineNum">  400</span>              :  </span>
<span class="lineNum">  401</span><span class="lineCov">      1  /   1: 		return NULL; </span>
<span class="lineNum">  402</span>              : 	} </span>
<span class="lineNum">  403</span>              :  </span>
<span class="lineNum">  404</span><span class="lineCov">      1  /   1: 	return g_instance; </span>
<span class="lineNum">  405</span><span class="lineCov">      1  /   1: } </span>
<span class="lineNum">  406</span>              :  </span>
<span class="lineNum">  407</span>              : IElf &amp;IElf::getInstance() </span>
<span class="lineNum">  408</span><span class="lineNoCov">      0  /   1: { </span>
<span class="lineNum">  409</span><span class="lineNoCov">      0  /   1: 	panic_if (!g_instance, </span>
<span class="lineNum">  410</span>              : 			&quot;ELF object not yet created&quot;); </span>
<span class="lineNum">  411</span>              :  </span>
<span class="lineNum">  412</span><span class="lineNoCov">      0  /   1: 	return *g_instance; </span>
<span class="lineNum">  413</span><span class="lineNoCov">      0  /   2: } </span>
</pre>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr><td class="versionInfo">Generated by: <a href="http://simonkagstrom.github.com/kcov/index.html">Kcov</a> (based on <a href="http://bcov.sourceforge.net">bcov</a>)</td></tr>
</table>
<br/>
</body>
</html>
