<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Coverage - frodo</title>
  <link rel="stylesheet" type="text/css" href="bcov.css"/>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="title">Coverage Report</td></tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr>
    <td width="100%">
      <table cellpadding="1" border="0" width="100%">
        <tr>
          <td class="headerItem" width="20%">Command:</td>
          <td class="headerValue" width="80%" colspan=6>frodo</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Date:</td>
          <td class="headerValue" width="15%">2012-06-16 11:50:06</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Instrumented&nbsp;lines:</td>
          <td class="headerValue" width="10%">153</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Code&nbsp;covered:</td>
          <td class="coverPerLeftMed" width="15%">54.2%</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Executed&nbsp;lines:</td>
          <td class="headerValue" width="10%">83</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
</table>
<pre class="source">
<span class="lineNum">    1</span>              : #include &lt;stdlib.h&gt; </span>
<span class="lineNum">    2</span>              : #include &lt;stdio.h&gt; </span>
<span class="lineNum">    3</span>              : #include &lt;dirent.h&gt; </span>
<span class="lineNum">    4</span>              : #include &lt;png.h&gt; </span>
<span class="lineNum">    5</span>              : #include &lt;sys&#047;stat.h&gt; </span>
<span class="lineNum">    6</span>              : #include &lt;SDL_ttf.h&gt; </span>
<span class="lineNum">    7</span>              : #include &lt;SDL_image.h&gt; </span>
<span class="lineNum">    8</span>              :  </span>
<span class="lineNum">    9</span>              : #include &lt;sysdeps.h&gt; </span>
<span class="lineNum">   10</span>              : #include &lt;C64.h&gt; </span>
<span class="lineNum">   11</span>              : #include &lt;Network.h&gt; </span>
<span class="lineNum">   12</span>              :  </span>
<span class="lineNum">   13</span>              : #include &quot;gui&#047;font.hh&quot; </span>
<span class="lineNum">   14</span>              : #include &quot;utils.hh&quot; </span>
<span class="lineNum">   15</span>              :  </span>
<span class="lineNum">   16</span>              : TTF_Font *read_and_alloc_font(const char *path, int pt_size) </span>
<span class="lineNum">   17</span><span class="lineCov">      1  /   1: { </span>
<span class="lineNum">   18</span>              : 	TTF_Font *out; </span>
<span class="lineNum">   19</span>              : 	SDL_RWops *rw; </span>
<span class="lineNum">   20</span>              : 	Uint8 *data; </span>
<span class="lineNum">   21</span><span class="lineCov">      2  /   2: 	FILE *fp = fopen(path, &quot;r&quot;); </span>
<span class="lineNum">   22</span>              : 	size_t r; </span>
<span class="lineNum">   23</span>              :  </span>
<span class="lineNum">   24</span><span class="lineCov">      2  /   2: 	if (!fp) { </span>
<span class="lineNum">   25</span>              : 		LOG(&quot;Could not open font %s&#092;n&quot;, path); </span>
<span class="lineNum">   26</span><span class="lineNoCov">      0  /   2: 		return NULL; </span>
<span class="lineNum">   27</span>              : 	} </span>
<span class="lineNum">   28</span>              : 	data = (Uint8*)xmalloc(1 * 1024*1024); </span>
<span class="lineNum">   29</span>              : 	r = fread(data, 1, 1 * 1024 * 1024, fp); </span>
<span class="lineNum">   30</span><span class="lineCov">      2  /   2: 	if (r == 0 || ferror(fp)) </span>
<span class="lineNum">   31</span>              : 	{ </span>
<span class="lineNum">   32</span>              : 		free(data); </span>
<span class="lineNum">   33</span>              : 		return NULL; </span>
<span class="lineNum">   34</span>              : 	} </span>
<span class="lineNum">   35</span><span class="lineCov">      1  /   1: 	rw = SDL_RWFromMem(data, 1 * 1024 * 1024); </span>
<span class="lineNum">   36</span><span class="lineCov">      1  /   1: 	if (!rw) </span>
<span class="lineNum">   37</span>              : 	{ </span>
<span class="lineNum">   38</span><span class="lineNoCov">      0  /   1: 		LOG(&quot;Could not create RW: %s&#092;n&quot;, SDL_GetError()); </span>
<span class="lineNum">   39</span><span class="lineNoCov">      0  /   2: 		free(data); </span>
<span class="lineNum">   40</span><span class="lineNoCov">      0  /   1: 		return NULL; </span>
<span class="lineNum">   41</span>              : 	} </span>
<span class="lineNum">   42</span><span class="lineCov">      2  /   2: 	out = TTF_OpenFontRW(rw, 1, pt_size); </span>
<span class="lineNum">   43</span><span class="lineCov">      2  /   2: 	if (!out) </span>
<span class="lineNum">   44</span>              : 	{ </span>
<span class="lineNum">   45</span><span class="lineNoCov">      0  /   1: 		LOG(&quot;TTF: Unable to create font %s (%s)&#092;n&quot;, </span>
<span class="lineNum">   46</span>              : 				path, TTF_GetError()); </span>
<span class="lineNum">   47</span>              : 	} </span>
<span class="lineNum">   48</span><span class="lineCov">      1  /   1: 	fclose(fp); </span>
<span class="lineNum">   49</span>              :  </span>
<span class="lineNum">   50</span>              : 	return out; </span>
<span class="lineNum">   51</span><span class="linePartCov">      1  /   2: } </span>
<span class="lineNum">   52</span>              :  </span>
<span class="lineNum">   53</span>              :  </span>
<span class="lineNum">   54</span>              :  </span>
<span class="lineNum">   55</span>              : static int cmpstringp(const void *p1, const void *p2) </span>
<span class="lineNum">   56</span><span class="lineCov">      1  /   1: { </span>
<span class="lineNum">   57</span><span class="lineCov">      1  /   1: 	const char *p1_s = *(const char**)p1; </span>
<span class="lineNum">   58</span><span class="lineCov">      2  /   2: 	const char *p2_s = *(const char**)p2; </span>
<span class="lineNum">   59</span>              :  </span>
<span class="lineNum">   60</span>              : 	&#047;* Put directories first and handle some special cases *&#047; </span>
<span class="lineNum">   61</span><span class="lineCov">      4  /   4: 	if (*p1_s == &#039;[&#039; &amp;&amp; *p2_s != &#039;[&#039;) </span>
<span class="lineNum">   62</span><span class="lineCov">      1  /   1: 		return -1; </span>
<span class="lineNum">   63</span><span class="lineCov">      1  /   1: 	if (*p1_s != &#039;[&#039; &amp;&amp; *p2_s == &#039;[&#039;) </span>
<span class="lineNum">   64</span><span class="lineCov">      1  /   1: 		return 1; </span>
<span class="lineNum">   65</span><span class="lineCov">      2  /   2: 	return strcmp(* (char * const *) p1, * (char * const *) p2); </span>
<span class="lineNum">   66</span><span class="lineCov">      3  /   3: } </span>
<span class="lineNum">   67</span>              :  </span>
<span class="lineNum">   68</span>              : &#047;* Return true if name ends with ext (for filenames) *&#047; </span>
<span class="lineNum">   69</span>              : static bool ext_matches(const char *name, const char *ext) </span>
<span class="lineNum">   70</span>              : { </span>
<span class="lineNum">   71</span>              : 	int len = strlen(name); </span>
<span class="lineNum">   72</span><span class="lineCov">      1  /   1: 	int ext_len = strlen(ext); </span>
<span class="lineNum">   73</span>              :  </span>
<span class="lineNum">   74</span><span class="lineCov">      1  /   1: 	if (len &lt;= ext_len) </span>
<span class="lineNum">   75</span>              : 		return false; </span>
<span class="lineNum">   76</span><span class="lineCov">      1  /   1: 	return (strcmp(name + len - ext_len, ext) == 0); </span>
<span class="lineNum">   77</span>              : } </span>
<span class="lineNum">   78</span>              :  </span>
<span class="lineNum">   79</span><span class="lineCov">      1  /   1: bool ext_matches_list(const char *name, const char **exts) </span>
<span class="lineNum">   80</span><span class="lineCov">      3  /   3: { </span>
<span class="lineNum">   81</span><span class="lineCov">      2  /   2: 	for (const char **p = exts; *p; p++) </span>
<span class="lineNum">   82</span>              : 	{ </span>
<span class="lineNum">   83</span><span class="lineCov">      1  /   1: 		if (ext_matches(name, *p)) </span>
<span class="lineNum">   84</span><span class="lineCov">      1  /   1: 			return true; </span>
<span class="lineNum">   85</span>              : 	} </span>
<span class="lineNum">   86</span>              :  </span>
<span class="lineNum">   87</span><span class="lineCov">      2  /   2: 	return false; </span>
<span class="lineNum">   88</span><span class="lineCov">      2  /   2: } </span>
<span class="lineNum">   89</span>              :  </span>
<span class="lineNum">   90</span>              : const char **get_file_list(const char *base_dir, const char *exts[]) </span>
<span class="lineNum">   91</span><span class="lineCov">      2  /   2: { </span>
<span class="lineNum">   92</span><span class="lineCov">      2  /   2: 	DIR *d = opendir(base_dir); </span>
<span class="lineNum">   93</span>              : 	const char **file_list; </span>
<span class="lineNum">   94</span>              : 	int cur = 0; </span>
<span class="lineNum">   95</span>              : 	struct dirent *de; </span>
<span class="lineNum">   96</span>              : 	int cnt = 16; </span>
<span class="lineNum">   97</span>              :  </span>
<span class="lineNum">   98</span><span class="lineCov">      2  /   2: 	if (!d) </span>
<span class="lineNum">   99</span><span class="lineCov">      1  /   1: 		return NULL; </span>
<span class="lineNum">  100</span>              :  </span>
<span class="lineNum">  101</span><span class="lineCov">      2  /   2: 	file_list = (const char**)malloc(cnt * sizeof(char*)); </span>
<span class="lineNum">  102</span><span class="lineCov">      3  /   3: 	file_list[cur++] = strdup(&quot;None&quot;); </span>
<span class="lineNum">  103</span><span class="lineCov">      1  /   1: 	file_list[cur] = NULL; </span>
<span class="lineNum">  104</span>              :  </span>
<span class="lineNum">  105</span><span class="linePartCov">      4  /   5: 	for (de = readdir(d); </span>
<span class="lineNum">  106</span>              : 	de; </span>
<span class="lineNum">  107</span>              : 	de = readdir(d)) </span>
<span class="lineNum">  108</span>              : 	{ </span>
<span class="lineNum">  109</span>              : 		char buf[255]; </span>
<span class="lineNum">  110</span>              : 		struct stat st; </span>
<span class="lineNum">  111</span>              :  </span>
<span class="lineNum">  112</span><span class="lineCov">      2  /   2: 		snprintf(buf, 255, &quot;%s&#047;%s&quot;, base_dir, de-&gt;d_name); </span>
<span class="lineNum">  113</span><span class="lineCov">      2  /   2: 		if (stat(buf, &amp;st) &lt; 0) </span>
<span class="lineNum">  114</span>              : 			continue; </span>
<span class="lineNum">  115</span><span class="lineCov">      1  /   1: 		if (S_ISDIR(st.st_mode)) </span>
<span class="lineNum">  116</span>              : 		{ </span>
<span class="lineNum">  117</span>              : 			char *p; </span>
<span class="lineNum">  118</span><span class="lineCov">      4  /   4: 			size_t len = strlen(de-&gt;d_name) + 4; </span>
<span class="lineNum">  119</span>              :  </span>
<span class="lineNum">  120</span>              : 			&#047;* We don&#039;t need the current dir *&#047; </span>
<span class="lineNum">  121</span><span class="lineCov">      3  /   3: 			if (strcmp(de-&gt;d_name, &quot;.&quot;) == 0) </span>
<span class="lineNum">  122</span>              : 				continue; </span>
<span class="lineNum">  123</span><span class="lineCov">      2  /   2: 			p = (char*)malloc( len ); </span>
<span class="lineNum">  124</span>              : 			snprintf(p, len, &quot;[%s]&quot;, de-&gt;d_name); </span>
<span class="lineNum">  125</span><span class="lineCov">      1  /   1: 			file_list[cur++] = p; </span>
<span class="lineNum">  126</span><span class="lineCov">      1  /   1: 			file_list[cur] = NULL; </span>
<span class="lineNum">  127</span>              : 		} </span>
<span class="lineNum">  128</span><span class="lineCov">      1  /   1: 		else if (ext_matches_list(de-&gt;d_name, exts)) </span>
<span class="lineNum">  129</span>              : 		{ </span>
<span class="lineNum">  130</span>              : 			char *p; </span>
<span class="lineNum">  131</span>              :  </span>
<span class="lineNum">  132</span><span class="lineCov">      1  /   1: 			p = strdup(de-&gt;d_name); </span>
<span class="lineNum">  133</span><span class="lineCov">      1  /   1: 			file_list[cur++] = p; </span>
<span class="lineNum">  134</span><span class="lineCov">      1  /   1: 			file_list[cur] = NULL; </span>
<span class="lineNum">  135</span>              : 		} </span>
<span class="lineNum">  136</span>              :  </span>
<span class="lineNum">  137</span><span class="lineCov">      1  /   1: 		if (cur &gt; cnt - 2) </span>
<span class="lineNum">  138</span>              : 		{ </span>
<span class="lineNum">  139</span><span class="lineCov">      1  /   1: 			cnt = cnt + 32; </span>
<span class="lineNum">  140</span><span class="lineCov">      2  /   2: 			file_list = (const char**)realloc(file_list, cnt * sizeof(char*)); </span>
<span class="lineNum">  141</span><span class="lineCov">      2  /   2: 			if (!file_list) </span>
<span class="lineNum">  142</span>              : 				return NULL; </span>
<span class="lineNum">  143</span>              : 		} </span>
<span class="lineNum">  144</span>              : 	} </span>
<span class="lineNum">  145</span><span class="lineCov">      1  /   1: 	closedir(d); </span>
<span class="lineNum">  146</span><span class="lineCov">      1  /   1:         qsort(&amp;file_list[1], cur-1, sizeof(const char *), cmpstringp); </span>
<span class="lineNum">  147</span>              :  </span>
<span class="lineNum">  148</span><span class="lineCov">      1  /   1:         return file_list; </span>
<span class="lineNum">  149</span><span class="linePartCov">      1  /   2: } </span>
<span class="lineNum">  150</span>              :  </span>
<span class="lineNum">  151</span>              :  </span>
<span class="lineNum">  152</span>              : &#047;* PNG writing *&#047; </span>
<span class="lineNum">  153</span>              : struct  png_write_user_struct </span>
<span class="lineNum">  154</span>              : { </span>
<span class="lineNum">  155</span>              : 	size_t sz; </span>
<span class="lineNum">  156</span>              : 	void *data; </span>
<span class="lineNum">  157</span>              : }; </span>
<span class="lineNum">  158</span>              :  </span>
<span class="lineNum">  159</span>              : static void user_write_fn(png_structp png_ptr, png_bytep bytes, png_size_t sz) </span>
<span class="lineNum">  160</span><span class="lineNoCov">      0  /   2: { </span>
<span class="lineNum">  161</span><span class="lineNoCov">      0  /   2: 	struct png_write_user_struct *out = (struct png_write_user_struct *)png_ptr-&gt;io_ptr; </span>
<span class="lineNum">  162</span>              :  </span>
<span class="lineNum">  163</span><span class="lineNoCov">      0  /   2: 	out-&gt;data = xrealloc(out-&gt;data, out-&gt;sz + sz); </span>
<span class="lineNum">  164</span><span class="lineNoCov">      0  /   1: 	memcpy((uint8_t*)out-&gt;data + out-&gt;sz, bytes, sz); </span>
<span class="lineNum">  165</span><span class="lineNoCov">      0  /   1: 	out-&gt;sz += sz; </span>
<span class="lineNum">  166</span><span class="lineNoCov">      0  /   1: } </span>
<span class="lineNum">  167</span>              :  </span>
<span class="lineNum">  168</span>              :  </span>
<span class="lineNum">  169</span>              : static int png_colortype_from_surface(SDL_Surface *surface) </span>
<span class="lineNum">  170</span>              : { </span>
<span class="lineNum">  171</span>              : 	int colortype = PNG_COLOR_MASK_COLOR; &#047;* grayscale not supported *&#047; </span>
<span class="lineNum">  172</span>              :  </span>
<span class="lineNum">  173</span><span class="lineNoCov">      0  /   1: 	if (surface-&gt;format-&gt;palette) </span>
<span class="lineNum">  174</span>              : 		colortype |= PNG_COLOR_MASK_PALETTE; </span>
<span class="lineNum">  175</span>              :  </span>
<span class="lineNum">  176</span>              : 	return colortype; </span>
<span class="lineNum">  177</span>              : } </span>
<span class="lineNum">  178</span>              :  </span>
<span class="lineNum">  179</span>              :  </span>
<span class="lineNum">  180</span>              : static void png_user_warn(png_structp ctx, png_const_charp str) </span>
<span class="lineNum">  181</span><span class="lineNoCov">      0  /   1: { </span>
<span class="lineNum">  182</span>              : 	LOG(&quot;libpng: warning: %s&#092;n&quot;, str); </span>
<span class="lineNum">  183</span><span class="lineNoCov">      0  /   1: } </span>
<span class="lineNum">  184</span>              :  </span>
<span class="lineNum">  185</span>              :  </span>
<span class="lineNum">  186</span>              : static void png_user_error(png_structp ctx, png_const_charp str) </span>
<span class="lineNum">  187</span><span class="lineNoCov">      0  /   1: { </span>
<span class="lineNum">  188</span>              : 	LOG(&quot;libpng: error: %s&#092;n&quot;, str); </span>
<span class="lineNum">  189</span><span class="lineNoCov">      0  /   1: } </span>
<span class="lineNum">  190</span>              :  </span>
<span class="lineNum">  191</span>              : extern SDL_Color sdl_palette[PALETTE_SIZE]; </span>
<span class="lineNum">  192</span>              :  </span>
<span class="lineNum">  193</span>              : &#047;* This is taken from http:&#047;&#047;encelo.netsons.org&#047;programming&#047;sdl (GPLed) *&#047; </span>
<span class="lineNum">  194</span><span class="lineNoCov">      0  /   1: void *sdl_surface_to_png(SDL_Surface *surf, size_t *out_sz) </span>
<span class="lineNum">  195</span><span class="lineNoCov">      0  /   1: { </span>
<span class="lineNum">  196</span>              : 	png_structp png_ptr; </span>
<span class="lineNum">  197</span>              : 	png_infop info_ptr; </span>
<span class="lineNum">  198</span>              : 	int i, colortype; </span>
<span class="lineNum">  199</span>              : 	png_bytep *row_pointers; </span>
<span class="lineNum">  200</span>              : 	png_colorp palette; </span>
<span class="lineNum">  201</span>              : 	struct png_write_user_struct out; </span>
<span class="lineNum">  202</span>              :  </span>
<span class="lineNum">  203</span><span class="lineNoCov">      0  /   1: 	if (!surf) </span>
<span class="lineNum">  204</span><span class="lineNoCov">      0  /   1: 		return NULL; </span>
<span class="lineNum">  205</span>              :  </span>
<span class="lineNum">  206</span><span class="lineNoCov">      0  /   1: 	out.sz = 0; </span>
<span class="lineNum">  207</span><span class="lineNoCov">      0  /   1: 	out.data = NULL; </span>
<span class="lineNum">  208</span>              :  </span>
<span class="lineNum">  209</span>              : 	&#047;* Initializing png structures and callbacks *&#047; </span>
<span class="lineNum">  210</span>              : 	png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, </span>
<span class="lineNum">  211</span><span class="lineNoCov">      0  /   2: 		NULL, png_user_error, png_user_warn); </span>
<span class="lineNum">  212</span><span class="lineNoCov">      0  /   2: 	if (png_ptr == NULL) { </span>
<span class="lineNum">  213</span>              : 		printf(&quot;png_create_write_struct error!&#092;n&quot;); </span>
<span class="lineNum">  214</span><span class="lineNoCov">      0  /   1: 		return NULL; </span>
<span class="lineNum">  215</span>              : 	} </span>
<span class="lineNum">  216</span>              :  </span>
<span class="lineNum">  217</span><span class="lineNoCov">      0  /   2: 	info_ptr = png_create_info_struct(png_ptr); </span>
<span class="lineNum">  218</span><span class="lineNoCov">      0  /   2: 	if (info_ptr == NULL) { </span>
<span class="lineNum">  219</span><span class="lineNoCov">      0  /   1: 		png_destroy_write_struct(&amp;png_ptr, (png_infopp)NULL); </span>
<span class="lineNum">  220</span>              : 		printf(&quot;png_create_info_struct error!&#092;n&quot;); </span>
<span class="lineNum">  221</span><span class="lineNoCov">      0  /   1: 		exit(-1); </span>
<span class="lineNum">  222</span>              : 	} </span>
<span class="lineNum">  223</span>              :  </span>
<span class="lineNum">  224</span><span class="lineNoCov">      0  /   1: 	if (setjmp(png_jmpbuf(png_ptr))) { </span>
<span class="lineNum">  225</span><span class="lineNoCov">      0  /   1: 		png_destroy_write_struct(&amp;png_ptr, &amp;info_ptr); </span>
<span class="lineNum">  226</span><span class="lineNoCov">      0  /   1: 		exit(-1); </span>
<span class="lineNum">  227</span>              : 	} </span>
<span class="lineNum">  228</span>              :  </span>
<span class="lineNum">  229</span><span class="lineNoCov">      0  /   1: 	png_set_write_fn(png_ptr, (void *)&amp;out, user_write_fn, NULL); </span>
<span class="lineNum">  230</span>              :  </span>
<span class="lineNum">  231</span>              : 	colortype = png_colortype_from_surface(surf); </span>
<span class="lineNum">  232</span>              : 	png_set_IHDR(png_ptr, info_ptr, surf-&gt;w, surf-&gt;h, 8, colortype,	PNG_INTERLACE_NONE, </span>
<span class="lineNum">  233</span><span class="lineNoCov">      0  /   2: 		PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT); </span>
<span class="lineNum">  234</span>              :  </span>
<span class="lineNum">  235</span>              : 	if (colortype &amp; PNG_COLOR_MASK_PALETTE) </span>
<span class="lineNum">  236</span>              : 	{ </span>
<span class="lineNum">  237</span>              : 		&#047;* Set the palette if there is one.  REQUIRED for indexed-color images *&#047; </span>
<span class="lineNum">  238</span>              : 		palette = (png_colorp)png_malloc(png_ptr, </span>
<span class="lineNum">  239</span><span class="lineNoCov">      0  /   2: 				PNG_MAX_PALETTE_LENGTH * png_sizeof(png_color)); </span>
<span class="lineNum">  240</span>              :  </span>
<span class="lineNum">  241</span>              : 		&#047;* KLUDGE! For some reason, surf-&gt;format-&gt;palette doesn&#039;t work... *&#047; </span>
<span class="lineNum">  242</span><span class="lineNoCov">      0  /   3: 		for (int i = 0; i &lt; PALETTE_SIZE; i++) </span>
<span class="lineNum">  243</span>              : 		{ </span>
<span class="lineNum">  244</span>              : 			SDL_Color *p = &amp;sdl_palette[i]; </span>
<span class="lineNum">  245</span>              :  </span>
<span class="lineNum">  246</span><span class="lineNoCov">      0  /   1: 			palette[i].red = p-&gt;r; </span>
<span class="lineNum">  247</span><span class="lineNoCov">      0  /   1: 			palette[i].green = p-&gt;g; </span>
<span class="lineNum">  248</span><span class="lineNoCov">      0  /   2: 			palette[i].blue = p-&gt;b; </span>
<span class="lineNum">  249</span>              : 		} </span>
<span class="lineNum">  250</span>              : 		&#047;* ... Set palette colors ... *&#047; </span>
<span class="lineNum">  251</span><span class="lineNoCov">      0  /   1: 		png_set_PLTE(png_ptr, info_ptr, palette, PNG_MAX_PALETTE_LENGTH); </span>
<span class="lineNum">  252</span>              : 	} </span>
<span class="lineNum">  253</span>              :  </span>
<span class="lineNum">  254</span>              : 	&#047;* Writing the image *&#047; </span>
<span class="lineNum">  255</span><span class="lineNoCov">      0  /   1: 	png_write_info(png_ptr, info_ptr); </span>
<span class="lineNum">  256</span><span class="lineNoCov">      0  /   1: 	png_set_packing(png_ptr); </span>
<span class="lineNum">  257</span>              :  </span>
<span class="lineNum">  258</span><span class="lineNoCov">      0  /   1: 	row_pointers = (png_bytep*) xmalloc(sizeof(png_bytep)*surf-&gt;h); </span>
<span class="lineNum">  259</span><span class="lineNoCov">      0  /   3: 	for (i = 0; i &lt; surf-&gt;h; i++) </span>
<span class="lineNum">  260</span><span class="lineNoCov">      0  /   1: 		row_pointers[i] = (png_bytep)(Uint8 *)surf-&gt;pixels + i*surf-&gt;pitch; </span>
<span class="lineNum">  261</span><span class="lineNoCov">      0  /   1: 	png_write_image(png_ptr, row_pointers); </span>
<span class="lineNum">  262</span><span class="lineNoCov">      0  /   1: 	png_write_end(png_ptr, info_ptr); </span>
<span class="lineNum">  263</span>              :  </span>
<span class="lineNum">  264</span>              : 	&#047;* Cleaning out... *&#047; </span>
<span class="lineNum">  265</span><span class="lineNoCov">      0  /   1: 	free(row_pointers); </span>
<span class="lineNum">  266</span><span class="lineNoCov">      0  /   1: 	png_destroy_write_struct(&amp;png_ptr, &amp;info_ptr); </span>
<span class="lineNum">  267</span>              :  </span>
<span class="lineNum">  268</span><span class="lineNoCov">      0  /   1: 	*out_sz = out.sz; </span>
<span class="lineNum">  269</span>              :  </span>
<span class="lineNum">  270</span><span class="lineNoCov">      0  /   1: 	return out.data; </span>
<span class="lineNum">  271</span><span class="lineNoCov">      0  /   2: } </span>
<span class="lineNum">  272</span>              :  </span>
<span class="lineNum">  273</span>              : SDL_Surface *sdl_surface_from_data(void *data, size_t sz) </span>
<span class="lineNum">  274</span><span class="lineCov">      2  /   2: { </span>
<span class="lineNum">  275</span>              : 	SDL_RWops *rw; </span>
<span class="lineNum">  276</span>              : 	SDL_Surface *out; </span>
<span class="lineNum">  277</span>              :  </span>
<span class="lineNum">  278</span><span class="lineCov">      3  /   3: 	rw = SDL_RWFromMem(data, sz); </span>
<span class="lineNum">  279</span><span class="lineCov">      2  /   2: 	if (!rw) </span>
<span class="lineNum">  280</span><span class="lineCov">      1  /   1: 		return NULL; </span>
<span class="lineNum">  281</span>              :  </span>
<span class="lineNum">  282</span><span class="lineCov">      2  /   2: 	out = IMG_Load_RW(rw, 0); </span>
<span class="lineNum">  283</span><span class="lineCov">      2  /   2: 	SDL_FreeRW(rw); </span>
<span class="lineNum">  284</span>              :  </span>
<span class="lineNum">  285</span>              : 	return out; </span>
<span class="lineNum">  286</span><span class="lineCov">      1  /   1: } </span>
<span class="lineNum">  287</span>              :  </span>
<span class="lineNum">  288</span>              : SDL_Surface *sdl_surface_8bit_copy(SDL_Surface *src) </span>
<span class="lineNum">  289</span><span class="lineNoCov">      0  /   1: { </span>
<span class="lineNum">  290</span>              : 	Uint32 rmask,gmask,bmask,amask; </span>
<span class="lineNum">  291</span>              : 	SDL_Surface *out; </span>
<span class="lineNum">  292</span>              :  </span>
<span class="lineNum">  293</span>              : #if SDL_BYTEORDER == SDL_BIG_ENDIAN </span>
<span class="lineNum">  294</span>              : 	rmask = 0xff000000; </span>
<span class="lineNum">  295</span>              : 	gmask = 0x00ff0000; </span>
<span class="lineNum">  296</span>              : 	bmask = 0x0000ff00; </span>
<span class="lineNum">  297</span>              : 	amask = 0x000000ff; </span>
<span class="lineNum">  298</span>              : #else </span>
<span class="lineNum">  299</span>              : 	rmask = 0x000000ff; </span>
<span class="lineNum">  300</span>              : 	gmask = 0x0000ff00; </span>
<span class="lineNum">  301</span>              : 	bmask = 0x00ff0000; </span>
<span class="lineNum">  302</span>              : 	amask = 0xff000000; </span>
<span class="lineNum">  303</span>              : #endif </span>
<span class="lineNum">  304</span><span class="lineNoCov">      0  /   1: 	if (!src) </span>
<span class="lineNum">  305</span><span class="lineNoCov">      0  /   1: 		return NULL; </span>
<span class="lineNum">  306</span><span class="lineNoCov">      0  /   1: 	if (src-&gt;format-&gt;BitsPerPixel != 8) </span>
<span class="lineNum">  307</span>              : 		return NULL; </span>
<span class="lineNum">  308</span>              :  </span>
<span class="lineNum">  309</span>              : 	out = SDL_CreateRGBSurface(SDL_SWSURFACE, src-&gt;w, src-&gt;h, 8, </span>
<span class="lineNum">  310</span><span class="lineNoCov">      0  /   2: 			rmask, gmask, bmask, amask); </span>
<span class="lineNum">  311</span><span class="lineNoCov">      0  /   2: 	if (!out) </span>
<span class="lineNum">  312</span>              : 		return NULL; </span>
<span class="lineNum">  313</span><span class="lineNoCov">      0  /   1: 	memcpy(out-&gt;pixels, src-&gt;pixels, src-&gt;h * src-&gt;pitch); </span>
<span class="lineNum">  314</span>              :  </span>
<span class="lineNum">  315</span><span class="lineNoCov">      0  /   1: 	SDL_SetColors(out, sdl_palette, 0, PALETTE_SIZE); </span>
<span class="lineNum">  316</span>              :  </span>
<span class="lineNum">  317</span><span class="lineNoCov">      0  /   1: 	return out; </span>
<span class="lineNum">  318</span><span class="lineNoCov">      0  /   1: } </span>
<span class="lineNum">  319</span>              :  </span>
<span class="lineNum">  320</span>              :  </span>
<span class="lineNum">  321</span>              : void highlight_background(SDL_Surface *where, Font *font, </span>
<span class="lineNum">  322</span>              : 		SDL_Surface *bg_left, SDL_Surface *bg_middle, SDL_Surface *bg_right, </span>
<span class="lineNum">  323</span>              : 		int x, int y, int w, int h) </span>
<span class="lineNum">  324</span><span class="lineCov">      2  /   2: { </span>
<span class="lineNum">  325</span>              : 	SDL_Rect dst; </span>
<span class="lineNum">  326</span>              :  </span>
<span class="lineNum">  327</span>              : 	&#047;* Can&#039;t highlight without images *&#047; </span>
<span class="lineNum">  328</span><span class="lineCov">      1  /   1: 	if (!bg_left ||	!bg_middle || !bg_right) </span>
<span class="lineNum">  329</span>              : 		return; </span>
<span class="lineNum">  330</span>              :  </span>
<span class="lineNum">  331</span><span class="lineCov">      1  /   1: 	int font_height = font-&gt;getHeight(&quot;X&quot;); </span>
<span class="lineNum">  332</span>              : 	int bg_y_start = y + font_height &#047; 2 - </span>
<span class="lineNum">  333</span><span class="lineCov">      3  /   3: 			bg_left-&gt;h &#047; 2; </span>
<span class="lineNum">  334</span><span class="lineCov">      4  /   4: 	int bg_x_start = x - bg_left-&gt;w &#047; 3; </span>
<span class="lineNum">  335</span><span class="lineCov">      2  /   2: 	int bg_x_end = x + w - (2 * bg_right-&gt;w) &#047; 3; </span>
<span class="lineNum">  336</span><span class="lineCov">      2  /   2: 	int n_mid = (bg_x_end - bg_x_start) &#047; bg_middle-&gt;w; </span>
<span class="lineNum">  337</span>              :  </span>
<span class="lineNum">  338</span>              : 	&#047;* Left *&#047; </span>
<span class="lineNum">  339</span><span class="lineCov">      3  /   3: 	dst = (SDL_Rect){bg_x_start, bg_y_start, 0,0}; </span>
<span class="lineNum">  340</span><span class="lineCov">      2  /   2: 	SDL_BlitSurface(bg_left, NULL, where, &amp;dst); </span>
<span class="lineNum">  341</span>              :  </span>
<span class="lineNum">  342</span>              : 	&#047;* Middle *&#047; </span>
<span class="lineNum">  343</span><span class="lineCov">      3  /   3: 	for (int i = 1; i &lt; n_mid; i++) </span>
<span class="lineNum">  344</span>              : 	{ </span>
<span class="lineNum">  345</span><span class="lineCov">      4  /   4: 		dst = (SDL_Rect){bg_x_start + i * bg_middle-&gt;w, bg_y_start, 0,0}; </span>
<span class="lineNum">  346</span><span class="lineCov">      3  /   3: 		SDL_BlitSurface(bg_middle, NULL, where, &amp;dst); </span>
<span class="lineNum">  347</span>              : 	} </span>
<span class="lineNum">  348</span><span class="lineCov">      4  /   4: 	dst = (SDL_Rect){bg_x_end - bg_middle-&gt;w, bg_y_start, 0,0}; </span>
<span class="lineNum">  349</span><span class="lineCov">      4  /   4: 	SDL_BlitSurface(bg_middle, NULL, where, &amp;dst); </span>
<span class="lineNum">  350</span>              :  </span>
<span class="lineNum">  351</span>              : 	&#047;* Right *&#047; </span>
<span class="lineNum">  352</span><span class="lineCov">      3  /   3: 	dst = (SDL_Rect){bg_x_end, bg_y_start, 0,0}; </span>
<span class="lineNum">  353</span><span class="lineCov">      3  /   3: 	SDL_BlitSurface(bg_right, NULL,	where, &amp;dst); </span>
<span class="lineNum">  354</span><span class="lineCov">      1  /   1: } </span>
<span class="lineNum">  355</span>              :  </span>
<span class="lineNum">  356</span>              : const char *ip_to_str(uint8_t *ip_in) </span>
<span class="lineNum">  357</span><span class="lineNoCov">      0  /   2: { </span>
<span class="lineNum">  358</span>              : 	char *out = (char *)xmalloc(24); </span>
<span class="lineNum">  359</span>              : 	int ip[4]; </span>
<span class="lineNum">  360</span>              :  </span>
<span class="lineNum">  361</span><span class="lineNoCov">      0  /   2: 	for (int i = 0; i &lt; 4; i++) </span>
<span class="lineNum">  362</span>              : 	{ </span>
<span class="lineNum">  363</span>              : 		char tmp[3]; </span>
<span class="lineNum">  364</span>              : 		char *endp; </span>
<span class="lineNum">  365</span>              :  </span>
<span class="lineNum">  366</span><span class="lineNoCov">      0  /   1: 		tmp[0] = ip_in[i * 2]; </span>
<span class="lineNum">  367</span><span class="lineNoCov">      0  /   2: 		tmp[1] = ip_in[i * 2 + 1]; </span>
<span class="lineNum">  368</span><span class="lineNoCov">      0  /   1: 		tmp[2] = &#039;&#092;0&#039;; </span>
<span class="lineNum">  369</span><span class="lineNoCov">      0  /   3: 		ip[i] = strtoul(tmp, &amp;endp, 16); </span>
<span class="lineNum">  370</span><span class="lineNoCov">      0  /   3: 		panic_if (endp == (const char*)tmp, </span>
<span class="lineNum">  371</span>              : 			&quot;Could not convert ip to str.&#092;n&quot;); </span>
<span class="lineNum">  372</span>              : 	} </span>
<span class="lineNum">  373</span>              : 	sprintf(out, &quot;%d.%d.%d.%d&quot;, ip[3], ip[2], ip[1], ip[0]); </span>
<span class="lineNum">  374</span>              :  </span>
<span class="lineNum">  375</span>              : 	return out; </span>
<span class="lineNum">  376</span><span class="lineNoCov">      0  /   1: } </span>
<span class="lineNum">  377</span>              :  </span>
<span class="lineNum">  378</span>              : const char *region_to_str(int region) </span>
<span class="lineNum">  379</span><span class="lineCov">      2  /   2: { </span>
<span class="lineNum">  380</span>              : 	switch (region) </span>
<span class="lineNum">  381</span>              : 	{ </span>
<span class="lineNum">  382</span>              : 	case REGION_EUROPE: return &quot;Europe&quot;; </span>
<span class="lineNum">  383</span>              : 	case REGION_AFRICA: return &quot;Africa&quot;; </span>
<span class="lineNum">  384</span>              : 	case REGION_NORTH_AMERICA: return &quot;North America&quot;; </span>
<span class="lineNum">  385</span>              : 	case REGION_SOUTH_AMERICA: return &quot;South America&quot;; </span>
<span class="lineNum">  386</span>              : 	case REGION_EAST_ASIA: return &quot;East asia&quot;; </span>
<span class="lineNum">  387</span>              : 	case REGION_SOUTH_ASIA: return &quot;South asia&quot;; </span>
<span class="lineNum">  388</span>              : 	case REGION_MIDDLE_EAST: return &quot;Middle east&quot;; </span>
<span class="lineNum">  389</span>              : 	case REGION_OCEANIA: return &quot;Oceania&quot;; </span>
<span class="lineNum">  390</span>              : 	case REGION_ANTARTICA: return &quot;Antartica&quot;; &#047;&#047; Likely, yes </span>
<span class="lineNum">  391</span>              : 	default: </span>
<span class="lineNum">  392</span>              : 		break; </span>
<span class="lineNum">  393</span>              : 	} </span>
<span class="lineNum">  394</span>              :  </span>
<span class="lineNum">  395</span>              : 	return &quot;Unknown&quot;; </span>
<span class="lineNum">  396</span><span class="linePartCov">      1  /   2: } </span>
</pre>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr><td class="versionInfo">Generated by: <a href="http://simonkagstrom.github.com/kcov/index.html">Kcov</a> (based on <a href="http://bcov.sourceforge.net">bcov</a>)</td></tr>
</table>
<br/>
</body>
</html>
