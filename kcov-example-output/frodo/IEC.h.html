<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Coverage - frodo</title>
  <link rel="stylesheet" type="text/css" href="bcov.css"/>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="title">Coverage Report</td></tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr>
    <td width="100%">
      <table cellpadding="1" border="0" width="100%">
        <tr>
          <td class="headerItem" width="20%">Command:</td>
          <td class="headerValue" width="80%" colspan=6>frodo</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Date:</td>
          <td class="headerValue" width="15%">2012-06-16 11:50:06</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Instrumented&nbsp;lines:</td>
          <td class="headerValue" width="10%">3</td>
        </tr>
        <tr>
          <td class="headerItem" width="20%">Code&nbsp;covered:</td>
          <td class="coverPerLeftMed" width="15%">33.3%</td>
          <td width="5%"></td>
          <td class="headerItem" width="20%">Executed&nbsp;lines:</td>
          <td class="headerValue" width="10%">1</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
</table>
<pre class="source">
<span class="lineNum">    1</span>              : &#047;* </span>
<span class="lineNum">    2</span>              :  *  IEC.h - IEC bus routines, 1541 emulation (DOS level) </span>
<span class="lineNum">    3</span>              :  * </span>
<span class="lineNum">    4</span>              :  *  Frodo (C) 1994-1997,2002-2005 Christian Bauer </span>
<span class="lineNum">    5</span>              :  * </span>
<span class="lineNum">    6</span>              :  *  This program is free software; you can redistribute it and&#047;or modify </span>
<span class="lineNum">    7</span>              :  *  it under the terms of the GNU General Public License as published by </span>
<span class="lineNum">    8</span>              :  *  the Free Software Foundation; either version 2 of the License, or </span>
<span class="lineNum">    9</span>              :  *  (at your option) any later version. </span>
<span class="lineNum">   10</span>              :  * </span>
<span class="lineNum">   11</span>              :  *  This program is distributed in the hope that it will be useful, </span>
<span class="lineNum">   12</span>              :  *  but WITHOUT ANY WARRANTY; without even the implied warranty of </span>
<span class="lineNum">   13</span>              :  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the </span>
<span class="lineNum">   14</span>              :  *  GNU General Public License for more details. </span>
<span class="lineNum">   15</span>              :  * </span>
<span class="lineNum">   16</span>              :  *  You should have received a copy of the GNU General Public License </span>
<span class="lineNum">   17</span>              :  *  along with this program; if not, write to the Free Software </span>
<span class="lineNum">   18</span>              :  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA </span>
<span class="lineNum">   19</span>              :  *&#047; </span>
<span class="lineNum">   20</span>              :  </span>
<span class="lineNum">   21</span>              : #ifndef _IEC_H </span>
<span class="lineNum">   22</span>              : #define _IEC_H </span>
<span class="lineNum">   23</span>              :  </span>
<span class="lineNum">   24</span>              :  </span>
<span class="lineNum">   25</span>              : &#047;* </span>
<span class="lineNum">   26</span>              :  *  Definitions </span>
<span class="lineNum">   27</span>              :  *&#047; </span>
<span class="lineNum">   28</span>              :  </span>
<span class="lineNum">   29</span>              : &#047;&#047; Maximum length of file names </span>
<span class="lineNum">   30</span>              : const int NAMEBUF_LENGTH = 256; </span>
<span class="lineNum">   31</span>              :  </span>
<span class="lineNum">   32</span>              : &#047;&#047; C64 status codes </span>
<span class="lineNum">   33</span>              : enum { </span>
<span class="lineNum">   34</span>              : 	ST_OK = 0,				&#047;&#047; No error </span>
<span class="lineNum">   35</span>              : 	ST_READ_TIMEOUT	= 0x02,	&#047;&#047; Timeout on reading </span>
<span class="lineNum">   36</span>              : 	ST_TIMEOUT = 0x03,		&#047;&#047; Timeout </span>
<span class="lineNum">   37</span>              : 	ST_EOF = 0x40,			&#047;&#047; End of file </span>
<span class="lineNum">   38</span>              : 	ST_NOTPRESENT = 0x80	&#047;&#047; Device not present </span>
<span class="lineNum">   39</span>              : }; </span>
<span class="lineNum">   40</span>              :  </span>
<span class="lineNum">   41</span>              : &#047;&#047; 1541 error codes </span>
<span class="lineNum">   42</span>              : enum { </span>
<span class="lineNum">   43</span>              : 	ERR_OK,				&#047;&#047; 00 OK </span>
<span class="lineNum">   44</span>              : 	ERR_SCRATCHED,		&#047;&#047; 01 FILES SCRATCHED </span>
<span class="lineNum">   45</span>              : 	ERR_UNIMPLEMENTED,	&#047;&#047; 03 UNIMPLEMENTED </span>
<span class="lineNum">   46</span>              : 	ERR_READ20,			&#047;&#047; 20 READ ERROR (block header not found) </span>
<span class="lineNum">   47</span>              : 	ERR_READ21,			&#047;&#047; 21 READ ERROR (no sync character) </span>
<span class="lineNum">   48</span>              : 	ERR_READ22,			&#047;&#047; 22 READ ERROR (data block not present) </span>
<span class="lineNum">   49</span>              : 	ERR_READ23,			&#047;&#047; 23 READ ERROR (checksum error in data block) </span>
<span class="lineNum">   50</span>              : 	ERR_READ24,			&#047;&#047; 24 READ ERROR (byte decoding error) </span>
<span class="lineNum">   51</span>              : 	ERR_WRITE25,		&#047;&#047; 25 WRITE ERROR (write-verify error) </span>
<span class="lineNum">   52</span>              : 	ERR_WRITEPROTECT,	&#047;&#047; 26 WRITE PROTECT ON </span>
<span class="lineNum">   53</span>              : 	ERR_READ27,			&#047;&#047; 27 READ ERROR (checksum error in header) </span>
<span class="lineNum">   54</span>              : 	ERR_WRITE28,		&#047;&#047; 28 WRITE ERROR (long data block) </span>
<span class="lineNum">   55</span>              : 	ERR_DISKID,			&#047;&#047; 29 DISK ID MISMATCH </span>
<span class="lineNum">   56</span>              : 	ERR_SYNTAX30,		&#047;&#047; 30 SYNTAX ERROR (general syntax) </span>
<span class="lineNum">   57</span>              : 	ERR_SYNTAX31,		&#047;&#047; 31 SYNTAX ERROR (invalid command) </span>
<span class="lineNum">   58</span>              : 	ERR_SYNTAX32,		&#047;&#047; 32 SYNTAX ERROR (command too long) </span>
<span class="lineNum">   59</span>              : 	ERR_SYNTAX33,		&#047;&#047; 33 SYNTAX ERROR (wildcards on writing) </span>
<span class="lineNum">   60</span>              : 	ERR_SYNTAX34,		&#047;&#047; 34 SYNTAX ERROR (missing file name) </span>
<span class="lineNum">   61</span>              : 	ERR_WRITEFILEOPEN,	&#047;&#047; 60 WRITE FILE OPEN </span>
<span class="lineNum">   62</span>              : 	ERR_FILENOTOPEN,	&#047;&#047; 61 FILE NOT OPEN </span>
<span class="lineNum">   63</span>              : 	ERR_FILENOTFOUND,	&#047;&#047; 62 FILE NOT FOUND </span>
<span class="lineNum">   64</span>              : 	ERR_FILEEXISTS,		&#047;&#047; 63 FILE EXISTS </span>
<span class="lineNum">   65</span>              : 	ERR_FILETYPE,		&#047;&#047; 64 FILE TYPE MISMATCH </span>
<span class="lineNum">   66</span>              : 	ERR_NOBLOCK,		&#047;&#047; 65 NO BLOCK </span>
<span class="lineNum">   67</span>              : 	ERR_ILLEGALTS,		&#047;&#047; 66 ILLEGAL TRACK OR SECTOR </span>
<span class="lineNum">   68</span>              : 	ERR_NOCHANNEL,		&#047;&#047; 70 NO CHANNEL </span>
<span class="lineNum">   69</span>              : 	ERR_DIRERROR,		&#047;&#047; 71 DIR ERROR </span>
<span class="lineNum">   70</span>              : 	ERR_DISKFULL,		&#047;&#047; 72 DISK FULL </span>
<span class="lineNum">   71</span>              : 	ERR_STARTUP,		&#047;&#047; 73 Power-up message </span>
<span class="lineNum">   72</span>              : 	ERR_NOTREADY		&#047;&#047; 74 DRIVE NOT READY </span>
<span class="lineNum">   73</span>              : }; </span>
<span class="lineNum">   74</span>              :  </span>
<span class="lineNum">   75</span>              : &#047;&#047; Mountable file types </span>
<span class="lineNum">   76</span>              : enum { </span>
<span class="lineNum">   77</span>              : 	FILE_IMAGE,			&#047;&#047; Disk image, handled by ImageDrive </span>
<span class="lineNum">   78</span>              : 	FILE_ARCH			&#047;&#047; Archive file, handled by ArchDrive </span>
<span class="lineNum">   79</span>              : }; </span>
<span class="lineNum">   80</span>              :  </span>
<span class="lineNum">   81</span>              : &#047;&#047; 1541 file types </span>
<span class="lineNum">   82</span>              : enum { </span>
<span class="lineNum">   83</span>              : 	FTYPE_DEL,			&#047;&#047; Deleted </span>
<span class="lineNum">   84</span>              : 	FTYPE_SEQ,			&#047;&#047; Sequential </span>
<span class="lineNum">   85</span>              : 	FTYPE_PRG,			&#047;&#047; Program </span>
<span class="lineNum">   86</span>              : 	FTYPE_USR,			&#047;&#047; User </span>
<span class="lineNum">   87</span>              : 	FTYPE_REL,			&#047;&#047; Relative </span>
<span class="lineNum">   88</span>              : 	FTYPE_UNKNOWN </span>
<span class="lineNum">   89</span>              : }; </span>
<span class="lineNum">   90</span>              :  </span>
<span class="lineNum">   91</span>              : static const char ftype_char[9] = &quot;DSPUL   &quot;; </span>
<span class="lineNum">   92</span>              :  </span>
<span class="lineNum">   93</span>              : &#047;&#047; 1541 file access modes </span>
<span class="lineNum">   94</span>              : enum { </span>
<span class="lineNum">   95</span>              : 	FMODE_READ,			&#047;&#047; Read </span>
<span class="lineNum">   96</span>              : 	FMODE_WRITE,		&#047;&#047; Write </span>
<span class="lineNum">   97</span>              : 	FMODE_APPEND,		&#047;&#047; Append </span>
<span class="lineNum">   98</span>              : 	FMODE_M				&#047;&#047; Read open file </span>
<span class="lineNum">   99</span>              : }; </span>
<span class="lineNum">  100</span>              :  </span>
<span class="lineNum">  101</span>              : &#047;&#047; Drive LED states </span>
<span class="lineNum">  102</span>              : enum { </span>
<span class="lineNum">  103</span>              : 	DRVLED_OFF,		&#047;&#047; Inactive, LED off </span>
<span class="lineNum">  104</span>              : 	DRVLED_ON,		&#047;&#047; Active, LED on </span>
<span class="lineNum">  105</span>              : 	DRVLED_ERROR	&#047;&#047; Error, blink LED </span>
<span class="lineNum">  106</span>              : }; </span>
<span class="lineNum">  107</span>              :  </span>
<span class="lineNum">  108</span>              : &#047;&#047; Information about file in disk image&#047;archive file </span>
<span class="lineNum">  109</span>              : struct c64_dir_entry { </span>
<span class="lineNum">  110</span>              : 	c64_dir_entry(const uint8 *n, int t, bool o, bool p, size_t s, off_t ofs = 0, uint8 sal = 0, uint8 sah = 0) </span>
<span class="lineNum">  111</span><span class="lineNoCov">      0  /  11: 		: type(t), is_open(o), is_protected(p), size(s), offset(ofs), sa_lo(sal), sa_hi(sah) </span>
<span class="lineNum">  112</span>              : 	{ </span>
<span class="lineNum">  113</span>              : 		strncpy((char *)name, (const char *)n, 17); </span>
<span class="lineNum">  114</span><span class="lineNoCov">      0  /   4: 		name[16] = 0; </span>
<span class="lineNum">  115</span>              : 	} </span>
<span class="lineNum">  116</span>              :  </span>
<span class="lineNum">  117</span>              : 	&#047;&#047; Basic information </span>
<span class="lineNum">  118</span>              : 	uint8 name[17];		&#047;&#047; File name (C64 charset, null-terminated) </span>
<span class="lineNum">  119</span>              : 	int type;			&#047;&#047; File type (see defines above) </span>
<span class="lineNum">  120</span>              : 	bool is_open;		&#047;&#047; Flag: file open </span>
<span class="lineNum">  121</span>              : 	bool is_protected;	&#047;&#047; Flag: file protected </span>
<span class="lineNum">  122</span>              : 	size_t size;		&#047;&#047; File size (may be approximated) </span>
<span class="lineNum">  123</span>              :  </span>
<span class="lineNum">  124</span>              : 	&#047;&#047; Special information </span>
<span class="lineNum">  125</span>              : 	off_t offset;		&#047;&#047; Offset of file in archive file </span>
<span class="lineNum">  126</span>              : 	uint8 sa_lo, sa_hi;	&#047;&#047; C64 start address </span>
<span class="lineNum">  127</span>              : }; </span>
<span class="lineNum">  128</span>              :  </span>
<span class="lineNum">  129</span>              : class Drive; </span>
<span class="lineNum">  130</span>              : class C64Display; </span>
<span class="lineNum">  131</span>              : class Prefs; </span>
<span class="lineNum">  132</span>              :  </span>
<span class="lineNum">  133</span>              : &#047;&#047; Class for complete IEC bus system with drives 8..11 </span>
<span class="lineNum">  134</span>              : class IEC { </span>
<span class="lineNum">  135</span>              : public: </span>
<span class="lineNum">  136</span>              : 	IEC(C64Display *display); </span>
<span class="lineNum">  137</span>              : 	~IEC(); </span>
<span class="lineNum">  138</span>              :  </span>
<span class="lineNum">  139</span>              : 	void Reset(void); </span>
<span class="lineNum">  140</span>              : 	void NewPrefs(Prefs *prefs); </span>
<span class="lineNum">  141</span>              : 	void UpdateLEDs(void); </span>
<span class="lineNum">  142</span>              :  </span>
<span class="lineNum">  143</span>              : 	uint8 Out(uint8 byte, bool eoi); </span>
<span class="lineNum">  144</span>              : 	uint8 OutATN(uint8 byte); </span>
<span class="lineNum">  145</span>              : 	uint8 OutSec(uint8 byte); </span>
<span class="lineNum">  146</span>              : 	uint8 In(uint8 &amp;byte); </span>
<span class="lineNum">  147</span>              : 	void SetATN(void); </span>
<span class="lineNum">  148</span>              : 	void RelATN(void); </span>
<span class="lineNum">  149</span>              : 	void Turnaround(void); </span>
<span class="lineNum">  150</span>              : 	void Release(void); </span>
<span class="lineNum">  151</span>              :  </span>
<span class="lineNum">  152</span>              : private: </span>
<span class="lineNum">  153</span>              : 	Drive *create_drive(const char *path); </span>
<span class="lineNum">  154</span>              :  </span>
<span class="lineNum">  155</span>              : 	uint8 listen(int device); </span>
<span class="lineNum">  156</span>              : 	uint8 talk(int device); </span>
<span class="lineNum">  157</span>              : 	uint8 unlisten(void); </span>
<span class="lineNum">  158</span>              : 	uint8 untalk(void); </span>
<span class="lineNum">  159</span>              : 	uint8 sec_listen(void); </span>
<span class="lineNum">  160</span>              : 	uint8 sec_talk(void); </span>
<span class="lineNum">  161</span>              : 	uint8 open_out(uint8 byte, bool eoi); </span>
<span class="lineNum">  162</span>              : 	uint8 data_out(uint8 byte, bool eoi); </span>
<span class="lineNum">  163</span>              : 	uint8 data_in(uint8 &amp;byte); </span>
<span class="lineNum">  164</span>              :  </span>
<span class="lineNum">  165</span>              : 	C64Display *the_display;	&#047;&#047; Pointer to display object (for drive LEDs) </span>
<span class="lineNum">  166</span>              :  </span>
<span class="lineNum">  167</span>              : 	uint8 name_buf[NAMEBUF_LENGTH];	&#047;&#047; Buffer for file names and command strings </span>
<span class="lineNum">  168</span>              : 	uint8 *name_ptr;		&#047;&#047; Pointer for reception of file name </span>
<span class="lineNum">  169</span>              : 	int name_len;			&#047;&#047; Received length of file name </span>
<span class="lineNum">  170</span>              :  </span>
<span class="lineNum">  171</span>              : 	Drive *drive[4];		&#047;&#047; 4 drives (8..11) </span>
<span class="lineNum">  172</span>              :  </span>
<span class="lineNum">  173</span>              : 	Drive *listener;		&#047;&#047; Pointer to active listener </span>
<span class="lineNum">  174</span>              : 	Drive *talker;			&#047;&#047; Pointer to active talker </span>
<span class="lineNum">  175</span>              :  </span>
<span class="lineNum">  176</span>              : 	bool listener_active;	&#047;&#047; Listener selected, listener_data is valid </span>
<span class="lineNum">  177</span>              : 	bool talker_active;		&#047;&#047; Talker selected, talker_data is valid </span>
<span class="lineNum">  178</span>              : 	bool listening;			&#047;&#047; Last ATN was listen (to decide between sec_listen&#047;sec_talk) </span>
<span class="lineNum">  179</span>              :  </span>
<span class="lineNum">  180</span>              : 	uint8 received_cmd;		&#047;&#047; Received command code ($x0) </span>
<span class="lineNum">  181</span>              : 	uint8 sec_addr;			&#047;&#047; Received secondary address ($0x) </span>
<span class="lineNum">  182</span>              : }; </span>
<span class="lineNum">  183</span>              :  </span>
<span class="lineNum">  184</span>              : &#047;&#047; Abstract superclass for individual drives </span>
<span class="lineNum">  185</span>              : class Drive { </span>
<span class="lineNum">  186</span>              : public: </span>
<span class="lineNum">  187</span>              : 	Drive(IEC *iec); </span>
<span class="lineNum">  188</span><span class="linePartCov">      1  /   9: 	virtual ~Drive() {} </span>
<span class="lineNum">  189</span>              :  </span>
<span class="lineNum">  190</span>              : 	virtual uint8 Open(int channel, const uint8 *name, int name_len)=0; </span>
<span class="lineNum">  191</span>              : 	virtual uint8 Close(int channel)=0; </span>
<span class="lineNum">  192</span>              : 	virtual uint8 Read(int channel, uint8 &amp;byte)=0; </span>
<span class="lineNum">  193</span>              : 	virtual uint8 Write(int channel, uint8 byte, bool eoi)=0; </span>
<span class="lineNum">  194</span>              : 	virtual void Reset(void)=0; </span>
<span class="lineNum">  195</span>              :  </span>
<span class="lineNum">  196</span>              : 	int LED;			&#047;&#047; Drive LED state </span>
<span class="lineNum">  197</span>              : 	bool Ready;			&#047;&#047; Drive is ready for operation </span>
<span class="lineNum">  198</span>              :  </span>
<span class="lineNum">  199</span>              : protected: </span>
<span class="lineNum">  200</span>              : 	void set_error(int error, int track = 0, int sector = 0); </span>
<span class="lineNum">  201</span>              :  </span>
<span class="lineNum">  202</span>              : 	void parse_file_name(const uint8 *src, int src_len, uint8 *dest, int &amp;dest_len, int &amp;mode, int &amp;type, int &amp;rec_len, bool convert_charset = false); </span>
<span class="lineNum">  203</span>              :  </span>
<span class="lineNum">  204</span>              : 	void execute_cmd(const uint8 *cmd, int cmd_len); </span>
<span class="lineNum">  205</span>              : 	virtual void block_read_cmd(int channel, int track, int sector, bool user_cmd = false); </span>
<span class="lineNum">  206</span>              : 	virtual void block_write_cmd(int channel, int track, int sector, bool user_cmd = false); </span>
<span class="lineNum">  207</span>              : 	virtual void block_execute_cmd(int channel, int track, int sector); </span>
<span class="lineNum">  208</span>              : 	virtual void block_allocate_cmd(int track, int sector); </span>
<span class="lineNum">  209</span>              : 	virtual void block_free_cmd(int track, int sector); </span>
<span class="lineNum">  210</span>              : 	virtual void buffer_pointer_cmd(int channel, int pos); </span>
<span class="lineNum">  211</span>              : 	virtual void mem_read_cmd(uint16 adr, uint8 len); </span>
<span class="lineNum">  212</span>              : 	virtual void mem_write_cmd(uint16 adr, uint8 len, uint8 *p); </span>
<span class="lineNum">  213</span>              : 	virtual void mem_execute_cmd(uint16 adr); </span>
<span class="lineNum">  214</span>              : 	virtual void copy_cmd(const uint8 *new_file, int new_file_len, const uint8 *old_files, int old_files_len); </span>
<span class="lineNum">  215</span>              : 	virtual void rename_cmd(const uint8 *new_file, int new_file_len, const uint8 *old_file, int old_file_len); </span>
<span class="lineNum">  216</span>              : 	virtual void scratch_cmd(const uint8 *files, int files_len); </span>
<span class="lineNum">  217</span>              : 	virtual void position_cmd(const uint8 *cmd, int cmd_len); </span>
<span class="lineNum">  218</span>              : 	virtual void initialize_cmd(void); </span>
<span class="lineNum">  219</span>              : 	virtual void new_cmd(const uint8 *name, int name_len, const uint8 *comma); </span>
<span class="lineNum">  220</span>              : 	virtual void validate_cmd(void); </span>
<span class="lineNum">  221</span>              : 	void unsupp_cmd(void); </span>
<span class="lineNum">  222</span>              :  </span>
<span class="lineNum">  223</span>              : 	char error_buf[256];	&#047;&#047; Buffer with current error message </span>
<span class="lineNum">  224</span>              : 	char *error_ptr;		&#047;&#047; Pointer within error message	 </span>
<span class="lineNum">  225</span>              : 	int error_len;			&#047;&#047; Remaining length of error message </span>
<span class="lineNum">  226</span>              : 	int current_error;		&#047;&#047; Number of current error </span>
<span class="lineNum">  227</span>              :  </span>
<span class="lineNum">  228</span>              : 	uint8 cmd_buf[64];		&#047;&#047; Buffer for incoming command strings </span>
<span class="lineNum">  229</span>              : 	int cmd_len;			&#047;&#047; Length of received command </span>
<span class="lineNum">  230</span>              :  </span>
<span class="lineNum">  231</span>              : private: </span>
<span class="lineNum">  232</span>              : 	IEC *the_iec;			&#047;&#047; Pointer to IEC object </span>
<span class="lineNum">  233</span>              : }; </span>
<span class="lineNum">  234</span>              :  </span>
<span class="lineNum">  235</span>              :  </span>
<span class="lineNum">  236</span>              : &#047;* </span>
<span class="lineNum">  237</span>              :  *  Functions </span>
<span class="lineNum">  238</span>              :  *&#047; </span>
<span class="lineNum">  239</span>              :  </span>
<span class="lineNum">  240</span>              : &#047;&#047; Convert ASCII character to PETSCII character </span>
<span class="lineNum">  241</span>              : extern uint8 ascii2petscii(char c); </span>
<span class="lineNum">  242</span>              :  </span>
<span class="lineNum">  243</span>              : &#047;&#047; Convert ASCII string to PETSCII string </span>
<span class="lineNum">  244</span>              : extern void ascii2petscii(uint8 *dest, const char *src, int max); </span>
<span class="lineNum">  245</span>              :  </span>
<span class="lineNum">  246</span>              : &#047;&#047; Convert PETSCII character to ASCII character </span>
<span class="lineNum">  247</span>              : extern char petscii2ascii(uint8 c); </span>
<span class="lineNum">  248</span>              :  </span>
<span class="lineNum">  249</span>              : &#047;&#047; Convert PETSCII string to ASCII string </span>
<span class="lineNum">  250</span>              : extern void petscii2ascii(char *dest, const uint8 *src, int max); </span>
<span class="lineNum">  251</span>              :  </span>
<span class="lineNum">  252</span>              : &#047;&#047; Check whether file is a mountable disk image or archive file, return type </span>
<span class="lineNum">  253</span>              : extern bool IsMountableFile(const char *path, int &amp;type); </span>
<span class="lineNum">  254</span>              :  </span>
<span class="lineNum">  255</span>              : &#047;&#047; Read directory of mountable disk image or archive file into c64_dir_entry vector </span>
<span class="lineNum">  256</span>              : extern bool ReadDirectory(const char *path, int type, vector&lt;c64_dir_entry&gt; &amp;vec); </span>
<span class="lineNum">  257</span>              :  </span>
<span class="lineNum">  258</span>              : #endif </span>
</pre>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr><td class="ruler"><img src="glass.png" width="3" height="3" alt=""/></td></tr>
  <tr><td class="versionInfo">Generated by: <a href="http://simonkagstrom.github.com/kcov/index.html">Kcov</a> (based on <a href="http://bcov.sourceforge.net">bcov</a>)</td></tr>
</table>
<br/>
</body>
</html>
